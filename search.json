[{"title":"复现FAST-LIVO2","url":"/2025/07/04/复现FAST-LIVO2/","content":"\n# 项目名称 : FAST-LIVO2复现\n\n## 任务规划\n\n- 设备:\n  1. Livox AVIA\n  2. Livox Converter 2.0\n  3. 海康相机MV-CS020-10UC\n\n- 硬件:\n\n  1. 手持设备支架设计(Solidworks)\n\n  2. STM32硬同步流程\n\n  3. 相机-Lidar标定\n\n- 软件:\n\n  1. 环境,build\n  2. 录包,跑包\n\n\n## 论文阅读\n\n### FAST-LIVO\n\n- LIO 子系统: 反向传播补偿 LiDAR 扫描的运动畸变,计算帧到地图点到平面的残差。\n\n- VIO 子系统: 提取当前 FoV 中的视觉子映射,剔除异常值。\n\n- 视觉对齐: 稀疏直接图像对齐,比较光流误差。\n\n- 紧密耦合: 点到平面残差和图像光度误差与误差状态iKF中的IMU传播紧密耦合。\n\n- ikdTree添加新点至全局映射。\n\n  <img src=\"../images/复现FAST-LIVO2/1.png\" alt=\"1\" style=\"zoom: 50%;\" />\n\n  \n\n### FAST-LIVO2\n\n#### 新贡献\n\n1. 问题 : 激光雷达和视觉测量之间维度不匹配 (测量维度 / 数据类型 / 分布特性) , 而 FAST-LIVO中使用异步更新。\n\n   解决方案 : ESIKF框架,惯顺序更新(sequential update)。\n\n2. 问题 : FAST-LIVO中假设图像块中所有像素共享相同深度,该假设降低了对齐中仿射变换的准确性。\n\n   解决方案 : 使用并进一步优化来自激光雷达点的平面先验。\n\n3. 问题: FAST-LIVO 基于与当前视图的接近度选择参考块,导致参考块低质量,降低了准确性。\n\n   解决方案 : 提出了一种参考块 Reference Patch 更新策略 ,通过选择具有大视差和足够纹理细节的高质量内点参考块提高图像对齐的准确性。\n\n4. 问题 : 环境光照变化会降低图像对齐中的收敛性,FAST-LIVO中未解决该问题。\n\n   解决方案 : 在线曝光时间估计。\n\n5. 问题 : 激光雷达近距离盲区造成激光雷达点测量缺失,FAST-LIVO中未考虑该问题。\n\n   解决方案 : 提出按需进行体素射线投射的方法，以增强系统在因激光雷达近距离盲区造成的激光雷达点测量缺失情况下的鲁棒性。 \n\n   <img src=\"../images/复现FAST-LIVO2/34.png\" alt=\"系统概览\" style=\"zoom:67%;\" />\n\n#### Section 4 顺序更新的ESIKF\n\n1. 扫描重组 Scan Recombination\n\n    1.  将$t_k-1$时刻到$t_k$时刻的所有激光点都合并到$t_k$时刻。\n\n        将高频、连续采样的LiDAR原始点云数据，按照相机采样时刻进行分割，从而得到与相机采样时刻对应的独立LiDAR扫描帧。\t\n\n   2. 通过硬同步使雷达和相机采样一致\n\n      激光雷达和相机在$t_k-1$ 时刻同时触发采集，但相机在瞬间完成采集，激光雷达则在$t_k$时刻才完成一帧数据。虽然触发时间相同，系统实际处理的是$t_k$时刻图像与延迟 $t$ (约100ms) 的激光雷达帧。\t\n\n2. 传播 Propagation\n\n<img src=\"../images/复现FAST-LIVO2/35.png\" alt=\"前向传播与反向传播\" style=\"zoom: 33%;\" />\n\n​\t1. 前向传播：KF在预测阶段将噪声$W_i$ 设为0，预测$t_k-1$ 到$t_k$ 这段时间每个IMU输入时的状态。由KF预测可得\t此时状态量为$\\hat{x}$，状态量对应的协方差$\\hat{P}$作为更新阶段的先验。\n\n​\t2. 反向传播 : 补偿激光雷达运动畸变，确保所有的点都是在tk时刻观测到的。\n\n​\t运动畸变 : 由于激光雷达在移动过程中分时采点，若忽略每个点的具体采集时间,统一视为同一时刻采样，会导致\t点云在空间上的扭曲或错位。\n\n<img src=\"../images/复现FAST-LIVO2/36.png\" alt=\"反向传播\" style=\"zoom:67%;\" />\n\n​\t3. 顺序更新 : 利用激光雷达测量细化的状态将被更新地图的几何结构，该状态将在视觉更新被进一步收敛，其中\t视觉更新将在每个金字塔层面上进行，每层都要收敛。最终得到的状态被用于传播新到来的IMU测量，并更新地\t图的视觉结构（纹理）。\n\n#### Section 5 局部建图\n\n1. 地图结构 Map Structure\n\n   <img src=\"../images/复现FAST-LIVO2/37.png\" alt=\"Voxel Map\" style=\"zoom: 33%;\" />\n\n​\t**自适应体素结构**,按照哈希表和每个哈希条目的八叉树组织。\n\n​\t哈希表管理根体素,每一个根体素为0.5x0.5x0.5m的固定维度,每个根体素包含一个八叉树结构。叶体素代表一个局部平面,存储一个平面特征(即平面中心、法向量和不确定性),以及一组位于该平面上的激光雷达原始点。**叶体素的不同大小使其能够表示不同尺度的局部平面,从而适应具有不同结构的环境**。部分点与三级图像块(8×8图块大小)相连(即视觉地图点),收敛的视觉地图点仅与参考块关联，未收敛的点与参考块和其他可见块都关联。\n\n​\t为了防止地图大小无限增长,设置初始地图范围后, 在该范围进行进行探测和建图，当雷达探测范围触碰到范围边界，局部地图范围会在该边界方向上移动d距离。存储的A处点云数据将被重置为C处的数据,保持内存大小固定。每次ESIKF更新后检查一次地图是否移动。\n\n<img src=\"../images/复现FAST-LIVO2/38.png\" alt=\"局部地图滑动\" style=\"zoom: 50%;\" />\n\n*在(a)中,灰色矩形是初 始地图区域,长度为 L。红色圆圈是以 p0 为中心的初始 检测区域。在(b)中,检测区域移动到新位置 p1,在此位 置触碰到地图边界。地图区域移动到新位置(蓝色矩形) ,移动距离为 d。在(c)中,内存空间B保持不变。存储绿色区域的内存空间A被重置为(b)中的蓝色区域C。*\n\n2. 几何构造及更新 : **基于ESIKF对激光雷达点测量构建和更新实现**\t<a name=\"Section5-2\"></a>\n\n   在ESIKF中的激光雷达更新后,将激光雷达扫描的所有点注册到全局坐标系中。对于每个注册的激光雷达点,确定其在哈希图中的根体素位置。\n\n   - 如果不存在,用新点初始化该体素并将其索引到哈希图中。\n\n   - 如果确定的体素已经存在于地图中, 将该点附加到现有体素中。\n\n   在所有扫描中的点分配完成后,进行几何构建和更新。\n\n   1. 对于新创建的体素\n\n      通过奇异值分解来确定其所有包含的点是否位于一个平面上。\n\n      - 如果是,计算中心点 $ q = p ̄$ 、平面法线 $n$ 和平面的协方差矩阵$ Σ_{n,q} $。$ Σ_{n,q} $ 用于表征平面不确定性 (平面不确定性源于姿态估计的不确定性和点测量噪声)。\n      - 如果不是,体素将不断细分为八个更小的八分体,直到子体素中的点被确定为形成一个平面或达到最大层数。达到最大层数后,叶体素中的点将被丢弃。\n      - **地图仅包含被识别为平面的体素(根体素或子体素)。**\n\n   2. 对于已存在的体素\n\n      评估新的点和已有的点能否构建为一个平面\n\n      -  如果否：和前面一样，对体素进行划分。\n      -  如果是：更新平面参数和协方差。\n      -  **一旦平面参数是收敛的，该平面将被视为成熟面，平面参数将被视为固定，平面上的新点将被丢弃。**\n\n   3. 平面上的激光雷达点生成视觉地图点\n\n      - 对于成熟的平面,最近的50个雷达点是生成视觉地图点的候选者。\n\n      - 对于未成熟的平面,所有雷达点都是候选者。\n\n      - 视觉地图点生成过程将识别其中一些候选点作为视觉地图点,并将它们与图像块附加以进行图像对齐。\n\n3. 视觉地图点生成和更新\n\n   选择地图中的候选激光雷达点用于生成和更新。([详见第Section 7-1](#Section7-1))\n\n   候选点条件:\n\n   1. 在当前帧视角可见\n   2. 在当前图像中表现出显著灰度梯度\n\n   在视觉更新后,将候选点投影到当前图像上,并**在每个体素中保留最小深度的候选点作为局部平面。将当前图像划分为每个30 × 30像素的均匀网格单元。**\n\n   - 若一个栅格元没有包含任何投影到这的视觉地图点,则使用**带有最高灰度梯度的候选点新建一个新的视觉地图点**。将该点与当前图像块、估计的当前状态（位姿/曝光时间）以及平面法向量相关联。与视觉地图点相关联的块有三个相同大小的层（每层11x11像素）,构成块金字塔。\n\n   - 若一个栅格元包含了投影的视觉地图点，并满足以下条件之一就添加新的块到当前视觉地图点上:\n     1. 超过20帧没有添加新的块到视觉地图点。\n     2. 视觉地图点在当前帧中的像素位置比其在上一个块的位置相差至少40像素（晃得太厉害，点在屏幕里移动了一大段距离，重新拍一张）。\n\n   **地图点将拥有视角分布均匀的有效块Patch。**\n\n4.  Reference Patch 参考块更新 : 一个视觉地图点会拥有不止一个块。需要选择一个作为参考块用于视觉更新中的图像对齐，基于光度相似性和视角给每个块 f 评分。在所有附加到视觉地图点的Patch中,得分最高的Patch被更新为参考块。\n\n   上述评分机制倾向于选择:\n\n   \t1. 外观与大多数其他补丁相似(以NCC为标准)的参考补丁, 以避免动态目标上的补丁;\n   \t1. 视角方向与平面正交,从而在高分辨率下保持纹理细节。\n\n   FAST-LIVO 中的参考块更新策略直接选择与当前帧视角方向差异最小的补丁,导致所选参考补丁与当前帧非常接近,从而对当前姿态更新施加了弱约束。\n\n5. 法向量细化\n\n   每个视觉地图点都被假设位于一个小的局部平面上。（以前的研究假设像素块上的所有像素拥有同样深度）\n\n   使用源于雷达点的平面参数取得更好的精度[(详见第Section 5-2)](#Section5-2)。 \n\n   平面法向量对于视觉更新过程中的图像仿射变换对齐至关重要,平面法向量细化能够增强仿射变换的精度。 \n\n   具体：**通过最小化参考块与视觉地图点关联的其他块之间的光度误差，来优化参考块中的平面法向量。**\n\n#### Section 6 激光雷达测量模型\n\n用于ESIKF LiDAR更新的LiDAR测量模型$y_l = h_l(x, v_l)$。\n\n1. 点到平面的雷达测量模型\n\n   - 投影无畸变点到世界系;\n\n   - 确定该世界点所在哈希图的根/子体素，并构建观测公式\n\n     如果没有体素被发现或该体素不包含平面则丢弃该点。 否则，构建该体素中平面与这个点的观测公式。 假设一个激光真值点，准确的到世界系变换阵，这个点与平面中心点应该是在一个平面上的。\n\n   - 带入激光点测量和噪声，平面法向量估计和中心点估计及协方差,\n\n     得到测量噪声的形式:$v_l=(δ^L\\mathbf{p}_j,δ\\mathbf{n}_j,δ\\mathbf{q}_j)$\n\n2. 带有光束发散效应的Lidar测量噪声\n\n   测量噪声主要由两个元素构成，飞行时间导致的测距不确定性和编码导致的轴承方向不确定性，除此外，还有激光的发散角度。随着方位方向与法向量之间的角度 $φ$的增加，激光雷达点的测距不确定性显著增加，而方位方向的不确定性不受影响。当从地面和墙面选的点更多时，位姿估计的精度更高。 **$φ$越小越好**。\n\n#### Section 7 视觉测量模型\n\n用于ESIKF视觉更新的视觉测量模型$y_c = h_c(x, v_c)$。\n\n1.视觉地图点选择<a name=\"Section7-1\"></a>\n\n为了视觉更新中的稀疏对齐，首先选择合适的视觉地图点。 \n\n- 使用体素和投射查询来提取当前相机FoV中的可见的地图点集合（视觉的子地图）。 \n\n- 来自这个子地图中视觉地图点将被挑选并剔除离群点。 \n\n- 这个过程能够为**视觉测量模型中构建视觉光度误差提供一个精细的视觉地图点集合**。\n\n   1.  可见体素的查询 : \n\n       问题: 地图中体素数量庞大,从地图中的大量体素中确定当前帧FoV中的地图体素困难。\n\n       解决：利用当前LiDAR扫描直接命中的体素作为候选，大幅减少需处理的体素数量。 \n\n       实现：1、使用测量的点位置来查询体素哈希表\n\n       ​\t   2、筛选上一图像帧中通过相同体素查询和光线投射确认为可见的地图点所命中的体素。 \n\n       最后,通过检查这两种体素中包含的地图点并进行视场检查,得到当前的视觉子图。\n\n  2. 按需投射 :\n\n     <img src=\"../images/复现FAST-LIVO2/39.png\" alt=\"按需体素光线投射的示意图\" style=\"zoom: 67%;\" />\n\n     当雷达距离目标太近而没有点返回时/摄像机FOV可能不会被激光雷达FOV完全覆盖。流程如下 :\n\n     1. 图像划分\n        将图像划分为30x30的均匀栅格元，投影体素查询获得的视觉地图点到栅格元上。\n\n     2. 对未被占据栅格元的射线投射\n        对于每个未被视觉地图点占据的栅格元，光线沿着中心像素向后投射，其中采样点沿着光线在深度方向上从dmin到dmax均匀分布\n\n     3. 降低计算量\n        相机机体系下每个光线上的采样点的位置都被预先算好了。\n\n     4. 处理每个采样点\n        对每个采样点，评估其对应的体素状态：\n        若该体素包含投影后位于此网格单元内的地图点，则将这些地图点纳入视觉子地图，并终止当前射线的处理。\n        否则：继续射线上的下一个采样点，直到达到最大深度DMAX。\n\n     5. 所有未被占据栅格元处理完成\n        获得了一组在整个图像上分布的视觉地图点集合。\n\n  3. 视觉地图点中离群点剔除\n\n     <img src=\"../images/复现FAST-LIVO2/40.png\" alt=\"剔除离群点\" style=\"zoom: 67%;\" />\n\n     存在的问题: 将会严重降低图像对齐精度\n\n     ​\t(1) 在当前帧中被遮挡\n\n     ​\t(2) 存在深度不连续性\n\n     ​\t(3) 拥有这些点的参考块采集视角过大\n\n     ​\t(4) 在当前帧中观测视角过大\n\n     1. 投影所有点--解决问题1\n\n        在雷达更新后，将子图中的所有视觉地图点用位姿投影至当前帧，并在每个栅格元中保留深度最小的点。\n\n     2. 深度图--解决问题2\n\n        将当前雷达帧的点投影至当前帧生成深度图，用9x9的邻域在深度图中比较视觉地图点的深度，并判断遮挡和深度变化。被占据的/深度不连续的点将被剔除。\n\n     3. 点移除--解决问题3&4\n\n        移除参考块与当前块的视角太大（法向量与从视觉地图点到块光学中心的方向之间的角度超过80°）的点。\n\n\n2. 稀疏直接的视觉测量模型\n\n上面提取的视觉地图点 {$G_{pi}$} 用于构建视觉测量模型。 其基本原理是,利用真值状态将地图点投影至当前图像，参考块与当前块之间的光度误差应当为0. \n\n要根据测量方程估算反向曝光时间 $τ_k$，将初始反向曝光时间固定为 $τ_0$ = 1 ，以消除方程在所有反向曝光时间都为零时的退化现象。后续帧的估计反向曝光时间是相对于第一帧的曝光时间。测量方程被用于三个层次的视觉更新步骤,估计的状态随后用于生成可视化地图点和更新参考块。\n\n\n\n## 本机环境 (和Fast-Livo2无关)\n\n只是电脑又坏了。\n\n1. NVIDIA驱动 : \n\n   - **关闭bios security boot**\n\n   - 在命令行模式下删除之前安装的nvidia驱动\n\n     ```shell\n     Ctrl + Alt + F3\n     sudo systemctl stop gdm\n     sudo apt-get purge '^nvidia-.*'\n     sudo apt-get autoremove\n     sudo rm -rf /etc/X11/xorg.conf\n     sudo rm -rf /lib/modules/$(uname -r)/kernel/drivers/video/nvidia*\n     sudo rm -rf /usr/src/nvidia*\n     sudo rm -rf /usr/share/doc/NVIDIA_GLX-1.0*\n     sudo rm -rf /usr/share/man/man1/nvidia*\n     sudo rm -rf /usr/bin/nvidia*\n     sudo rm -rf /etc/modprobe.d/blacklist-nvidia.conf\n     ```\n\n   - 重新安装,选择recommend的版本\n\n     ``` shell\n     sudo ubuntu-drivers devices # 查看可以使用的驱动版本\n     ```\n\n   - 重启\n\n     ``` shell\n     reboot\n     ```\n\n   - 检查\n\n     ```shell\n     nvidia-smi\n     ```\n\n     \n\n## NUC环境搭建\n\n### 1. 修网卡 \n\n```shell\nfast@fast:~/WIFI/backport-iwlwifi$ lspci | grep -i wireless\nfast@fast:~/WIFI/backport-iwlwifi$ lsmod | grep iwl\n```\n\n系统没有识别出无线网卡设备,疑似硬件问题.最后使用网线上网.\n\n### 2. 依赖项\n\n- PCL>=1.8, Follow [PCL Installation](https://pointclouds.org/).\n\n- Eigen>=3.3.4, Follow [Eigen Installation](https://eigen.tuxfamily.org/index.php?title=Main_Page).\n\n- OpenCV>=4.2, Follow [Opencv Installation](http://opencv.org/).\n\n- Livox_SDK2 :\n\n  ```shell\n  git clone https://github.com/Livox-SDK/Livox-SDK2.git\n  cd ./Livox-SDK2/\n  mkdir build\n  cd build\n  cmake .. && make -j\n  sudo make install\n  ```\n\n- Sophus : Sophus Installation for the non-templated/double-only version.\n\n  ``` shell\n  git clone https://github.com/strasdat/Sophus.git\n  cd Sophus\n  git checkout a621ff\n  mkdir build && cd build && cmake ..\n  make\n  sudo make install\n  ```\n\n \n\n### 3. 工作空间配置\n\nAvia只支持livox_ros_driver\n\nlivox_ros_driver可以不着急先编译,等最后一起build\n\n- FAST_LIVO2 : https://github.com/hku-mars/FAST-LIVO2.git\n\n- livox_ros_ driver :  https://github.com/xuankuzcr/LIV_handhold.git\n\n   [<说明>](#change)硬同步需要使用这个github库中的livox_ros_driver,**对比官方,这里做了硬同步的改动，增加了对共享内存写入时间戳的功能** \n\n- mvs_ros_pkg : https://github.com/xuankuzcr/LIV_handhold.git \t<a name=\"mvs_ros_pkg\"></a>\n\n   <说明>硬同步需要使用这个github库中的相机ros驱动\n\n- rpg_vikit : https://github.com/xuankuzcr/rpg_vikit.git (使用这个url,否则编译时出错)\n\n   \n\n### 4. Build \n\n``` shell\ncd ~/fast_livo2_ws/src\ncd livox_ros_driver2\n./build.sh ROS1\ncd ../..\ncatkin_make\nsource ~/fast_livo2_ws/devel/setup.bash\n```\n\n​\t<a name=\"change\"></a>\n\n#### 说明\n\n- 关于[LIV_handhold](https://github.com/xuankuzcr/LIV_handhold)中**livox_ros_driver**的改动\n\n  使用meld对比两份文件夹 ,  新的livox_ros_driver增加了共享内存以及对共享内存写入时间戳的功能.\n\n```c++\n+ livox_ros_driver.cpp\n\t // 将文件映射为一个共享内存区域，大小为sizeof(time_stamp)，通过指针pointt可以直接读写它。\n\t  const char *user_name = getlogin();\n      std::string path_for_time_stamp = \"/home/\" + std::string(user_name) + \"/timeshare\";\n      const char *shared_file_name = path_for_time_stamp.c_str();\n      int fd = open(shared_file_name, O_CREAT | O_RDWR | O_TRUNC, 0666);\n      if (fd == -1) {\n        ERR_EXIT(\"open\");\n      } else {\n        printf(\"open code: %d\\n\", fd);\n      }\n      lseek(fd, sizeof(time_stamp) * 1, SEEK_SET);\n      write(fd, \"\", 1);\n      pointt = (time_stamp *)mmap(NULL, sizeof(time_stamp) * 1,\n                                  PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n```\n\n- 关于[LIV_handhold](https://github.com/xuankuzcr/LIV_handhold)中**livox_ros_driver2**的改动\n\n  新的livox_ros_driver2增加了共享内存以及对共享内存写入时间戳的功能.\n\n```c++\n+lddc.cpp\n    // 实现了用一个普通文件作为共享内存的载体，进程间可以通过映射该文件进行数据共享。\n    // 结构体time_stamp用于在多个进程（或设备驱动与应用程序）间共享硬件时间戳。\n    //******************************************************************** add code\n    if (isOpended == false)\n    {\n      const char *user_name = getlogin();\n      std::string path_for_time_stamp = \"/home/\" + std::string(user_name) + \"/timeshare\";\n\n      const char *shared_file_name = path_for_time_stamp.c_str();\n      int fd = open(shared_file_name, O_CREAT | O_RDWR | O_TRUNC, 0666);\n      if (fd == -1)\n      {\n        ROS_ERROR(\"open failed\\n\");\n        isOpended = false;\n      }\n      else\n      {\n        ROS_ERROR(\"open code: %d\\n\", fd);\n        isOpended = true;\n      }\n      lseek(fd, sizeof(time_stamp) * 1, SEEK_SET);\n      write(fd, \"\", 1);\n      pointt = (time_stamp *)mmap(NULL, sizeof(time_stamp) * 1,\n                                  PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    }\n    //********************************************************************\n```\n\n\n\n## STM32硬同步\n\n### 1. 材料\n\n- 工程文件 : [stm32_timersync-open](https://github.com/xuankuzcr/LIV_handhold/tree/main/stm32_timersync-open)\n- 烧录器 : ST-LINK V2\n- STM32F103C8T6\n- TTL to USB\n- TTL to RS485\n\n### 2. 原理图\n\n![论文硬同步原理图](../images/复现FAST-LIVO2/15.png)\n\nLivox_avia不支持直接读取GPRMC格式的指令,mid360支持直接读取.如果使用mid360连线原理图将会改变.本篇只考虑Livox_avia.\n\n![逻辑原理图](../images/复现FAST-LIVO2/16.png)\n\n![原理图](../images/复现FAST-LIVO2/19.png)\n\n### 3. 硬件连线图\n\n**硬件连线参考图 : ** \n\n![硬件连线图](../images/复现FAST-LIVO2/31.png)\n\n相机线说明 :\n\n相机的电源及 I/O 接口为 6-pin P7 接口。\n\n<img src=\"../images/复现FAST-LIVO2/32.png\" alt=\"相机线\" style=\"zoom:67%;\" />\n\nLivox Converter 2.0 同步线说明 :\n\n<img src=\"../images/复现FAST-LIVO2/33.png\" alt=\"雷达同步线\" style=\"zoom:67%;\" />\n\n\n\n### 4. 雷达设置\n\n#### Livox雷达时间同步说明\n\n参考:https://github.com/Livox-SDK/Livox-SDK/wiki/livox-device-time-synchronization-manual-cn#%E9%99%84%E5%BD%95\n\nLivox设备支持3种时间同步方式：\n\n- PTP：IEEE 1588v2.0 PTP 网络协议同步；\n- GPS：秒脉冲+GPRMC时间数据，组成GPS时间同步方式；\n- PPS：秒脉冲同步，需要上层应用程序通过其他途径（如：uart）获取每个脉冲的时间信息，并修正点云时间。\n\nFAST-LIO只涉及GPS和PPS两种,只介绍这两种.\n\n##### GPS\n\nGPS时钟源的PPS端口每秒发送一次硬件脉冲（PPS信号），随后数据端口发送一次对应这个脉冲上升沿的时间信息（GPRMC格式）。Livox设备接收到PPS信号上升沿，并由GPRMC数据解析出正确的时间信息后，会设置点云时间为GPS时间，并保持此时间基准持续累加，来实现和GPS设备的时间同步。\n\n![GPS原理图](../images/复现FAST-LIVO2/17.png)\n\n**Livox Converter 2.0**将GPS模块的时间信号（GPRMC）通过TTL转usb模块接入PC，PPS信号接入LiDAR转接盒同步口（Sync Port）。\n\n<img src=\"../images/复现FAST-LIVO2/18.png\" style=\"zoom: 67%;\" />\n\n##### PPS\n\nLivox LiDAR每次接收到PPS信号的上升沿后，会将当前时刻的点云时间置为0，然后重新开始计时直到下一个PPS脉冲到来,利用这个特性，来实现PPS脉冲对LiDAR时间的同步。\n\n伪代码:\n\n```c\n// PPS Time Synchronization\nstatic uint64_t lidar_time_last;\nstatic uint64_t lidar_time_real;\n\n// 1. Read the PPS rising edge time, Unit is nanosecond.\nuint64_t pps_time_ns = get_pps_rising_nsecond();\n// 2. Read LiDAR point time, Unit is nanosecond.\nuint64_t lidar_time = get_lidar_pack_time();\n// 3. Update real time.\nif (lidar_time < lidar_time_last)\n{\n    //LiDAR time jump indicates the generation of PPS rising edge.\n    lidar_time_real = pps_time_ns + lidar_time%(1000000000);\n}\nelse\n{\n    lidar_time_real += lidar_time - lidar_time_last;\n}\n//Update history\nlidar_time_last = lidar_time;\n```\n\n#### 雷达设置\n\n#### 1. 安装Livox Viewer\n\n Livox Viewer 0.10.0(64bit) : https://www.livoxtech.com/downloads\n\n> 注：Livox Viewer2并不支持Avia\n\n以太网设置:\n\n<img src=\"../images/复现FAST-LIVO2/47.jpg\" style=\"zoom: 50%;\" />\n\n点击左上角播放按钮,出现点云.\n\n<img src=\"../images/复现FAST-LIVO2/48.jpg\" style=\"zoom: 67%;\" />\n\n插上硬同步设备后,查看雷达的连接转态和数据的读取状态，来确认雷达是否已进入PPS同步状态\n\n<img src=\"../images/复现FAST-LIVO2/49.png\" style=\"zoom: 67%;\" />\n\n1.livox_lidar_config.json中，修改参数值：\n\n\n\n#### 相机设置\n\n相机 : 海康相机MV-CS020-10UC\n\n驱动 : MVS_STD_V3.0.1\n\n##### 1. 安装驱动\n\n海康威视工业相机SDK的ros驱动依赖MVS的库文件，先安装MVS客户端.\n\n官方下载地址：[https://www.hikrobotics.com/cn/machinevision/service/download/?module=0](https://gitee.com/link?target=https%3A%2F%2Fwww.hikrobotics.com%2Fcn%2Fmachinevision%2Fservice%2Fdownload%2F%3Fmodule%3D0)\n\n##### 2. 下载和编译相机的雷达ros驱动\n\n (见[NUC环境搭建 - 3.工作空间配置](#mvs_ros_pkg))\n\n##### 3. 调整配置文件 \n\n路径 : mvs_ros_driver/config\n\n```yaml\n%YAML:1.0\n\n#--------------------------------------------------------------------------------------------\n# Camera Parameters. Adjust them!\n#--------------------------------------------------------------------------------------------\nSerialNumber: \"DA2099368\" # Not needed for single camera. Specify serial number for multiple cameras. \nTopicName: \"left_camera/image\"\n\nTriggerEnable: 1 # 0 stands for Off, 1 stands for On\n\nExposureAutoMode: 0 # 0 stands for Off, 1 stands for Once, 2 stands for Continues\nExposureTime: 5000 # us\n\n# ExposureAutoMode: 2\n# AutoExposureTimeLower: 100\n# AutoExposureTimeUpper: 20000\n\nimage_scale: 0.5 # 1 0.5\nGainAuto: 2 # Gain Auto, 0 stands for Off, 1 stands for Once, 2 stands for Continues\nGain: 15 # min: 0   max: 17.0166\nGamma: 0.7  # min: 0   max: 17.0166\nGammaSelector: 1 # 0 stands for user, 1 stands for sRGB\n# GammaEnable: 1\n\nPixelFormat: 0 # 0: RGB8, 1: BayerRG8, 2: BayerRG12Packed, 3: BayerGB12Packed, 4: BayerGB8\n```\n\n最重要的参数是**PixelFormat**,需要根据相机型号调整。遍历一遍看哪个数值可用当然可以,代价是报错的时候不能理解其中原因,会造成很多麻烦。\n\n**如何找到适合本相机的PixelFormat :**\n\n- 查阅海康相机官网https://www.hikrobotics.com/cn/machinevision/productdetail/?id=12379\n\n![海康相机官网详细参数](../images/复现FAST-LIVO2/41.png)\n\n​\t看似这个相机支持RGB8 / BayerRG8 / BayerRG12Packed, PixelFormat选择0/1/2都可以, 实则不然。\n\n​\t当选择1或2的时候,运行`roslaunch mvs_ros_driver mvs_camera_trigger.launch`时, 出现报错 :\n\n<img src=\"../images/复现FAST-LIVO2/42.jpg\" alt=\"报错\" style=\"zoom:50%;\" />\n\n​\t针对这个报错, 打开MVS的官方图形化界面看一下 : \n\n​\t图形化界面参数太多了,再查阅海康机器人USB3.0工业面阵相机用户手册,发现Gamma参数应该在Analog Control 属性中.\n\n<img src=\"../images/复现FAST-LIVO2/43.png\" alt=\"海康相机用户手册详细参数\" style=\"zoom:33%;\" />\n\n​\t在Bayer RG 8 / BayerRG12Packed模式下 , 没有Gamma这个参数 ．只有在RGB8模式下才有Gamma参数．\n\n<img src=\"../images/复现FAST-LIVO2/44.jpg\" alt=\"海康相机用户手册详细参数\" style=\"zoom: 80%;\" />\n\n<img src=\"../images/复现FAST-LIVO2/45.jpg\" alt=\"海康相机用户手册详细参数\" style=\"zoom: 80%;\" />\n\n​\t探究一下原理：\n\n- Bayer 格式是原始图像数据（Raw），`Bayer RG8` 是未经过处理的原始图像数据格式，每个像素仅包含单色信息（红、绿或蓝中的一个）。在这种格式下，图像还没有完成 去马赛克（Demosaicing）、白平衡、Gamma 校正等ISP流程。\n\n- RGB8 是处理后的彩色图像格式，可以进行Gamma调节．\n\n  > 注 : 如果把yaml文件中的Gamma和GammaSelector注释掉,该驱动包也能正常跑.但是之后我都选择使用**RGB8**格式,故BayerRG8 / BayerRG12Packed能否跑完全流程并不确定．\n\n##### 4. 测试\n\n- 如果需要**单独测试相机驱动**,需要把mvs_ros_driver/config中的**TriggerEnable参数改为0**,否则节点无图像数据！\n\n- 相机插NUC的**USB3.0**的插口\n\n- 指令\n\n  ```shell\n  roslaunch mvs_ros_pkg mvs_camera_trigger.launch\n  ```\n\n  rviz中查看图像是否正常输出．\n\n  <img src=\"../images/复现FAST-LIVO2/46.jpg\" alt=\"报错\" style=\"zoom: 33%;\" />\n\n  \n\n### 烧录\n\n1. STLINK驱动安装\n\n   https://docs.qq.com/doc/DT2hyS2ZjY21WQkZt\n\n2. 硬件连接\n\n   ![烧录硬件连接原理图](../images/复现FAST-LIVO2/20.png)\n\n   <img src=\"../images/复现FAST-LIVO2/21.jpg\" alt=\"烧录硬件连接实物图\" style=\"zoom: 25%;\" />\n\n<img src=\"../images/复现FAST-LIVO2/22.jpg\" alt=\"烧录硬件连接实物图\" style=\"zoom: 25%;\" />\n\n<img src=\"../images/复现FAST-LIVO2/23.jpg\" alt=\"烧录硬件连接实物图\" style=\"zoom: 25%;\" />\n\n3. Keil烧录\n\n   ![烧录过程1](../images/复现FAST-LIVO2/24.png)\n\n​\t<img src=\"../images/复现FAST-LIVO2/25.png\" alt=\"烧录过程2\" style=\"zoom:50%;\" />\n\n![烧录过程3](../images/复现FAST-LIVO2/26.png)\n\n<img src=\"../images/复现FAST-LIVO2/27.png\" alt=\"烧录过程4\" style=\"zoom:50%;\" />\n\n<img src=\"../images/复现FAST-LIVO2/28.png\" alt=\"烧录过程5\" style=\"zoom:50%;\" />\n\n<img src=\"../images/复现FAST-LIVO2/29.png\" alt=\"烧录过程6\" style=\"zoom:50%;\" />\n\n![烧录过程7](../images/复现FAST-LIVO2/30.png)\n\n\n\n\n## 测试\n\n#### 跑包\n\nHKU_Lecture_Center_02.bag\n\n```shell\nroslaunch fast_livo mapping_avia.launch\nrosbag play HKU_Lecture_Center_02.bag\n```\n\n##### rviz\n\n![2](../images/复现FAST-LIVO2/2.jpg)\n\n![3](../images/复现FAST-LIVO2/3.jpg)\n\n墙面与地面分界线清晰\n\n![7](../images/复现FAST-LIVO2/4.jpg)\n\n图片处理(拉高亮度)后,可以看到墙面纹路,转角非常清晰\n\n![5](../images/复现FAST-LIVO2/5.jpg)\n\n![6](../images/复现FAST-LIVO2/6.jpg)\n\n\n\n##### 系统资源占用\n\n运行launch和rviz : 资源主要由rviz占用,且初始rviz config中点云queue数值极大,NUC很卡,可以把queue值适当改小.\n\n| **字段** |                          **含义**                          |\n| :------: | :--------------------------------------------------------: |\n|   PRI    |                     Priority（优先级）                     |\n|    NI    |                     Nice 值（友好度）                      |\n|   VIRT   |               Virtual Memory（虚拟内存大小）               |\n|   RES    | Resident Memory（常驻内存） 当前进程实际占用的物理内存大小 |\n|   SHR    |                 Shared Memory（共享内存）                  |\n|    S     |   State（进程状态）R：运行（Running）S：休眠（Sleeping）   |\n|   CPU%   |          进程当前使用的 CPU 百分比（所有核总和）           |\n|   MEM%   |           进程使用的物理内存占系统总内存的百分比           |\n\n![7](../images/复现FAST-LIVO2/7.jpg)\n\n![8](../images/复现FAST-LIVO2/8.jpg)\n\n![9](../images/复现FAST-LIVO2/9.jpg)\n\n只运行launch: \n\n![10](../images/复现FAST-LIVO2/10.jpg)\n\n\n\n##### 里程计数据\n\n纵轴单位(m) ,三条曲线分别是x轴,y轴,z轴里程计数据变化\n\n- 蓝色-x轴\n\n- 红色-y轴\n\n- 绿色-z轴\n\n  取最后一段平稳曲线部分放大 : 静态波动在厘米级,峰峰值4-6cm\n\n![11](../images/复现FAST-LIVO2/11.jpg)\n\n![12](../images/复现FAST-LIVO2/12.png)\n\n![13](../images/复现FAST-LIVO2/13.jpg)\n\n\n\n##### 处理时间\n\n参考该帧处理时间数量级\n\n![14](../images/复现FAST-LIVO2/14.jpg)\n","tags":["project"]},{"title":"课程设计_背单词软件调试记录","url":"/2025/05/22/课程设计_背单词软件调试记录/","content":"\n# 调试记录\n\n## 5.21测试记录\n\n目前采用静态网页进行可视化\n\n1. 用户登录未测试,现在根据用户名区分不同用户,密码不管是什么都能登录\n2. 增加home界面,在该页面可选择词书,查询单词,选择学习/复习,复习下选择释义测试/拼写测试\n3. 查询单词后可选择标记\n4. 个人中心中增加我的数据/学习进度.我的数据子菜单下可展开每个掌握度的单词\n5. 将不同词书隔离,不同词书学习进度独立,学习的单词独立\n6. 在Learning界面中乱序展示所有单词,可进行标记\n\n\n\n## 5.22测试记录\n\n目前采用静态网页进行可视化\n\n1. 增加每日学习部分.\n3. 增加profile中学习成果及可视化部分.\n4. 增加复习规则/learn帮助/review帮助\n5. 缺少按记忆曲线进行复习部分.\n\n代码已推送至dictionary的visual分支\n\n`在home界面可更改每日学习词数\n\n\n\n## 5.23测试记录\n\n现在复习的逻辑已经完善了\n可以在个人中心看到今日学习数据/复习曲线/待复习列表,复习只会在当天对应复习列表的词汇中抽取\n","tags":["算法"]},{"title":"Path_planning_learning","url":"/2025/04/06/Path-planning-learning/","content":"\n# OverView\n\n## 前端:路径寻找\n\n### 基于搜索\n\n- 图搜索基础\n- Dijkstra and A*\n- Jump Point Search\n\n### 基于采样\n\n- Probabilstic Road Map\n- RRT\n- RRT* / Informed RRT\n\n### 基于运动学动态路径寻找\n\n- State-state Boundary Value Optimal Control Problem\n- State Lattic Search\n- Kinodynamic RRT*\n- Hybrid A*\n\n## 后端:轨迹生成\n\n### MINIMUN SNAP TRAJECTORY GENERATION\n\n### SOFT AND HARD CONSTRAINED TRAJECTORY OPTIMIZATION\n\n\n\n# MAP\n\n## Occupancy grid map\n\ngithub:https://github.com/ANYbotics/grid_map\n\n- 排列紧密\n- 结构化\n- 索引队列访问\n\n缺点:当切分过于细密时空间占用率大.\n\n\n\n## Octo-map\n\ngithub:https://github.com/OctoMap/octomap_mapping\n\n地图中大部分为稀疏部分,使用八叉树的数据结构储存.如果一个区块没有障碍物,不再细分该区块;如果一个区块有障碍物则细分至最小包含该障碍物的区块.\n\n**Octree**\n\n八叉树（Octree）是一种用于描述三维空间的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，将八个子节点所表示的体积元素加在一起就等于父节点的体积。八叉树是四叉树在三维空间上的扩展，二维上我们有四个象限，而三维上，我们有8个卦限。八叉树主要用于空间划分和最近邻搜索。\n\n实现Octree的原理:\n\n- 将当前的立方体细分为八个子立方体。\n- 如果任何一个子立方体内包含多个点，则将其进一步细分为八个子立方体。\n- 重复以上操作使得每个子立方体内包含最多一个点。\n\n![八叉树1](/images/path_planning_learning/1.png)\n\n![八叉树2](/images/path_planning_learning/2.webp)\n\n- 排列稀疏\n- 结构化\n- 非直接索引访问(树的查询)\n\n\n\n## Voxel hashing\n\ngithub:https://github.com/niessner/VoxelHashing\n\n记录存在碰撞的区块 ----> 哈希表,**字典**\n\n一个bucket中划分为更小的voxel blocks\n\n![Voxel](/images/path_planning_learning/3.png)\n\n- 排列最稀疏\n- 结构化\n- 非直接索引访问(字典查询)\n\n\n\n## Point Cloud Map\n\n- 无序\n- 无法通过索引队列访问(除非自发遍历)\n\n\n\n## TSDF map\n\n**Truncated Signed Distance Functions (截断/有符号/距离函数)**\n\ngithub:\n\nTSDF 是一种用于表示3D空间表面的体素网格地图.\n\n### Signed Distance Function (SDF)\n\n对于空间中任意一点 x，SDF 给出它到最近表面的距离 d：\n$$\nSDF(x)=±d\n$$\n\n- +d：点在**表面外部**（通常指相机方向）\n- −d：点在**表面内部**\n- d=0：点在表面上（即零交叉点）\n\n### Truncated SDF（TSDF）\n\n真实计算中远离表面部分的距离信息不重要且不准确，因此会进行截断：\n\n- 若 ∣d∣> μ，则 TSDF 值为截断值。\n- μ 是截断距离阈值（truncation distance）。\n\n### Voxel Grid（体素网格）\n\nTSDF 存在于一个 3D 网格中（类似立方体像素）：\n\n- 每个体素（voxel）存储：\n  - 当前体素的 TSDF 值\n  - 加权平均值（来自多个观测帧）\n  - 权重（用于融合多个观测）\n\n![TSDF1](/images/path_planning_learning/4.png)\n\n![TSDF2](/images/path_planning_learning/5.png)\n\n\n\n##  ESDF Map\n\n**Euclidean Signed Distance Field 欧几里得有符号距离场**\n\n以 3D 网格（体素）的形式表示环境中每一点**到障碍物最近点的欧几里得距离**，并附带符号来表示点位于障碍物内部或外部。局部ESDF地图:只记忆感兴趣部分的ESDF值.\n\n![ESDF1](/images/path_planning_learning/6.png)\n\n![ESDF2](/images/path_planning_learning/7.png)\n\n\n\n## Free-space Roadmap\n\n概率路线图 ----> 安全通行区域,使用**凸多边体**表示\n\n得到的是一个宽阔的解空间\n\n\n\n## Voronoi Diagram Map\n\n高效利用ESDF提取地图骨架 ----> 稀疏\n\n\n\n# 基于搜索的路径寻找\n\n## A*\n\nA*算法在Dijkstra算法的基础上引入了启发函数(贪心思想)，启发函数是对当前节点到目标节点所需代价的预估.启发式函数一般使用曼哈顿距离、欧几里德距离。\n\n> 1. 从起点开始，将其加入待探索的节点集合（open set）。\n>\n> 2. 每次选择 f 值最小的节点进行扩展，其中 `f(n) = g(n) + h(n)`\n>\n> - `g(n)` 是从起点到当前节点的实际代价\n> - `h(n)` 是从当前节点到终点的启发式估计（如直线距离）\n>\n> 3. 对当前节点的所有相邻节点，计算新的 g 值，更新路径记录。\n>\n> 4. 如果发现更优路径（g 值更小），则更新该邻居的记录，并加入 open set。\n>\n> 5. 重复以上步骤，直到终点被选中扩展，表示找到最短路径。\n>\n> 6. 通过路径记录表回溯，重建从起点到终点的完整路径。\n\n伪代码\n\n```c++\n• 维护一个优先级队列来存储所有待扩容节点\n• 所有节点的启发式函数h(n)是预定义的\n• 优先级队列初始化为起始状态 X S\n• 对图中所有其他节点赋值g(X S) = 0, g(n) = infinite\n• Loop\n    •如果队列为空，则返回FALSE；BREAK;\n    •从优先级队列中删除f(n)=g(n)+h(n)最小的节点“n”\n    •将节点“n”标记为展开\n    •如果节点“n”是目标状态，返回TRUE；BREAK;\n    •对于节点n的所有未展开的邻居 m\n\t\t•If g(m) = infinite\n\t\t\t• g(m)= g(n) + Cnm\n    •对于节点n的所有未展开的邻居 m\n\t\t•If g(m) = infinite\n\t\t\t• g(m)= g(n) + Cnm\n\t\t\t• Push node “m” into the queue\n\t\t•If g(m) > g(n) + C nm\n\t\t\t•g(m)= g(n) + Cnm\n\t•end\n• End Loop\n```\n\n\n\n### Weighted A* Search\n\nSub-Optimal Solution\n\n通过人为加大启发函数的影响力来获得更快的搜索速度，以牺牲路径最优性为代价。\n\nf = g + εh, ε > 1 =bias towards states that are closer to goal.\n\n![Weighted_A*_Search](/images/path_planning_learning/8.png)\n\n- Most Greedy（最贪婪）\n\n- 参数：a=0,b=1\n- 只考虑启发式代价，完全不考虑当前路径代价\n- 结果：趋向于直接朝目标点移动，但路径不一定最短或最优\n\n------\n\n- Tunable Greediness（可调贪婪度）\n\n- 参数：a=1,b=ε>1\n- 综合考虑当前路径和启发式估计，但偏向启发式\n- 结果：平衡探索性和效率，路径更合理\n\n------\n\n- Optimal（最优路径）\n\n- 参数：a=1,b=1\n- 平等考虑已知路径和启发估计\n- 结果：找到最优路径\n\n------\n\n- Dijkstra算法\n\n- 参数：a=1,b=0\n- 完全不使用启发式，只靠实际代价 g,效率低\n\n\n\n### A*的实施流程\n\n1. 建立地图 → 生成网格节点数组\n\n2. 设定障碍 → 标记不可达节点\n\n3. 编写邻居搜索函数\n\n4. 编写A*主循环：\n\n   - 从openList中取出f值最小的节点\n\n   - 计算邻居的g/h/f值，加入openList\n\n   - 更新已访问节点（closedList）\n\n5. 使用`priority_queue`或`multimap`优化性能\n\n\n\n### **最好的启发函数**\n\n**最好:tight**,正确的最短距离函数\n\n> 二维最佳启发函数:\n> $$\n> h2D​=(dx+dy)+(2\n> ​−2)⋅min(dx,dy)\n> $$\n> 三维最佳启发函数:\n>\n> 我们记 dx,dy,dz为三维网格中当前点与目标点在三个轴上的距离（均为非负整数），有：\n> $$\n> h3D=dmin⋅3+(dmid−dmin)⋅2+(dmax−dmid)⋅1\n> $$\n> 其中：dmin,dmid,dmax是 dx,dy,dzdx,dy,dz 的排序结果，使得\n>\n> $$\n> dmin≤dmid≤dmax\n> $$\n\n\n\n### Tie Breaker\n\n平局处理器,打破 f 值相等时的探索顺序\n\n- 问题:\n\n​\tA* 会选取 f 值最小的节点扩展（f=g+h）\n\n​\t但在一些情形下，很多节点的 f 值完全相等,尤其是在网格图中启发函数不够 tight 的时候\n\n​\t导致算法要探索很多不必要的节点，降低效率\n\n>- **解决方法:**\n>\n>1. 人为干扰 h，让 f 值不同:\n>\n>   将原来的启发函数 h乘上一个微小因子：\n> $$\n>   h=h×(1.0+p)\n> $$\n>   其中：\n> $$\n>   p < \\frac{\\text{最小步长代价}}{\\text{预期路径总长度}}\n> $$\n>   这样能 **轻微打破平局**，减少无效扩展\n>\n>   代价是轻微地破坏启发式的“可采纳性”（admissibility），但常常实际无影响或带来更好效率.\n>\n>2. 优先选 h值小的节点\n>\n>   如果两个节点 f 一样，选择 h 小的那个（靠近终点）\n>\n>3. 加入伪随机干扰项（Deterministic random）\n>\n>- 给每个节点加一个唯一扰动，保持一致性但不完全对称\n>\n>4. 优先靠近起点-终点连线的路径\n>\n>$$\n>cross=∣dx1×dy2−dx2×dy1∣\n>$$\n>\n>**这其实是在衡量点偏离直线的“面积”，越小越靠近理想路径。**\n\n\n\n## Jump Point Search\n\n核心思想:**在两点之间没有障碍物时，中间的节点不考虑,只考虑重要节点.**\n\n1. 邻居修剪 Neighbor Pruning\n\n- 灰色节点：较差的邻居，当去到它们时，没有分值的路径更便宜。丢弃。\n\n\n- 白色节点：自然邻居。\n\n\n​\t只需要考虑**自然邻居**.\n\n![Neighbor Pruning](/images/path_planning_learning/9.png)\n\n2. 强迫邻居 Forced Neighbors\n\n节点X的邻居节点有障碍物，且X的父节点P经过X到达N的距离代价，比不经过X到大N的任一路径的距离代价都小，则称N是X的强迫邻居。\n\n- 有相邻的障碍\n\n- 红色节点是强制邻居。\n\n- 一条从父母到他们通过障碍的更便宜的路径被阻断。\n\n\n![Forced Neighbors](/images/path_planning_learning/10.png)\n\n3. 跳点(Jump Point)：什么样的节点可以作为跳点\n    (1)节点 A 是起点、终点.\n    (2)节点A 至少有一个强迫邻居.\n    (3)父节点在斜方向(斜向搜索)，节点A的水平或者垂直方向上有满足 (1)、(2) 的节点\n\n![Jump Point](/images/path_planning_learning/11.png)\n\n跳点搜索中，会递归地检查路径上的邻居节点是否是“跳点”。在检查对角线方向前，会优先尝试直线方向。只要某个节点通往某些邻居的最短路径必须经过它，它就会被标记为跳点。同时，对“强制邻居”不能剪枝，必须展开。\n\n\n\n# 基于采样的路径寻找\n\n## Probabilistic Road Map\n\n图结构\n\n将规划分为两个阶段：\n·学习阶段\n·查询阶段\n\n检查采样配置和连接的样本之间的碰撞可以有效率地完成任务。\n数量相对较少的里程碑和局部路径足以捕获的连通性。\n\n- 限制路径点连接的长度避免图结构过于复杂\n\n### 学习阶段:\n\n- 在c空间中采样N个点\n- 删除碰撞点\n\n![PRM-Learning1](/images/path_planning_learning/12.png)\n\n- 连接到最近的点，并获得无碰撞段。\n- 删除碰撞段\n\n![PRM-Learning2](/images/path_planning_learning/13.png)\n\n### 查询阶段:\n\n- 在路线图上搜索，找到从起点到终点的路径目标（使用Dijkstra算法或A*算法）。\n- 路线图现在类似于网格地图\n\n![PRM-Query](/images/path_planning_learning/14.png)\n\n 优点\n\n- 概率完备\n\n\n缺点\n\n- 要求解决两点边值问题\n\n- 在状态空间上构建图，但不特别关注生成路径\n\n- 效率不高\n\n\n\n### Lazy collision-checking\n\n**效率低**: PRM（Probabilistic Roadmap）或 RRT（Rapidly-exploring Random Tree) 需要频繁地检查从一个配置到另一个配置（或状态）之间的路径是否与障碍物发生碰撞。但碰撞检测是一个昂贵的计算操作，尤其在高维空间或复杂环境中，频繁的碰撞检测会成为性能瓶颈。\n\n- 不考虑采样点和生成分段碰撞（懒惰）\n\n\n先构建图（PRM）或树（RRT）时不立即检查碰撞，等到真正要使用这条路径时（例如在查询最短路径、或者将路径从树/图中提取出来时），再执行碰撞检测。\n\n#### **PRM+Lazy collision-checking**\n\n1. 构建 roadmap：采样节点、连接边，不做碰撞检测。\n\n2. 查询路径：使用 A* 或 Dijkstra 等算法找到一条从起点到终点的路径。\n\n3. 在该路径上进行逐段碰撞检测：\n\n   - 如果全部无碰撞，路径有效；\n\n   - 如果某段有碰撞，将该边标记为无效（不可达），从图中删除，重新搜索。\n\n![Lazy collision-checking](/images/path_planning_learning/15.png)\n\n\n\n## Rapidly-exploring Random Tree\n\n**核心思想:**\n\n> 通过生成next构建树状态在树中通过执行随机控制,从起点开始，不断向随机方向扩展一棵树，迅速探索整个状态空间。\n\n伪代码:\n\n![RRT伪代码](/images/path_planning_learning/16.png)\n\n- 初始化一棵树 `T`，将起始点 `X_init` 作为树的根节点。\n- 循环:\n- 在整个状态空间中随机采样一个点 `X_rand`，用于探索新方向。\n- 找出树 `T` 中距离 `X_rand` 最近的已有节点 `X_nearest`。\n- 从 `X_nearest` 朝 `q_rand` 方向延伸一个固定步长delta，生成新点 `X_new`。\n\n如果新点 `X_new` 是可行的（比如不与障碍物碰撞），则执行以下操作:\n\n- 把这个新点 `X_new` 加入树中，作为新的节点。\n- 在树中添加一条从 `X_nearest` 到 `X_new` 的路径边。\n- 返回整个搜索生成的树 `T`，它包含从起点开始探索出来的路径结构。\n\n**提前停止的条件：**因为每一段树枝的末端都是Xnew，所以每产生一次Xnew节点，我们都判断一下Xnew与终点之间的距离，看这个距离是否小于步长，如果小于步长且没有经过障碍物，则就直接把Xnew与终点进行相连。\n\n> 优点:\n> ·旨在找到从起点到目标的路径\n> ·比PRM更有针对性\n> 缺点:\n> ·非最优解\n> ·效率不高,在 **narrow环境** 中效率低\n> ·整个空间取样\n\n\n\n### KD树\n\n Kd-Tree，即K-dimensional  tree，是一棵二叉树，树中存储的是一些K维数据。在一个K维数据集合上构建一棵Kd-Tree代表了对该K维数据集合构成的K维空间的一个划分，即树中的每个结点就对应了一个K维的超矩形区域（Hyperrectangle）。\n\n关键术语:\n\n- 维度（K）：表示数据点所在的空间维数。例如，二维空间中的点有x和y坐标，三维空间中的点有x、y、z坐标。\n- 节点：KD树的每个节点包含一个K维点及其分割超平面的信息。\n- 超平面：在K维空间中用于将空间划分为两个部分的（K-1）维子空间。例如，二维空间中的超平面是直线，三维空间中的超平面是平面。\n\n构建步骤:\n\n1. 输入数据：假设有N个K维数据点。\n\n2. 选择分割维度：按照循环顺序选择当前维度。例如，第一个维度（x轴）用于根节点，第二个维度（y轴）用于其子节点，依此类推。\n\n3. 选择分割值：在当前分割维度上找到**中位数**点，将其作为当前节点。\n\n4. 划分数据：\n\n   -  左子集：所有在当前分割维度上小于中位数点的点。\n\n   - 右子集：所有在当前分割维度上大于中位数点的点。\n\n5. 递归构建子树：对左子集和右子集重复上述步骤，直到所有点都被包含在树中。\n\n6. 终止条件：当某一子集为空时，递归终止。\n\n![一个创建KD树的例子](/images/path_planning_learning/17.png)\n\n使用KD树提高**路径规划**效率\n\n\n\n### Bidirectional RRT / RRT-Connect 双向快速扩展随机树\n\n>1. 初始化两棵树：T_start 以 q_start 为根，T_goal 以 q_goal 为根。\n>2. 重复以下过程直到路径找到或迭代上限：\n>    a. 从状态空间中采样一个随机点 q_rand。\n>    b. 使用 Extend 操作从 T_start 向 q_rand 延伸，得到 q_new。\n>    c. 如果扩展成功：\n>        i. 使用 Connect 操作让 T_goal 向 q_new 不断扩展，直到无法前进。\n>        ii. 如果两个树在某个点连接，则路径找到。\n>    d. 交换 T_start 和 T_goal。\n\n|   项目   |     单向 RRT     | 双向 RRT（RRT-Connect） |\n| :------: | :--------------: | :---------------------: |\n| 扩展方向 |   只从起点扩展   |   起点和终点同时扩展    |\n| 搜索速度 |       较慢       |      更快，更高效       |\n|  成功率  | 容易陷入复杂障碍 |  双向推进更容易绕障碍   |\n| 路径质量 |       一般       |          更好           |\n|  复杂性  |        低        |           高            |\n\n\n\n## Optimal sampling-based path planning methods\n在传统采样方法（如 RRT、PRM）的基础上，进一步加入了**路径最优性保证**的算法。最经典的代表是 **RRT***\n\n### RRT*\n\n![RRT*伪代码](/images/path_planning_learning/18.png)\n\n**Choose Best Parent**：在新节点周围半径内的已有节点中，选择一条“代价最小”的路径作为父节点；\n\n**Rewire**：反过来看新节点是否能以更小的代价更新周围节点的父节点。\n\n### Kinodynamic-RRT*\n\n更改Steer（）函数以适应机器人的运动或其他限制导航(曲线)\n\n\n\n## Advanced Sampling-based Methods\n\n### Inform RRT*\n\n一旦找到一条路径，其代价为 `c_best`，就只在以下区域采样：\n\n> **从起点 `q_start` 到终点 `q_goal` 的椭球体区域（Ellipsoidal Sampling Space）**\n>  半长轴为 `c_best/2`，焦点为起点与终点，构成一个最短路径所有可能穿过的区域。\n\n![Inform RRT*](/images/path_planning_learning/18.png)\n\n### Cross-entropy motion planning\n\n1. **初始化一个轨迹分布模型**\n\n   - 比如用高斯分布建模一条轨迹（多个中间点组成）\n\n   - 初始均值：可能是直线路径，初始方差大\n\n2. **采样多个轨迹**\n\n   每条轨迹是从当前分布中采样得到的一个完整路径（可加速度约束等）\n\n3. **评估轨迹代价**:碰撞检测、路径长度、平滑性、目标接近度等\n\n4. **选取表现最好的轨迹（Top-k）**:选出“精英轨迹”，即代价最小的那一部分\n\n5. **用精英轨迹更新分布参数:**更新高斯均值和协方差，使下次采样更集中于好路径附近\n\n6. **迭代**:重复 2-5，直到满足终止条件（如达到最小代价、收敛、超时等）\n","tags":["算法"]},{"title":"接入网综合课设","url":"/2025/03/10/接入网课设/","content":"\n#  接入网综合课设\n\n## 阶段一\n\n1. 完成虚拟机选型，并配置至少两个网段， 分别测试子网内和子网间连通性； \n\n2. 设计PPPOE本地认证拓扑图及IP地址规划 (客户至少两个网段)  ；\n\n3. 选型PPPOE服务器软件，并在虚拟环境下 完成PPPoE接入本地认证的搭建、配置、 实验测试。\n\n### 任务一\n\n#### 子网规划\n\n虚拟机选型：ubuntu20.04\n\n配置网段：\n\n- Vmnet1:192.168.10.0/24\n- Vmnet2:192.168.20.0/24 \n- Vmnet3:192.168.30.0/24\n\n![子网规划](/images/接入网综合课设/1.png)\n\n#### 配置流程\n\n1. 在ubuntu编辑-虚拟网络编辑器中选择更改设置，赋予管理员权限后选择添加网络，类型为**仅主机模式**，修改子网IP和子网掩码。\n\n![虚拟网络编辑器](/images/接入网综合课设/2.png)\n\n2. 在ubuntu虚拟机设置中添加网卡，三张为子网规划中定义所对应的网卡。\n\n![虚拟机设置](/images/接入网综合课设/3.png)\n\n![硬件设置](/images/接入网综合课设/4.png)\n\n对应网络适配器选择自定义-特定虚拟网络-选择对应网卡-确定。\n\n![虚拟机设置](/images/接入网综合课设/5.png)\n\n3. 在ubuntu中输入\n\n```shell\nifconfig\n```\n\n出现对应网卡信息。\n\n![网卡信息](/images/接入网综合课设/6.png)\n\n4. 配置静态IP。参考博客：[Ubuntu配置静态IP](https://blog.csdn.net/weixin_58305495/article/details/130554393)，注意与网卡名称匹配。\n\n**Ubuntu 16.04 及更早版本**：网络管理工具使用 `ifupdown`，网络配置文件在 `/etc/network/interfaces`\n\n```shell\nauto lo\niface lo inet loopback\n\nauto eth0\niface eth0 inet dhcp\n\nauto eth1\niface eth1 inet static\naddress 192.168.10.10\nnetmask 255.255.255.0\ngateway 192.168.10.1\ndns-nameservers 8.8.8.8 8.8.4.4\n\nauto eth2\niface eth2 inet static\naddress 192.168.20.10\nnetmask 255.255.255.0\ngateway 192.168.20.1\n\nauto eth3\niface eth3 inet static\naddress 192.168.30.10\nnetmask 255.255.255.0\ngateway 192.168.30.1\n\n```\n\n**Ubuntu 17.10 及更高版本**：网络管理工具使用 `Netplan`，配置文件位于 `/etc/netplan/00-installer-config.yaml`\n\n```yaml\n# Let NetworkManager manage all devices on this system\nnetwork:\n  version: 2\n  renderer: NetworkManager\n  ethernets:\n    ens33:            \n      dhcp4: true                          \n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]       \n\n    ens37:\n      addresses: [192.168.10.10/24]        \n      routes:\n        - to: default\n          via: 192.168.10.1                \n      dhcp4: false                          \n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]      \n\n    ens38:\n      addresses: [192.168.20.10/24]         \n      routes:\n        - to: default\n          via: 192.168.20.1                \n      dhcp4: false                          \n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]   \n\n    ens39:\n      addresses: [192.168.30.10/24]        \n      routes:\n        - to: default\n          via: 192.168.30.1              \n      dhcp4: false                     \n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]   \n```\n\n配置完成后执行命令使配置生效。\n\n```shell\nsudo netplan apply\n```\n\n执行`ifconfig`命令查看当前IP地址。\n\n\n\n####  测试\n\n**子网间连通性**\n\n![Linux子网间连通性](/images/接入网综合课设/7.png)\n\nClient1(192.168.10.20)\n\n![Client1子网间连通性](/images/接入网综合课设/8.png)\n\nClient2(192.168.20.20)\n\n<img src=\"/images/接入网综合课设/9.png\" alt=\"image-20250308132954522\" style=\"zoom: 80%;\" />\n\n**子网内连通性**\n\nClient1(192.168.10.20)\n\n![Client1子网内连通性](/images/接入网综合课设/10.png)\n\nClient2(192.168.20.20)\n\n<img src=\"/images/接入网综合课设/11.png\" alt=\"image-20250308133215681\" style=\"zoom:80%;\" />\n\n### 任务三\n\n#### PPPoE服务器端\n\n[参考博客:基于Linux环境的PPPOE服务器搭建](https://zhuanlan.zhihu.com/p/41499761)\n\n1. 安装PPPoE服务器程序\n\n```shell\nsudo apt-get install pppoe\n```\n\n使用`pppoe-server -h`查看pppoe安装情况及版本,该PPPoE-Server版本为3.12。\n\n![PPPoE服务器版本](/images/接入网综合课设/12.png)\n\n2. 编辑/etc/ppp/options文件\n\n- PAP：明文密码认证协议。\n- CHAP：挑战握手认证协议，**三次握手**机制，使用哈希加密。\n\n```shell\n14+ ms-dns 8.8.8.8\n57  local\n144 #+pap  // 关闭pap\n147 -pap\n151 +chap  // 开启chap\n154 #-chap\n208 proxyarp\n```\n\n3. 编辑 pppoe-server-options文件\n\n创建/etc/ppp/pppoe-server-options文件，使用chap验证协议require-chap，如果使用pap验证协议则配置为 require-pap。\n\n```shell\nauth\nrequire-chap\nlcp-echo-interval 60\nlcp-echo-failure 5     \nlogfile /var/log/pppd.log\n```\n\n3. 编辑/etc/ppp/chap-secrets 文件\n\n```shell\n# Secrets for authentication using CHAP\n# client\tserver\tsecret\t\t\tIP addresses\ntest * test *\n```\n\n用户名为test，密码为test，服务器名和IP地址为任意。\n\n4.  开启IP转发功能\n\n​\t编辑/etc/sysctl.conf文件：\n\n```shell\n28 net.ipv4.ip_forward=1\n```\n\n​\t运行`sudo sysctl -p`生效配置。\n\n5. 启动PPPoE服务器\n\n```shell\nsudo pppoe-server -I ens37 -L 192.168.10.10 -R 192.168.10.11 -N 20   \nsudo pppoe-server -I ens38 -L 192.168.20.10 -R 192.168.20.11 -N 20   \n```\n\n**指令含义：**\n\n| pppoe-server | 启动 PPPoE 服务器进程                        |\n| ------------ | -------------------------------------------- |\n| -I xxx       | 监听物理网卡xxx，接受客户端的 PPPoE 拨号请求 |\n| -L IP地址    | PPP 服务器的 IP 地址                         |\n| -R IP地址    | 客户端分配 IP 的起始地址                     |\n| -N n         | 最多允许 n 个 PPPoE 客户端同时连接           |\n\n6. 查看PPPoE服务器的启用情况\n\n```shell\nps -ef|grep pppoe\n```\n\n![pppoe服务器的启用情况](/images/接入网综合课设/13.png)\n\n- 如果需要关闭PPPoE服务器，指令为：\n\n```shell\nsudo killall pppoe-server\n```\n\n- 每次电脑重启均需要重新运行PPPoE启动命令，设置开机自启动脚本：\n\n  1. 创建systemd服务文件：\n\n     ```shell\n     sudo gedit /etc/systemd/system/pppoe-server.service\n     ```\n\n     ```SHELL\n     [Unit]\n     Description=PPPoE Server Service\n     After=network.target # 等到网络启动后再启动\n     \n     [Service]\n     ExecStart=/usr/local/bin/start-pppoe.sh\n     Restart=always\n     RestartSec=5\n     User=root\n     \n     # 无限制重启\n     StartLimitIntervalSec=0\n     \n     [Install]\n     WantedBy=multi-user.target\n     ```\n\n     ```shell\n     sudo gedit /usr/local/bin/start-pppoe.sh\n     ```\n\n  2. 创建脚本文件：\n\n     ```shell\n     sudo gedit /usr/local/bin/start-pppoe.sh\n     ```\n\n     ```shell\n     #!/bin/bash\n     \n     pppoe-server -I ens37 -L 192.168.10.10 -R 192.168.10.11 -N 20\n     pppoe-server -I ens38 -L 192.168.20.10 -R 192.168.20.11 -N 20\n     \n     # 保持进程运行\n     tail -f /dev/null\n     ```\n\n     赋予执行权限：\n\n     ```shell\n     sudo chmod +x /usr/local/bin/start-pppoe.sh\n     ```\n\n  3. 重新加载配置，重启服务：\n\n     ```shell\n     sudo systemctl daemon-reload\n     sudo systemctl reset-failed\n     sudo systemctl enable pppoe-server\n     sudo systemctl start pppoe-server\n     ```\n\n  4. 重启后检查服务状态：\n\n     ```shell\n     ps -ef|grep pppoe\n     sudo systemctl status pppoe-server\n     ```\n\n     ![重启后的服务状态](/images/接入网综合课设/24.png)\n\n  - 注：如果systemd服务文件中没有添加`StartLimitIntervalSec=0`,脚本文件中没有`tail -f /dev/null`,则有可能报错：\n\n    ```shell\n    sudo systemctl status pppoe-server\n    ● pppoe-server.service - PPPoE Server Service\n         Loaded: loaded (/etc/systemd/system/pppoe-server.service; enabled; vendor>\n         Active: failed (Result: start-limit-hit) since Mon 2025-03-10 00:16:20 CS>\n        Process: 2386 ExecStart=/usr/local/bin/start-pppoe.sh (code=exited, status>\n       Main PID: 2386 (code=exited, status=0/SUCCESS)\n    \n    3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Scheduled>\n    3月 10 00:16:20 xu-virtual-machine systemd[1]: Stopped PPPoE Server Service.\n    3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Start req>\n    3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Failed wi>\n    3月 10 00:16:20 xu-virtual-machine systemd[1]: Failed to start PPPoE Server Se>\n    ```\n\n    失败的原因： `start-limit-hit`，短时间内该服务多次失败，触发了 systemd 的启动限制机制。原脚本`start-pppoe.sh` 脚本执行完后立即退出，systemd 误以为它崩溃并尝试重启，导致触发 `start-limit-hit`。\n\n    \n\n#### PPPoE客户端\n\nWindows端拨号步骤：\n\n1. 选择网络和Internet设置\n\n![选择网络和Internet设置](/images/接入网综合课设/14.png)\n\n2. 选择拨号-设置新连接-连接到Internet-下一页-宽带\n\n![拨号选择](/images/接入网综合课设/15.png)\n\n3. 输入用户名和密码\n\n   ![用户名和密码](/images/接入网综合课设/16.png)\n\n4. 连接成功\n\n![拨号成功](/images/接入网综合课设/17.png)\n\n#### 测试\n\n 客户端连接成功后，在服务器端输入`ifconfig`会看到PPP接口信息\n\n![PPP接口](/images/接入网综合课设/18.png)\n\n在客户端输入`ipconfig /all`  会看到PPP服务器分配的IP地址\n\n**Client1(192.168.10.20)**\n\n![Client1](/images/接入网综合课设/19.png)\n\n**测试ping通：**\n\n![Client1](/images/接入网综合课设/20.png)\n\n**Client2(192.168.20.20)**\n\n![Client2](/images/接入网综合课设/21.png)\n\n测试ping通：\n\n![Client2](/images/接入网综合课设/22.png)\n\n**抓包分析**\n\n**注意**：执行 `sudo wireshark` \n\nFilter 选择pppoe|ppoes。\n\n**PPPoE报文类型**\n\n| 阶段                      | 以太网协议号 | 报文类型                               |\n| ------------------------- | ------------ | -------------------------------------- |\n| **发现阶段**（Discovery） | `0x8863`     | PADI, PADO, PADR, PADS, PADT           |\n| **会话阶段**（Session）   | `0x8864`     | PPP 数据包（LCP、PAP/CHAP、IP 数据等） |\n\n**PPPoE交互过程**\n\n![PPPoE交互过程](/images/接入网综合课设/32.png)\n\n![抓包pppoed](/images/接入网综合课设/25.png)\n\n![抓包pppoes-1](/images/接入网综合课设/26.png)\n\n![抓包pppoes-2](/images/接入网综合课设/27.png)\n\n**PPPoE 发现阶段**\n\nPPPoE 发现阶段用于 建立 PPPoE 连接有5种报文：\n\n1.  PADI（PPPoE Active Discovery Initiation）\n\n- **客户端 → 广播** 发送 **PADI**（发现请求）。\n- 用于查找可用的 PPPoE 服务器（AC, Access Concentrator）。\n- **目标 MAC 地址：`FF:FF:FF:FF:FF:FF`**（广播）。\n- 只有Service-Name为空的服务器会响应。\n\n![抓包pppoed-PADI](/images/接入网综合课设/28.png)\n\n2. PADO（PPPoE Active Discovery Offer）\n\n- **服务器（AC）→ 客户端** 回复 **PADO**（提供服务）。\n- 服务器响应客户端，表明自己可用。\n- 包含 **服务器名称** 和 **支持的服务**。\n\n![抓包pppoed-PADO](./images/接入网综合课设/29.png)\n\n3. PADR（PPPoE Active Discovery Request）\n\n- **客户端 → 服务器（AC）** 发送 **PADR**（连接请求）。\n\n- 用户主机可能会收到多个 PADO，但仅查看它收到的 PADO 数据包并选择一个，并请求建立会话。\n\n- 包含 **服务名** 和 **唯一的标识符**。\n\n  ![抓包pppoed-PADR](/images/接入网综合课设/30.png)\n\n4. PADS（PPPoE Active Discovery Session-confirmation）\n\n- **服务器（AC）→ 客户端** 发送 **PADS**（会话确认）。\n- **分配一个 PPPoE 会话 ID**，表示连接已建立。\n\n![抓包pppoed-PADS](/images/接入网综合课设/31.png)\n\n5. PADT（PPPoE Active Discovery Terminate）\n\n- 客户端或服务器 发送 **PADT**（终止连接）。\n- 关闭 PPPoE 连接。\n\n**PPPoE 会话阶段**\n\nPPPoE 发现阶段完成后，客户端和服务器通过 **PPPoE 会话 ID** 进行通信。\n 此时 PPPoE 封装标准 PPP 报文，包括4种报文：\n\n1. **LCP（Link Control Protocol）**：链路协商。\n2. **PAP/CHAP（Password Authentication Protocol / Challenge Handshake Authentication Protocol）**:  用户身份认证。\n3. **NCP（Network Control Protocol)** : 分配 IP 地址。\n4. **IP 数据报文**: 网络通信数据（TCP/IP、UDP）。\n\n\n\n## 阶段二\n\n1.  设计PPPoE+RADIUS远程接入控制拓扑图及IP地址规划（客户机至少两个网段）。\n2.  选型RADIUS服务器软件，并在虚拟平台下完成PPPOE+RADIUS远程接入认证的搭建、配置、实验测试。\n\n### 任务一\n\n![42](/images/接入网综合课设/42.png)\n\n### 任务二\n\n- RADIUS服务器：FreeRADIUS 3.0.27 （最新stable版本）\n- RADIUS客户端：FreeRADIUS -client-1.1.7\n\n#### 配置Radius服务器及客户端静态IP\n\n```shell\nsudo gedit /etc/netplan/01-network-manager-all.yaml\n```\n\n- **服务器**\n\n```shell\n# Let NetworkManager manage all devices on this system\nnetwork:\n  version: 2\n  renderer: NetworkManager\n  ethernets:\n    ens33:            \n      dhcp4: true                           # 启用 DHCP\n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置\n        \n    ens37:\n      addresses: [192.168.30.2/24]        \n      routes:\n        - to: default\n          via: 192.168.30.1                \n      dhcp4: false                          \n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4] \n```\n\n配置完成后执行命令使配置生效。\n\n```shell\nsudo netplan apply\n```\n\n执行`ifconfig`命令查看当前IP地址\n\n![40](/images/接入网综合课设/40.png)\n\n- **客户端（PPPoE服务器）**\n\n``` shell\n# Let NetworkManager manage all devices on this system\nnetwork:\n  version: 2\n  renderer: NetworkManager\n  ethernets:\n    ens33:            \n      dhcp4: true                           # 启用 DHCP\n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置\n        \n    ens37:\n      addresses: [192.168.10.1/24]           # 静态 IP 地址\n      routes:\n        - to: default\n          via: 192.168.10.1  # 默认网关\n      dhcp4: false                           # 禁用 DHCP\n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置\n        \n    ens38:\n      addresses: [192.168.20.1/24]           # 静态 IP 地址\n      routes:\n        - to: default\n          via: 192.168.20.1  # 默认网关\n      dhcp4: false                           # 禁用 DHCP\n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置\n        \n    ens39:\n      addresses: [192.168.30.1/24]           # 静态 IP 地址\n      routes:\n        - to: default\n          via: 192.168.30.1  # 默认网关\n      dhcp4: false                           # 禁用 DHCP\n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置\n\n      link: ens37\n      addresses:\n        - 192.168.10.129/25\n```\n\n配置完成后执行命令使配置生效。\n\n```shell\nsudo netplan apply\n```\n\n执行`ifconfig`命令查看当前IP地址\n\n![41](/images/接入网综合课设/41.png)\n\n\n\n#### 安装Radius服务器\n\n1. 下载Radius：\n\n   freeradius官方网站：http://freeradius.org/download.html\n\n   freeradius官方文档：\n\n2. 解压：\n\n   ```shell\n   tar -zxvf freeradius-server-3.0.27.tar.gz \n   ```\n\n3. 安装依赖项\n\n   ```shell\n   sudo apt update\n   sudo apt install build-essential -y\n   sudo apt install libtalloc-dev -y\n   sudo apt install libssl-dev -y\n   sudo apt install libhiredis-dev -y\n   sudo apt install freeradius-mysql\n   ```\n\n4. 编译及安装\n\n   ```shell\n   cd  freeradius-server-3.0.26\n   ./configure \n   make\n   sudo make install # 默认安装在 /usr/local/etc/raddb下\n   ```\n\n5. 启动Radius\n\n   ```shell\n   # debug模式启动\n   sudo radiusd -X\n   \n   # 后台进程方式启动\n   systemctl start radiusd\n   systemctl enable radiusd\n   \n   # 日志\n   /var/log/radius/radius.log \n   ```\n\n6. 添加用户\n\n   在 /usr/local/etc/raddb/users 的末尾添加：\n\n   ```shell\n   # test 的用户设置明文密码为 \"test\"\n   # user Cleartext-Password := \"password\"\n   test Cleartext-Password := \"test\"\n   ```\n\n   ```shell \n   # radtest <用户名> <密码> <服务器地址> <端口> <共享密钥>\n   radtest testing password123 127.0.0.1 0 testing123  \n   ```\n\n   本地测试成功\n\n   ![34](/images/接入网综合课设/34.png)\n\n#### 创建数据库\n\n1.安装mariadb\n\n```shell\nsudo apt update\nsudo apt install mariadb-server mariadb-client\nsudo systemctl start mariadb\nsudo systemctl enable mariadb\n```\n\n若此时直接运行安全设置`mysql_secure_installation`，则报错：\n\n```shell\nxu@xu-virtual-machine:~/Desktop$ mysql_secure_installation\n\nNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB\n      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!\n\nIn order to log into MariaDB to secure it, we'll need the current\npassword for the root user.  If you've just installed MariaDB, and\nyou haven't set the root password yet, the password will be blank,\nso you should just press enter here.\n\nEnter current password for root (enter for none): \nERROR 1698 (28000): Access denied for user 'root'@'localhost'\nEnter current password for root (enter for none): \nAborting!\n\nCleaning up...\n```\n\n这是因为 MariaDB 默认使用 **`auth_socket` 插件** 进行身份验证，它不接受通过普通密码登录，只通过 Unix 套接字进行验证。\n\n解决方案：\n\n- 通过root用户登录:\n\n  ``` shell\n  sudo mysql -u root\n  ```\n\n- 禁用 `auth_socket` 插件并设置密码:\n\n  ``` shell\n  sudo mysql\n  USE mysql;\n  SET PASSWORD FOR 'root'@'localhost' = PASSWORD('1');\n  # 刷新权限并退出\n  FLUSH PRIVILEGES;\n  EXIT;\n  ```\n\n​\t运行`mysql_secure_installation`进行安全设置：\n\n<img src=\"/images/接入网综合课设/35.png\" alt=\"35\" style=\"zoom: 80%;\" />\n\n2. 进入数据库\n\n``` sql\n mysql -uroot -p\n```\n\n3. 创建数据库并授权\n\n``` sql\nMariaDB [(none)]> create database radius；\nQuery OK, 1 row affected (0.00 sec)\n\nMariaDB [(none)]> grant all on radius.* to radius@'localhost' identified by 'radius';\nQuery OK, 0 rows affected (0.00 sec)\n\nMariaDB [(none)]> flush privileges;\nQuery OK, 0 rows affected (0.00 sec)\n```\n\n\n\n#### 配置Radius服务器端和数据库\n\n1. 导入数据库\n\n``` shell\ncd /usr/local/etc/raddb/mods-config/sql/main/mysql\nmysql -u radius -p radius< schema.sql\n```\n\n如果报错：\n\n``` shell\nroot@xu-virtual-machine:/usr/local/etc/raddb/mods-config/sql/main/mysql# mysql -u radius -p radius< schema.sql\nEnter password: \nERROR 1045 (28000): Access denied for user 'radius'@'localhost' (using password: YES)\n```\n\n这是因为 MySQL 用户 `radius` 在 `localhost` 上的访问被拒绝，重新设置密码\n\n```sql\nmysql -uroot -p\nALTER USER 'radius'@'localhost' IDENTIFIED BY 'your_password';\nGRANT ALL PRIVILEGES ON radius.* TO 'radius'@'localhost';\nFLUSH PRIVILEGES;\n```\n\n2. 配置Radius\n\n   - 配置default文件\n\n     ```shell\n     sudo -i\n     gedit /usr/local/etc/raddb/sites-enabled/default\n     ```\n\n     使用数据库储存用户信息/计费：\n\n     在538行authenticate {}部分，注释files，解注释sql\n\n     在673行accounting{}部分，解注释 sql\n\n   - 配置sql文件\n\n     ```shell\n     sudo -i\n     gedit /usr/local/etc/raddb/mods-available/sql\n     \n     # 设置文件\n     tls_required = no\n     driver = \"rlm_sql_mysql\"  # 指定 FreeRADIUS 使用 MySQL 数据库作为后端数据库来进行认证和计费\n     dialect = \"mysql\"         # mysql 表示使用 MySQL 数据库的 SQL 方言\n     server = \"localhost\"      # 数据库运行在本地计算机上\n     port = 3306 \n     login = \"radius\"\n     password = \"radius\"\n     radius_db = \"radius\"\n     read_clients = yes         # 允许 FreeRADIUS 从数据库中读取客户端信息                                      、\n     ```\n\n3. 客户端认证设置\n\n```shell\nsudo gedit /usr/local/etc/raddb/clients.conf\n\n# 定义 PPPoE 客户端连接到服务器时需要使用的 IP 地址和密码（共享密钥）\nclient pppoe-server {\n    ipaddr = 192.168.30.1\n    secret = testing123\n}\n```\n\n4. 配置组与用户信息\n\n- 进入radius库\n\n```shell\nsudo mysql -u root -p radius\n```\n\n- 新建组\n\n```shell\ninsert into radgroupcheck (groupname,attribute,op,value) values  ('usr','Auth- Type',':=','Local');\ninsert into radgroupcheck (groupname,attribute,op,value) values ('usr','Service-Type',':=','Framed-User');\ninsert into radgroupcheck (groupname,attribute,op,value) values ('usr','Framed-IP-Address',':=','255.255.255.255');\ninsert into radgroupcheck (groupname,attribute,op,value) values ('usr','Framed-IP-Netmask',':=','255.255.255.0');\n```\n\n查看新建组 `select * from radgroupcheck; `\n\n![36](/images/接入网综合课设/36.png)\n\n可以看到，`usr` 组的认证方式为 **本地认证（Local）**， `Service-Type` 为 Framed-User，即拨号用户，用于 **PPP/PPPoE 认证**。分配给用户的 IP 地址为255.255.255.255，表示 不指定具体 IP 地址，由PPPoE 服务器动态分配。若分配了 IP 地址，默认子网掩码为 `255.255.255.0`。\n\n- 配置 RADIUS 认证用户\n\n  定义 RADIUS 用户，用于身份验证。\n\n```shell\nsudo gedit /usr/local/etc/raddb/users\n\n# 对于 client-1\nuser1 Cleartext-Password := \"test-1\"\n# 对于 client-2\nuser2 Cleartext-Password := \"test-2\"\n```\n\n- 插入用户\n\n```sql\nINSERT INTO radcheck (username, attribute, op, value) VALUES ('user1', 'Cleartext-Password', ':=', 'test-1'); \nINSERT INTO radcheck (username, attribute, op, value) VALUES ('user2', 'Cleartext-Password', ':=', 'test-2'); \n```\n\n查看用户信息 `SELECT * FROM radcheck; `\n\n![37](/images/接入网综合课设/37.png)\n\n- 关联用户和组\n\n```sql\nINSERT INTO radusergroup (username, groupname) VALUES ('user1', 'usr');\nINSERT INTO radusergroup (username, groupname) VALUES ('user2', 'usr');\n```\n\n查看用户和组的关联信息 `SELECT * FROM radusergroup; `\n\n![38](/images/接入网综合课设/38.png)\n\n- 建立软链接\n\n在 FreeRADIUS 服务器的配置目录中启用 SQL 模块\n\n```shell\nsudo -i\ncd /usr/local/etc/raddb/mods-enabled\nln -s /usr/local/etc/raddb/mods-available/sql ./\n```\n\n查看软链接信息 `ls -l /usr/local/etc/raddb/mods-enabled/sql `![39](/images/接入网综合课设/39.png)\n\n- 本地测试用户链接：\n\n```shell\nradtest user1 test-1 127.0.0.1 0 testing123\nradtest user2 test-2 127.0.0.1 0 testing123\n```\n\n![44](/images/接入网综合课设/44.png)\n\n\n\n#### 配置Radius客户端\n\n1. 下载并安装RADIUS -clients\n\n```shell\nwget ftp://ftp.freeradius.org/pub/freeradius/freeradius-client-1.1.7.tar.gz\ntar -xzvf freeradius-client-1.1.7.tar.gz \n\ncd freeradius-client-1.1.7/\n./configure \nsudo make\nsudo make install\n```\n\n2. 在 PPPoE 服务器中启用 RADIUS 认证\n\n​\t在/etc/ppp/pppoe-server-options中增加\n\n```shell\n# 加载 radius.so 插件\nplugin /usr/lib/pppd/2.4.7/radius.so\n# 指定 RADIUS 客户端配置文件\nradius-config-file /usr/local/etc/radiusclient/radiusclient.conf\n```\n\n3. 配置radiusclient.conf文件\n\n```shell\nsudo gedit /usr/local/etc/radiusclient/radiusclient.conf\n```\n\n在文件末尾添加：\n\n```shell\n# 认证顺序：先本地认证，再 RADIUS 远程认证\nauth_order      local,radius\n\n# RADIUS 认证服务器\nauthserver      192.168.30.2:1812\n# RADIUS 计费服务器\nacctserver      192.168.30.2:1813\n\n# RADIUS 共享密钥存放\nservers        /usr/local/etc/radiusclient/servers\n# RADIUS 共享密钥文件\nseqfile        /var/run/radius.seq\n# RADIUS映射文件\nmapfile        /usr/local/etc/radiusclient/port-id-map\ndictionary     /usr/local/etc/radiusclient/dictionary\nlogin_radius   /usr/local/sbin/login.radius\n```\n\n4. 配置 server 文件\n\n```shell\nsudo gedit /usr/local/etc/radiusclient/servers\n```\n\n在文件末尾添加：\n\n```shell\n# [RADIUS服务器IP]  [共享密钥]  [可选参数]\n192.168.30.2 testing123\n```\n\n5. 配置dictionary文件\n\n```shell\nsudo gedit /usr/local/etc/radiusclient/dictionary\n```\n\n在文件末尾添加：\n\n``` shell\nINCLUDE /usr/local/etc/radiusclient/dictionary.sip\nINCLUDE /usr/local/etc/radiusclient/dictionary.ascend\nINCLUDE /usr/local/etc/radiusclient/dictionary.merit\nINCLUDE /usr/local/etc/radiusclient/dictionary.compat\nINCLUDE /usr/local/etc/radiusclient/dictionary.microsoft\n```\n\n\n\n#### 测试\n\n- PPPoE服务器启动情况\n\n  ![43](/images/接入网综合课设/43.png)\n\n- Radius服务器启动情况\n\n![45](/images/接入网综合课设/45.png)\n\n- **Client1**\n\n输入正确用户及密码（user1，test-1），拨号成功\n\n![46](/images/接入网综合课设/46.png)\n\nPPPoE服务器已分配地址：\n\n![47](/images/接入网综合课设/47.png)\n\n上网测试：\n\n![49](/images/接入网综合课设/49.png)\n\n在Radius服务器端本次会话记录:\n\n![50](/images/接入网综合课设/50.png)\n\n输入错误用户及密码（user1，test-2），拨号失败\n\n![51](/images/接入网综合课设/51.png)\n\n在Radius服务器端本次会话记录:\n\n![53](/images/接入网综合课设/53.png)\n\n- **Client2**\n\n输入正确用户密码（user2，test-2），拨号成功\n\n![46](/images/接入网综合课设/46.png)\n\nPPPoE服务器已分配地址：\n\n![48](/images/接入网综合课设/48.png)\n\n上网测试：\n\n![49](/images/接入网综合课设/49.png)\n\n在Radius服务器端本次会话记录:\n\n![52](/images/接入网综合课设/52.png)\n\n输入错误用户及密码（user2，test-1），拨号失败\n\n![51](/images/接入网综合课设/51.png)\n\n![54](/images/接入网综合课设/54.png)\n\n\n\n#### 抓包分析\n\nRADIUS报文格式\n\n![55](/images/接入网综合课设/55.png)\n\nRADIUS 报文类型分为 认证报文 和 计费报文：\n\n**1. 认证报文（Authentication Messages）**\n\n认证报文用于 **用户身份验证**，确保用户合法，并为其分配相应权限。常见类型如下：\n\n| 报文类型             | 代码 | 作用                                                         |\n| -------------------- | ---- | ------------------------------------------------------------ |\n| **Access-Request**   | `1`  | 认证请求，客户端（NAS）向 RADIUS 服务器发送，包含用户名、密码等信息 |\n| **Access-Accept**    | `2`  | 认证通过，RADIUS 服务器返回，NAS 允许用户访问                |\n| **Access-Reject**    | `3`  | 认证失败，RADIUS 服务器拒绝用户访问                          |\n| **Access-Challenge** | `11` | 质询认证，要求客户端提供额外凭证（如 EAP 认证）              |\n\n** 2. 计费报文（Accounting Messages）**\n\n计费报文用于 **记录用户上网时长、流量等信息**，用于后续计费。常见类型如下：\n\n| 报文类型                | 代码 | 作用                                                 |\n| ----------------------- | ---- | ---------------------------------------------------- |\n| **Accounting-Request**  | `4`  | 计费请求，NAS 发送给 RADIUS 服务器，包含用户会话信息 |\n| **Accounting-Response** | `5`  | 计费响应，RADIUS 服务器收到计费信息后确认            |\n\n`Accounting-Request` 又分为：\n\n- **Start**（用户上线）：用户开始上网时发送，记录 `acctstarttime`。\n- **Interim-Update**（状态更新）：定期发送，更新流量、时长等数据。\n- **Stop**（用户下线）：用户断开时发送，记录 `acctstoptime`、`acctsessiontime`、流量。\n\n\n\nRADIUS客户端与服务器交互过程：\n\n![56](/images/接入网综合课设/56.png)\n\n![57](/images/接入网综合课设/57.png)\n\n**Access-Request**：\n\n![58](/images/接入网综合课设/58.png)\n\n**Access-Accept**\n\n![59](/images/接入网综合课设/59.png)\n\n**Access-Reject**\n\n![60](/images/接入网综合课设/60.png)\n\n**Accounting-Request**\n\n![61](/images/接入网综合课设/61.png)\n\n**Accounting-Response**\n\n![62](/images/接入网综合课设/62.png)\n\n\n\n#### 遇到的问题及调试方法\n\n在Radius全面配置好后，windows客户端无法直接拨号，否则显示691错误码，在radius端无信息反馈。推测PPPoE与客户端间传输存在问题。接回PPPoE本地测试可通。\n\n使用`sudo tail -f /var/log/syslog | grep ppp`监听PPPoE服务器信息\n\n当客户端拨号时，报错：\n\n```shell\nApr  3 11:19:13 xu-virtual-machine pppd[2901]: rc_read_dictionary: invalid type on line 92 of dictionary /usr/local/etc/radiusclient/dictionary\nApr  3 11:19:13 xu-virtual-machine pppd[2901]: RADIUS: Can't read dictionary file /usr/local/etc/radiusclient/dictionary\nApr  3 11:19:13 xu-virtual-machine pppd[2901]: Peer user2 failed CHAP authentication\n```\n\n- 把`/usr/local/etc/radiusclient/dictionary`文件中所有`ipv6addr`和`ipv6prdeix`改成`string`\n\n- 下载dictionary.microsoft，只有使用该文件才支持Windows拨号\n\n- 在`/usr/local/etc/radiusclient/dictionary`末尾加上\n\n  ```shell\n  INCLUDE /usr/local/etc/radiusclient/dictionary.sip\n  INCLUDE /usr/local/etc/radiusclient/dictionary.ascend\n  INCLUDE /usr/local/etc/radiusclient/dictionary.merit\n  INCLUDE /usr/local/etc/radiusclient/dictionary.compat\n  INCLUDE /usr/local/etc/radiusclient/dictionary.microsoft\n  ```\n\n  之后再拨号，Radius服务器端显示报错信息，根据具体报错信息修改即可。\n","tags":["网络","课设"]},{"title":"网络算法基础","url":"/2025/02/27/网络算法基础/","content":"\n# 算法与分治\n\nDivide and Conquer（DC）\n\nDivide：将源问题分解为规模较小的子问题，**拆分问题性质相同**，将子问题的解组合成原问题的解。\n\nConquer：如果子问题仍然困难，就继续对子问题进行分解，直到子问题可以被trivial。\n\nRecursion：用递归的方式实现。\n\n## 归并排序\n\n问题定义：\n\n- 输入：n个数构成的数组;\n\n- 输出：排列该n个数的有序数组。\n\nMerg Sort：\n\n- 分解：将原数组等分为两个子数组;\n- 求解：递归地对两个子数组分别排序;\n- 合并：将两个已排序的子数组合并。\n\n### Merge Step\n\n **CLAIM**：对于n ≥ 1的数组，MergeSort需要的运行时间T(n) ≤ $ 6n \\log_2 n + 6n $\n\n![图片](/images/网络算法基础/1.PNG \"证明\")\n\n### 函数增长的渐进符号\n\n**Big O**: 如果存在正数c和N，对于所有的n>=N，有f(n)<=c*g(n)，则f(n)=O(g(n))。\n\n**Big Omega**：如果存在正数c和N，对于所有的n>=N，有f(n)>=c*g(n)，则f(n)=Omega(g(n))。\n\n**Big Theta**：f(n)=Theta(g(n))，当且仅当f(n)=O(g(n))且f(n)=Omega(g(n))。\n\n### 基于比较的排序\n\n**CLAIM**：任何基于比较的排序算法，RT不可能低于O(nlogn)。\n\n任何基于两两比较的排序算法都可以表达为一棵决策树（完全二叉树）。\n\n完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。\n\n![图片](/images/网络算法基础/2.PNG \"决策树的性质\")\n\n### 主办法（Master Method）\n\n**主定理**\n\n![图片](/images/网络算法基础/3.PNG \"主定理的定义\")\n\n![图片](/images/网络算法基础/4.PNG \"主定理的证明\")\n\n![图片](/images/网络算法基础/5.PNG \"参数\")\n\n\n\n# 图简介\n\n## 树\n\n**树**：不包含任何圈的连通图。\n\n**生成树(Spanning Tree)**：如果图G的一个子图包含了G的全部顶点，且为树，则称之为G的生成树。\n\n\n\n## 图搜索\n\n### 循环不变式\n\n- 概念：每次循环开始时都要保持的性质 / 状态。\n- **INVARIANT**：已探索集合和未探索集合应该处于正确的状态。边界点集合应准备好了。\n  - 循环开始时，从边界点集合中选择一个顶点进行探索。\n  - 循环结束前，将新扩展的边界点纳入集合。\n- 维护边界点集合：\n  - **BFS：队列(FIFO)**\n  - **DFS：堆栈(LIFO)**\n\n### BFS\n\nBFS的伪代码：\n\n    BFS(Graph, start):\n    B.EnQueue(s)\n    WHILE B is not empty:\n        d=B.DeQueue();\n        标记d为“已探索”\n        FOR each neighbor t of d:\n            IF t is not in visited:\n                B.EnQueue(t)\n            ENDIF\n        ENDFOR\n    ENDWHILE\n\n**聚合分析复杂度**：O(n+m)\n\n### DFS\n\nDFS的伪代码：\n\n```\nDFS(Graph, start):\nB.Push(s)\nWHILE B is not empty:\n d = B.Pop()\n 标记 d 为“已探索”\n FOR each neighbor t of d:\n  IF t is not in visited:\n   B.Push(t)\n  ENDIF\n ENDFOR\nENDWHILE\n```\n\n**聚合分析复杂度**：O(n+m)\n\n\n\n## 图的连通性\n\n### <u>无向图</u>的连通分量\n\n下述等价关系的等价类：当且仅当图中具有u-v路径时，称u~v。\n\n#### BFS求无向连通分量\n\nBFS求无向连通分量的伪代码：\n\n```\nLoop-BFS(G):\nFOR i=1 to n\n\tIF t is not in visited:\n\t\tBFS(G,i);\nENDFOR\n```\n\n**聚合分析复杂度**：O(n+m)\n\n\n\n### <u>有向图</u>的强连通分量（Strongly Connected Component,SCC）\n\n下述等价关系的等价类：当且仅当有向图G中具有u -> v路径且具有v -> u路径时，称称u~v。\n\n#### TWO-PASS算法(Kosaraju算法)\n\n1. 构建逆图。\n2. **在逆图中进行 Loop-DFS**，记录每个节点的**完成时间** f(v)。\n3. **在原图中运行 Loop-DFS**，按照逆图 DFS 完成的节点顺序进行，确定每个节点的 Leader。\n\n![图片](/images/网络算法基础/6.PNG \"Kosaraju算法-1\")\n\n![图片](/images/网络算法基础/7.PNG \"Kosaraju算法-2\")\n\n**聚合分析复杂度**：O(n+m)\n\n#### **关键引理**\n\nKey Lemma：考虑有向图G中的两个临接SCC，f(v)表示顶点v在反向图G'中Loop-DFS的完成时间，则有：\n$$\n\\max_{v \\in C_1} f(v) < \\max_{v \\in C_2} f(v)\n$$\n推论：最大的f值必然在”sink“SCC中。\n\n\n\n# 贪心MST\n\n## 贪心vs分治\n\n- **决策过程**：\n  - **分治**：每个子问题的解都会考虑整个子问题的情况，逐步拆解，最终合并。\n  - **贪心**：每一步决策只关注当前的局部最优解，不回头。\n- **全局与局部**：\n  - **分治**：每个子问题的解可能涉及整个问题的全局结构。\n  - **贪心**：每一步只考虑局部最优解，期望通过局部最优解得到全局最优解。\n- **解决问题的方式**：\n  - **分治**：递归地分解问题，直到子问题足够简单直接求解。\n  - **贪心**：通过逐步选择当前最优的解来构建最终解。\n- **是否需要回溯**：\n  - **分治**：通常会回溯并合并结果。\n  - **贪心**：不会回溯，一旦做出选择就不再修改。\n\n## MST（前提：无向图）\n\n**定义**：最小权重生成树T。\n\n- 必须是无向图;\n- 生成树的权重定义为树上边权重之和;\n- 生成树定义为E的子集：\n  1. 必须覆盖V;\n  2. 无环;\n  3. 连通。\n\n![图片](/images/网络算法基础/8.PNG \"MST\")\n\n### 割\n\n割的概念：图G(V，E)的一个割(Cut)是V的一个划分，该划分将集合V分为两个非空的集合。\n\n![图片](/images/网络算法基础/9.PNG \"割\")\n\n- n个顶点的图最多有 $ 2^n-2 $ 个不同的割。\n\n**Empty-Cut引理**：图G不连通，当且仅当Cut(A，B)没有割边。\n\n**Double-Crossing Lemma**：如果某个圈C⊆E中有边跨越了Cut(A，B)，则C中**至少还有一条边**跨越Cut(A，B)。\n\n**Lonely-Cut Corollary**：如果边e是跨越了Cut(A，B)的唯一一条边，则e不可能在**任一**圈中。\n\n**The Cut Property**：考虑图G中的一条边e，如果存在Cut(A，B)，使得e是所有跨越该割的所有边中权最小者，则e一定在G的MST中。\n\n割的证明：\n\n![图片](/images/网络算法基础/10.PNG \"割的证明-1\")\n\n![图片](/images/网络算法基础/11.PNG \"割的证明-2\")\n\n\n\n### 堆（Heap）\n\n一个容器，其中元素具有key。\n\n常规操作及对应的RT：\n\n- Heapify：建堆 O(n)\n- Insert：加入一个新的对象 O(logn)\n- Extract-Min：从堆中取出具有最小key的元素 O(logn)\n- Delete：删除指定元素 O(logn)\n\n#### **Heap Property**\n\n- 堆是一颗有根，二叉，尽可能完全的树。\n- 任何节点的key都不大于其所有子代的key。 ——> **根元素具有最小key**\n\n#### **用数组实现堆**\n\n- Parent (i) = i / 2  （下标i为奇数时向下取整）\n- LeftC (i) = 2i\n- RightC (i) = 2i + 1\n\n![图片](/images/网络算法基础/12.PNG \"堆的操作-1\")\n\n![图片](/images/网络算法基础/13.PNG \"堆的操作-2\")\n\n\n\n### **Prime算法**\n\n基本思想：\n\n- 从一个节点开始（任意选择一个节点作为起点），将它加入生成树。\n- 找到当前生成树中所有节点与其他节点之间的边，选择权重最小的边。\n- 将与该边相连的节点加入生成树，更新最小边的权重，重复选择最小边的过程。\n- 直到所有节点都被加入到生成树中。\n\nPim的伪代码：\n\n```\nPrim(Graph, start):\n    初始化最小生成树的边集合 MST = {}\n    初始化一个优先队列 Q，用于存储每个节点及其最小边的权重\n    对于每个节点 v ∈ Graph:\n        设置 v 的最小权重为无穷大（∞）\n    设置 start 节点的最小权重为 0，并将其加入 Q\n\n    WHILE Q is not empty:\n        选择 Q 中最小的权重的节点 u\n        标记 u 为“已加入到最小生成树”\n\n        对于 u 的每个邻居 v:\n            IF v is not in MST AND weight(u, v) < v 的当前权重:\n                更新 v 的最小权重为 weight(u, v)\n                将 v 更新到 Q 中，以反映其新的最小权重\n\n        ENDFOR\n    ENDWHILE\n```\n\nPrim算法的证明：\n\n![图片](/images/网络算法基础/14.PNG \"Prim的证明-1\")\n\n![图片](/images/网络算法基础/15.PNG \"Prim的证明-2\")\n\n用堆实现Prim：\n\n    Prim(Graph, start):\n        初始化最小生成树 MST = {}\n        初始化最小堆 MinHeap\n        初始化一个集合 Visited，用于记录已加入 MST 的节点\n        将 (0, start) 插入 MinHeap  // (边的权重, 节点)\n        初始化 total_weight = 0  // 记录最小生成树的总权重\t\n    \tWHILE MinHeap is not empty:\n        \t(weight, node) = MinHeap.Pop()  // 取出当前权重最小的边\n       \t IF node 已在 Visited:\n        \t    CONTINUE  // 如果该节点已经在 MST 中，跳过\n    \n      \t  标记 node 为已访问\n      \t  total_weight += weight  // 累加权重\n      \t  MST.Add(node)\n    \n    \t    FOR each (neighbor, edge_weight) in Graph[node]:  // 遍历邻居\n         \t   IF neighbor 不在 Visited:\n           \t     MinHeap.Push((edge_weight, neighbor))  // 只加入未访问的节点\n    \n    \tRETURN MST, total_weight\n\n**复杂度分析**：\n\n- n次Extract-Min：O(nlogn)\n- m次Delete和m次Insert：O(mlogn)\n\n总RT = O(nlogn)+O(mlogn) = **O(mlogn)**\n\n\n\n## Kruskal算法\n\n基本思想：\n\n- 按权重升序对边排序。\n- 按序逐条检查边。\n- 只要不成环，就将边加入T。\n\nKruskal的伪代码：\n\n    Kruskal(Graph):\n        初始化最小生成树 MST = {}\n        初始化并查集（Union-Find）来管理连通性\n        按照权重从小到大排序 Graph 的所有边 EdgeList\n    \tFOR (u, v, weight) in EdgeList:  // 遍历排序后的边\n       \t IF u 和 v 不在同一个连通分量 (Find(u) ≠ Find(v)):\n        \t    MST.Add((u, v, weight))  // 加入最小生成树\n      \t      Union(u, v)  // 合并连通分量\n      \t  IF MST 的边数 == V - 1:\n         \t   BREAK  // 最小生成树构建完成\n    \tRETURN MST\n\nKruskal算法的证明：\n\n![图片](/images/网络算法基础/16.PNG \"Kruskal的证明-1\")\n\n![图片](/images/网络算法基础/17.PNG \"Kruskal的证明-2\")\n\n#### UNION-FIND算法\n\nUnion-Find（并查集）是一种高效的数据结构，主要用于**处理动态连通性问题**。它支持两种核心操作：\n\n1. **Find(x)**：查找元素 `x` 所属的集合（返回它的代表元素）。\n2. **Union(x, y)**：合并 `x` 和 `y` 所在的两个集合。\n\n核心思想：\n\n- **每个集合用一棵树表示**，树的根节点作为该集合的**代表元**（代表元素）。\n- **Find(x)** 操作用于查找 `x` 所在集合的代表元（根节点）。\n- **Union(x, y)** 操作用于合并两个集合，**将其中一个集合的根节点指向另一个集合的根**。\n\n\n\n# Dijkstra算法\n\nDijkstra的前提：**无负权图（源点到第一层点的权重可为负值），避免负圈。**\n\nDijkstra的基本思路：\n\n1. 初始化：\n\n- 设 `dist[s] = 0`（起点到自身的距离为 0），其他所有点 `dist[v] = ∞`（起始时认为未知）。\n- 用一个**优先队列（最小堆）**维护当前已发现的最短距离点。\n\n2. 贪心扩展：\n\n- 每次从**未访问的节点中选取当前 `dist[v]` 最小的点 `u`**。\n- 遍历 u的所有邻居 v，尝试松弛：\n  - **如果 `dist[u] + w(u, v) < dist[v]`，更新 `dist[v]`**，并将 `v` 加入优先队列。\n\n3. 终止：所有节点均已访问，或优先队列为空（所有可达点已确定最短路径）。\n\n\n\nDijkstra的伪代码：\n\n```\nDijkstra(Graph, start):\n    初始化 dist[]，所有点设为 ∞，dist[start] = 0\n    初始化优先队列 PQ，插入 (0, start)  // (当前最短距离, 顶点)\n    初始化 visited[] 记录已确定最短路径的点\n\n    WHILE PQ 不为空:\n        (d, u) = PQ.Pop()  // 取出当前最短距离的点\n        IF u 已访问:\n            CONTINUE\n        标记 u 为已访问\n\n        FOR each 邻居 (v, weight) of u:\n            IF dist[u] + weight < dist[v]:  // 进行松弛操作\n                dist[v] = dist[u] + weight\n                PQ.Push((dist[v], v))  // 将 v 加入优先队列\n    \n    RETURN dist[]\n```\n\n## 循环桶\n\n**桶（Bucket）** 是一种数据存储和分类的方法，可以根据某种规则（如哈希值、时间、范围等）**将数据映射到不同的桶中**，以加快查询、存储或计算的效率。\n\n循环桶将数据按照一定规则分配到有限个桶（Bucket）中，并循环使用这些桶。\n\n### 循环桶的核心特点\n\n1. 固定数量的桶（N 个）：\n   - 设定 `N` 个桶，编号从 `0` 到 `N-1`，它们按照顺序**排列成一个循环结构**。\n   - 访问时**基于取模（modulo）运算**，保证访问永远落在 `0 ~ N-1` 之间。\n2. 循环访问（Modulo 取模）：\n   - 计算索引 `index = (当前时间 t) % N`，从而使得时间到了 `N` 之后会回到 `0`，形成循环管理。\n\n### 用循环桶实现Dijkstra算法：\n\n**CLAIM**：Dijkstra算法中最多只需要C+1个桶。\n\n- 永久标记的顶点和非边界顶点不在桶中。\n- 边界点的距离标记不会超过A[i]+C（i为当前标记点）\n- 顶点x的桶的编号：A[x]mod(C+1)\n\n```\nDijkstra_CircularBucket(Graph, start):\n    初始化 dist[]，所有点设为 ∞，dist[start] = 0\n    初始化桶 Bucket[]，桶的数量为 C+1，存储每个距离区间的节点\n    初始化 visited[]，记录顶点是否已被永久标记\n    \n    将起点 start 放入 Bucket[0] 中（dist[start] = 0）\n    \n    WHILE 有节点未被永久标记:\n        从桶中找出具有最小距离的非永久标记的边界点 u\n        标记 u 为永久标记，并从桶中移除 u\n        \n        FOR 每个邻居 v of u:\n            IF v 没有被永久标记:\n                IF dist[u] + w(u, v) < dist[v]:\n                    dist[v] = dist[u] + w(u, v)  // 松弛操作\n                    将 v 放入 Bucket[dist[v] mod (C + 1)] 中  // 根据 dist[v] 放入桶\n                    更新 v 的距离标记\n\n    RETURN dist[]\n```\n\n**复杂度分析**：O(m+nC)\n\n\n\n## Dijsktra算法扩展\n\n### 单源单宿最短路问题\n\n问题描述：给定图G，给定顶点s和d，求从s到d的最小权重路径。\n\n解决方式：增加一个判断分支，d被永久标记时终止循环。\n\n\n\n1111111111111111\n","tags":["图","算法"]},{"title":"about","url":"/about/index.html","content":"\n\n\n![](/images/页面/1.jpg)\n\n# 个人介绍\n\n欢迎来到我的博客。\n\n这里是李双仪，INTJ-A / 一名RCer 。\n偶尔记录一些奇怪的想法，偶尔分享一些折腾的过程，偶尔写一些大学生活指南，可能有趣，也可能只是碎碎念。💬\n\n希望你能在这找到一点点灵感，随时交流，欢迎常来。 🌿\n\n\n\n# 技术栈\n\n- Linux\n- 深度相机\n- 2D/3D雷达\n- 机器人视觉\n- C / C++\n- Python\n- Pytorch\n\n\n\n# 联系方式\n\n- 邮箱：1365895688@qq.com\n- Github：https://github.com/Li-shuangyi\n\n"},{"title":"tags","url":"/tags/index.html"},{"title":"categories","url":"/categories/index.html"}]