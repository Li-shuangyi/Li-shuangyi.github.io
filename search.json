[{"title":"网络算法基础","url":"/2025/02/27/网络算法基础/","content":"\n# 算法与分治\n\nDivide and Conquer（DC）\n\nDivide：将源问题分解为规模较小的子问题，**拆分问题性质相同**，将子问题的解组合成原问题的解。\n\nConquer：如果子问题仍然困难，就继续对子问题进行分解，直到子问题可以被trivial。\n\nRecursion：用递归的方式实现。\n\n## 归并排序\n\n问题定义：\n\n- 输入：n个数构成的数组;\n\n- 输出：排列该n个数的有序数组。\n\nMerg Sort：\n\n- 分解：将原数组等分为两个子数组;\n- 求解：递归地对两个子数组分别排序;\n- 合并：将两个已排序的子数组合并。\n\n### Merge Step\n\n **CLAIM**：对于n ≥ 1的数组，MergeSort需要的运行时间T(n) ≤ $ 6n \\log_2 n + 6n $\n\n![图片](/images/网络算法基础/1.PNG \"证明\")\n\n### 函数增长的渐进符号\n\n**Big O**: 如果存在正数c和N，对于所有的n>=N，有f(n)<=c*g(n)，则f(n)=O(g(n))。\n\n**Big Omega**：如果存在正数c和N，对于所有的n>=N，有f(n)>=c*g(n)，则f(n)=Omega(g(n))。\n\n**Big Theta**：f(n)=Theta(g(n))，当且仅当f(n)=O(g(n))且f(n)=Omega(g(n))。\n\n### 基于比较的排序\n\n**CLAIM**：任何基于比较的排序算法，RT不可能低于O(nlogn)。\n\n任何基于两两比较的排序算法都可以表达为一棵决策树（完全二叉树）。\n\n完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。\n\n![图片](/images/网络算法基础/2.PNG \"决策树的性质\")\n\n### 主办法（Master Method）\n\n**主定理**\n\n![图片](/images/网络算法基础/3.PNG \"主定理的定义\")\n\n![图片](/images/网络算法基础/4.PNG \"主定理的证明\")\n\n![图片](/images/网络算法基础/5.PNG \"参数\")\n\n\n\n# 图简介\n\n## 树\n\n**树**：不包含任何圈的连通图。\n\n**生成树(Spanning Tree)**：如果图G的一个子图包含了G的全部顶点，且为树，则称之为G的生成树。\n\n\n\n## 图搜索\n\n### 循环不变式\n\n- 概念：每次循环开始时都要保持的性质 / 状态。\n- **INVARIANT**：已探索集合和未探索集合应该处于正确的状态。边界点集合应准备好了。\n  - 循环开始时，从边界点集合中选择一个顶点进行探索。\n  - 循环结束前，将新扩展的边界点纳入集合。\n- 维护边界点集合：\n  - **BFS：队列(FIFO)**\n  - **DFS：堆栈(LIFO)**\n\n### BFS\n\n    BFS(Graph, start):\n    B.EnQueue(s)\n    WHILE B is not empty:\n        d=B.DeQueue();\n        标记d为“已探索”\n        FOR each neighbor t of d:\n            IF t is not in visited:\n                B.EnQueue(t)\n            ENDIF\n        ENDFOR\n    ENDWHILE\n\n**聚合分析复杂度**：O(n+m)\n\n### DFS\n\n```\nDFS(Graph, start):\nB.Push(s)\nWHILE B is not empty:\n d = B.Pop()\n 标记 d 为“已探索”\n FOR each neighbor t of d:\n  IF t is not in visited:\n   B.Push(t)\n  ENDIF\n ENDFOR\nENDWHILE\n```\n\n**聚合分析复杂度**：O(n+m)\n\n\n\n## 图的连通性\n\n### <u>无向图</u>的连通分量\n\n下述等价关系的等价类：当且仅当图中具有u-v路径时，称u~v。\n\n#### BFS求无向连通分量\n\n```\nLoop-BFS(G):\nFOR i=1 to n\n\tIF t is not in visited:\n\t\tBFS(G,i);\nENDFOR\n```\n\n**聚合分析复杂度**：O(n+m)\n\n\n\n### <u>有向图</u>的强连通分量（Strongly Connected Component,SCC）\n\n下述等价关系的等价类：当且仅当有向图G中具有u -> v路径且具有v -> u路径时，称称u~v。\n\n#### TWO-PASS算法(Kosaraju算法)\n\n1. 构建逆图。\n2. **在逆图中进行 Loop-DFS**，记录每个节点的**完成时间** f(v)。\n3. **在原图中运行 Loop-DFS**，按照逆图 DFS 完成的节点顺序进行，确定每个节点的 Leader。\n\n![图片](/images/网络算法基础/6.PNG \"Kosaraju算法-1\")\n\n![图片](/images/网络算法基础/7.PNG \"Kosaraju算法-2\")\n\n**聚合分析复杂度**：O(n+m)\n\n#### **关键引理**\n\nKey Lemma：考虑有向图G中的两个临接SCC，f(v)表示顶点v在反向图G'中Loop-DFS的完成时间，则有：\n$$\n\\max_{v \\in C_1} f(v) < \\max_{v \\in C_2} f(v)\n$$\n","tags":["图","算法"]},{"url":"/categories/index.html","content":"---\n​---\ntitle:categories\nlayout:categories\n​---\n---\n"},{"url":"/about/index.html","content":"---\n​---\ntitle:about\nlayout:about\n​---\n---\n"},{"url":"/tags/index.html","content":"---\n​---\ntitle:tags\nlayout:tags\n​---\n---\n"}]