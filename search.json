[{"title":"网络算法基础","url":"/2025/02/27/网络算法基础/","content":"\n# 算法与分治\n\nDivide and Conquer（DC）\n\nDivide：将源问题分解为规模较小的子问题，**拆分问题性质相同**，将子问题的解组合成原问题的解。\n\nConquer：如果子问题仍然困难，就继续对子问题进行分解，直到子问题可以被trivial。\n\nRecursion：用递归的方式实现。\n\n## 归并排序\n\n问题定义：\n\n- 输入：n个数构成的数组;\n\n- 输出：排列该n个数的有序数组。\n\nMerg Sort：\n\n- 分解：将原数组等分为两个子数组;\n- 求解：递归地对两个子数组分别排序;\n- 合并：将两个已排序的子数组合并。\n\n### Merge Step\n\n **CLAIM**：对于n ≥ 1的数组，MergeSort需要的运行时间T(n) ≤ $ 6n \\log_2 n + 6n $\n\n<img src=\"/home/qi/my-blog/source/images/网络算法基础/1.PNG\" alt=\"1\" style=\"zoom:50%;\" />\n\n### 函数增长的渐进符号\n\n**Big O**: 如果存在正数c和N，对于所有的n>=N，有f(n)<=c*g(n)，则f(n)=O(g(n))。\n\n**Big Omega**：如果存在正数c和N，对于所有的n>=N，有f(n)>=c*g(n)，则f(n)=Omega(g(n))。\n\n**Big Theta**：f(n)=Theta(g(n))，当且仅当f(n)=O(g(n))且f(n)=Omega(g(n))。\n\n### 基于比较的排序\n\n**CLAIM**：任何基于比较的排序算法，RT不可能低于O(nlogn)。\n\n任何基于两两比较的排序算法都可以表达为一棵决策树（完全二叉树）。\n\n完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。\n\n<img src=\"/home/qi/my-blog/source/images/网络算法基础/2.PNG\" alt=\"2\" style=\"zoom:50%;\" />\n\n### 主办法（Master Method）\n\n**主定理**\n\n<img src=\"/home/qi/my-blog/source/images/网络算法基础/3.PNG\" alt=\"3\" style=\"zoom:50%;\" />\n\n<img src=\"/home/qi/my-blog/source/images/网络算法基础/5.PNG\" alt=\"5\" style=\"zoom:50%;\" />\n\n<img src=\"/home/qi/my-blog/source/images/网络算法基础/4.PNG\" alt=\"4\" style=\"zoom:50%;\" />\n\n","tags":["图","算法"]},{"url":"/categories/index.html","content":"---\n​---\ntitle:categories\nlayout:categories\n​---\n---\n"},{"url":"/about/index.html","content":"---\n​---\ntitle:about\nlayout:about\n​---\n---\n"},{"url":"/tags/index.html","content":"---\n​---\ntitle:tags\nlayout:tags\n​---\n---\n"}]