[{"title":"Path_planning_learning","url":"/2025/04/06/Path-planning-learning/","content":"\n# OverView\n\n## 前端:路径寻找\n\n### 基于搜索\n\n- 图搜索基础\n- Dijkstra and A*\n- Jump Point Search\n\n### 基于采样\n\n- Probabilstic Road Map\n- RRT\n- RRT* / Informed RRT\n\n### 基于运动学动态路径寻找\n\n- State-state Boundary Value Optimal Control Problem\n- State Lattic Search\n- Kinodynamic RRT*\n- Hybrid A*\n\n## 后端:轨迹生成\n\n### MINIMUN SNAP TRAJECTORY GENERATION\n\n### SOFT AND HARD CONSTRAINED TRAJECTORY OPTIMIZATION\n\n\n\n# MAP\n\n## Occupancy grid map\n\ngithub:https://github.com/ANYbotics/grid_map\n\n- 排列紧密\n- 结构化\n- 索引队列访问\n\n缺点:当切分过于细密时空间占用率大.\n\n\n\n## Octo-map\n\ngithub:https://github.com/OctoMap/octomap_mapping\n\n地图中大部分为稀疏部分,使用八叉树的数据结构储存.如果一个区块没有障碍物,不再细分该区块;如果一个区块有障碍物则细分至最小包含该障碍物的区块.\n\n**Octree**\n\n八叉树（Octree）是一种用于描述三维空间的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，将八个子节点所表示的体积元素加在一起就等于父节点的体积。八叉树是四叉树在三维空间上的扩展，二维上我们有四个象限，而三维上，我们有8个卦限。八叉树主要用于空间划分和最近邻搜索。\n\n实现Octree的原理:\n\n- 将当前的立方体细分为八个子立方体。\n- 如果任何一个子立方体内包含多个点，则将其进一步细分为八个子立方体。\n- 重复以上操作使得每个子立方体内包含最多一个点。\n\n![八叉树1](/images/path_planning_learning/1.png)\n\n![八叉树2](/images/path_planning_learning/2.webp)\n\n- 排列稀疏\n- 结构化\n- 非直接索引访问(树的查询)\n\n\n\n## Voxel hashing\n\ngithub:https://github.com/niessner/VoxelHashing\n\n记录存在碰撞的区块 ----> 哈希表,**字典**\n\n一个bucket中划分为更小的voxel blocks\n\n![Voxel](/images/path_planning_learning/3.png)\n\n- 排列最稀疏\n- 结构化\n- 非直接索引访问(字典查询)\n\n\n\n## Point Cloud Map\n\n- 无序\n- 无法通过索引队列访问(除非自发遍历)\n\n\n\n## TSDF map\n\n**Truncated Signed Distance Functions (截断/有符号/距离函数)**\n\ngithub:\n\nTSDF 是一种用于表示3D空间表面的体素网格地图.\n\n### Signed Distance Function (SDF)\n\n对于空间中任意一点 x，SDF 给出它到最近表面的距离 d：\n$$\nSDF(x)=±d\n$$\n\n- +d：点在**表面外部**（通常指相机方向）\n- −d：点在**表面内部**\n- d=0：点在表面上（即零交叉点）\n\n### Truncated SDF（TSDF）\n\n真实计算中远离表面部分的距离信息不重要且不准确，因此会进行截断：\n\n- 若 ∣d∣> μ，则 TSDF 值为截断值。\n- μ 是截断距离阈值（truncation distance）。\n\n### Voxel Grid（体素网格）\n\nTSDF 存在于一个 3D 网格中（类似立方体像素）：\n\n- 每个体素（voxel）存储：\n  - 当前体素的 TSDF 值\n  - 加权平均值（来自多个观测帧）\n  - 权重（用于融合多个观测）\n\n![TSDF1](/images/path_planning_learning/4.png)\n\n![TSDF2](/images/path_planning_learning/5.png)\n\n\n\n##  ESDF Map\n\n**Euclidean Signed Distance Field 欧几里得有符号距离场**\n\n以 3D 网格（体素）的形式表示环境中每一点**到障碍物最近点的欧几里得距离**，并附带符号来表示点位于障碍物内部或外部。局部ESDF地图:只记忆感兴趣部分的ESDF值.\n\n![ESDF1](/images/path_planning_learning/6.png)\n\n![ESDF2](/images/path_planning_learning/7.png)\n\n\n\n## Free-space Roadmap\n\n概率路线图 ----> 安全通行区域,使用**凸多边体**表示\n\n得到的是一个宽阔的解空间\n\n\n\n## Voronoi Diagram Map\n\n高效利用ESDF提取地图骨架 ----> 稀疏\n\n\n\n# 基于搜索的路径寻找\n\n## A*\n\nA*算法在Dijkstra算法的基础上引入了启发函数(贪心思想)，启发函数是对当前节点到目标节点所需代价的预估.启发式函数一般使用曼哈顿距离、欧几里德距离。\n\n> 1. 从起点开始，将其加入待探索的节点集合（open set）。\n>\n> 2. 每次选择 f 值最小的节点进行扩展，其中 `f(n) = g(n) + h(n)`\n>\n> - `g(n)` 是从起点到当前节点的实际代价\n> - `h(n)` 是从当前节点到终点的启发式估计（如直线距离）\n>\n> 3. 对当前节点的所有相邻节点，计算新的 g 值，更新路径记录。\n>\n> 4. 如果发现更优路径（g 值更小），则更新该邻居的记录，并加入 open set。\n>\n> 5. 重复以上步骤，直到终点被选中扩展，表示找到最短路径。\n>\n> 6. 通过路径记录表回溯，重建从起点到终点的完整路径。\n\n伪代码\n\n```c++\n• 维护一个优先级队列来存储所有待扩容节点\n• 所有节点的启发式函数h(n)是预定义的\n• 优先级队列初始化为起始状态 X S\n• 对图中所有其他节点赋值g(X S) = 0, g(n) = infinite\n• Loop\n    •如果队列为空，则返回FALSE；BREAK;\n    •从优先级队列中删除f(n)=g(n)+h(n)最小的节点“n”\n    •将节点“n”标记为展开\n    •如果节点“n”是目标状态，返回TRUE；BREAK;\n    •对于节点n的所有未展开的邻居 m\n\t\t•If g(m) = infinite\n\t\t\t• g(m)= g(n) + Cnm\n    •对于节点n的所有未展开的邻居 m\n\t\t•If g(m) = infinite\n\t\t\t• g(m)= g(n) + Cnm\n\t\t\t• Push node “m” into the queue\n\t\t•If g(m) > g(n) + C nm\n\t\t\t•g(m)= g(n) + Cnm\n\t•end\n• End Loop\n```\n\n\n\n### Weighted A* Search\n\nSub-Optimal Solution\n\n通过人为加大启发函数的影响力来获得更快的搜索速度，以牺牲路径最优性为代价。\n\nf = g + εh, ε > 1 =bias towards states that are closer to goal.\n\n![Weighted_A*_Search](/images/path_planning_learning/8.png)\n\n- Most Greedy（最贪婪）\n\n- 参数：a=0,b=1\n- 只考虑启发式代价，完全不考虑当前路径代价\n- 结果：趋向于直接朝目标点移动，但路径不一定最短或最优\n\n------\n\n- Tunable Greediness（可调贪婪度）\n\n- 参数：a=1,b=ε>1\n- 综合考虑当前路径和启发式估计，但偏向启发式\n- 结果：平衡探索性和效率，路径更合理\n\n------\n\n- Optimal（最优路径）\n\n- 参数：a=1,b=1\n- 平等考虑已知路径和启发估计\n- 结果：找到最优路径\n\n------\n\n- Dijkstra算法\n\n- 参数：a=1,b=0\n- 完全不使用启发式，只靠实际代价 g,效率低\n\n\n\n### A*的实施流程\n\n1. 建立地图 → 生成网格节点数组\n\n2. 设定障碍 → 标记不可达节点\n\n3. 编写邻居搜索函数\n\n4. 编写A*主循环：\n\n   - 从openList中取出f值最小的节点\n\n   - 计算邻居的g/h/f值，加入openList\n\n   - 更新已访问节点（closedList）\n\n5. 使用`priority_queue`或`multimap`优化性能\n\n\n\n### **最好的启发函数**\n\n**最好:tight**,正确的最短距离函数\n\n> 二维最佳启发函数:\n> $$\n> h2D​=(dx+dy)+(2\n> ​−2)⋅min(dx,dy)\n> $$\n> 三维最佳启发函数:\n>\n> 我们记 dx,dy,dz为三维网格中当前点与目标点在三个轴上的距离（均为非负整数），有：\n> $$\n> h3D=dmin⋅3+(dmid−dmin)⋅2+(dmax−dmid)⋅1\n> $$\n> 其中：dmin,dmid,dmax是 dx,dy,dzdx,dy,dz 的排序结果，使得\n>\n> $$\n> dmin≤dmid≤dmax\n> $$\n\n\n\n### Tie Breaker\n\n平局处理器,打破 f 值相等时的探索顺序\n\n- 问题:\n\n​\tA* 会选取 f 值最小的节点扩展（f=g+h）\n\n​\t但在一些情形下，很多节点的 f 值完全相等,尤其是在网格图中启发函数不够 tight 的时候\n\n​\t导致算法要探索很多不必要的节点，降低效率\n\n>- **解决方法:**\n>\n>1. 人为干扰 h，让 f 值不同:\n>\n>   将原来的启发函数 h乘上一个微小因子：\n> $$\n>   h=h×(1.0+p)\n> $$\n>   其中：\n> $$\n>   p < \\frac{\\text{最小步长代价}}{\\text{预期路径总长度}}\n> $$\n>   这样能 **轻微打破平局**，减少无效扩展\n>\n>   代价是轻微地破坏启发式的“可采纳性”（admissibility），但常常实际无影响或带来更好效率.\n>\n>2. 优先选 h值小的节点\n>\n>   如果两个节点 f 一样，选择 h 小的那个（靠近终点）\n>\n>3. 加入伪随机干扰项（Deterministic random）\n>\n>- 给每个节点加一个唯一扰动，保持一致性但不完全对称\n>\n>4. 优先靠近起点-终点连线的路径\n>\n>$$\n>cross=∣dx1×dy2−dx2×dy1∣\n>$$\n>\n>**这其实是在衡量点偏离直线的“面积”，越小越靠近理想路径。**\n\n\n\n## Jump Point Search\n\n核心思想:**在两点之间没有障碍物时，中间的节点不考虑,只考虑重要节点.**\n\n1. 邻居修剪 Neighbor Pruning\n\n- 灰色节点：较差的邻居，当去到它们时，没有分值的路径更便宜。丢弃。\n\n\n- 白色节点：自然邻居。\n\n\n​\t只需要考虑**自然邻居**.\n\n![Neighbor Pruning](/images/path_planning_learning/9.png)\n\n2. 强迫邻居 Forced Neighbors\n\n节点X的邻居节点有障碍物，且X的父节点P经过X到达N的距离代价，比不经过X到大N的任一路径的距离代价都小，则称N是X的强迫邻居。\n\n- 有相邻的障碍\n\n- 红色节点是强制邻居。\n\n- 一条从父母到他们通过障碍的更便宜的路径被阻断。\n\n\n![Forced Neighbors](/images/path_planning_learning/10.png)\n\n3. 跳点(Jump Point)：什么样的节点可以作为跳点\n    (1)节点 A 是起点、终点.\n    (2)节点A 至少有一个强迫邻居.\n    (3)父节点在斜方向(斜向搜索)，节点A的水平或者垂直方向上有满足 (1)、(2) 的节点\n\n![Jump Point](/images/path_planning_learning/11.png)\n\n跳点搜索中，会递归地检查路径上的邻居节点是否是“跳点”。在检查对角线方向前，会优先尝试直线方向。只要某个节点通往某些邻居的最短路径必须经过它，它就会被标记为跳点。同时，对“强制邻居”不能剪枝，必须展开。\n\n\n\n# 基于采样的路径寻找\n\n## Probabilistic Road Map\n\n图结构\n\n将规划分为两个阶段：\n·学习阶段\n·查询阶段\n\n检查采样配置和连接的样本之间的碰撞可以有效率地完成任务。\n数量相对较少的里程碑和局部路径足以捕获的连通性。\n\n- 限制路径点连接的长度避免图结构过于复杂\n\n### 学习阶段:\n\n- 在c空间中采样N个点\n- 删除碰撞点\n\n![PRM-Learning1](/images/path_planning_learning/12.png)\n\n- 连接到最近的点，并获得无碰撞段。\n- 删除碰撞段\n\n![PRM-Learning2](/images/path_planning_learning/13.png)\n\n### 查询阶段:\n\n- 在路线图上搜索，找到从起点到终点的路径目标（使用Dijkstra算法或A*算法）。\n- 路线图现在类似于网格地图\n\n![PRM-Query](/images/path_planning_learning/14.png)\n\n优点\n\n- 概率完备\n\n\n缺点\n\n- 要求解决两点边值问题\n\n- 在状态空间上构建图，但不特别关注生成路径\n\n- 效率不高\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["算法"]},{"title":"接入网综合课设","url":"/2025/03/10/接入网课设/","content":"\n#  接入网综合课设\n\n## 阶段一\n\n1. 完成虚拟机选型，并配置至少两个网段， 分别测试子网内和子网间连通性； \n\n2. 设计PPPOE本地认证拓扑图及IP地址规划 (客户至少两个网段)  ；\n\n3. 选型PPPOE服务器软件，并在虚拟环境下 完成PPPoE接入本地认证的搭建、配置、 实验测试。\n\n### 任务一\n\n#### 子网规划\n\n虚拟机选型：ubuntu20.04\n\n配置网段：\n\n- Vmnet1:192.168.10.0/24\n- Vmnet2:192.168.20.0/24 \n- Vmnet3:192.168.30.0/24\n\n![子网规划](/images/接入网综合课设/1.png)\n\n#### 配置流程\n\n1. 在ubuntu编辑-虚拟网络编辑器中选择更改设置，赋予管理员权限后选择添加网络，类型为**仅主机模式**，修改子网IP和子网掩码。\n\n![虚拟网络编辑器](/images/接入网综合课设/2.png)\n\n2. 在ubuntu虚拟机设置中添加网卡，三张为子网规划中定义所对应的网卡。\n\n![虚拟机设置](/images/接入网综合课设/3.png)\n\n![硬件设置](/images/接入网综合课设/4.png)\n\n对应网络适配器选择自定义-特定虚拟网络-选择对应网卡-确定。\n\n![虚拟机设置](/images/接入网综合课设/5.png)\n\n3. 在ubuntu中输入\n\n```shell\nifconfig\n```\n\n出现对应网卡信息。\n\n![网卡信息](/images/接入网综合课设/6.png)\n\n4. 配置静态IP。参考博客：[Ubuntu配置静态IP](https://blog.csdn.net/weixin_58305495/article/details/130554393)，注意与网卡名称匹配。\n\n**Ubuntu 16.04 及更早版本**：网络管理工具使用 `ifupdown`，网络配置文件在 `/etc/network/interfaces`\n\n```shell\nauto lo\niface lo inet loopback\n\nauto eth0\niface eth0 inet dhcp\n\nauto eth1\niface eth1 inet static\naddress 192.168.10.10\nnetmask 255.255.255.0\ngateway 192.168.10.1\ndns-nameservers 8.8.8.8 8.8.4.4\n\nauto eth2\niface eth2 inet static\naddress 192.168.20.10\nnetmask 255.255.255.0\ngateway 192.168.20.1\n\nauto eth3\niface eth3 inet static\naddress 192.168.30.10\nnetmask 255.255.255.0\ngateway 192.168.30.1\n\n```\n\n**Ubuntu 17.10 及更高版本**：网络管理工具使用 `Netplan`，配置文件位于 `/etc/netplan/00-installer-config.yaml`\n\n```yaml\n# Let NetworkManager manage all devices on this system\nnetwork:\n  version: 2\n  renderer: NetworkManager\n  ethernets:\n    ens33:            \n      dhcp4: true                          \n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]       \n\n    ens37:\n      addresses: [192.168.10.10/24]        \n      routes:\n        - to: default\n          via: 192.168.10.1                \n      dhcp4: false                          \n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]      \n\n    ens38:\n      addresses: [192.168.20.10/24]         \n      routes:\n        - to: default\n          via: 192.168.20.1                \n      dhcp4: false                          \n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]   \n\n    ens39:\n      addresses: [192.168.30.10/24]        \n      routes:\n        - to: default\n          via: 192.168.30.1              \n      dhcp4: false                     \n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]   \n```\n\n配置完成后执行命令使配置生效。\n\n```shell\nsudo netplan apply\n```\n\n执行`ifconfig`命令查看当前IP地址。\n\n\n\n####  测试\n\n**子网间连通性**\n\n![Linux子网间连通性](/images/接入网综合课设/7.png)\n\nClient1(192.168.10.20)\n\n![Client1子网间连通性](/images/接入网综合课设/8.png)\n\nClient2(192.168.20.20)\n\n<img src=\"/images/接入网综合课设/9.png\" alt=\"image-20250308132954522\" style=\"zoom: 80%;\" />\n\n**子网内连通性**\n\nClient1(192.168.10.20)\n\n![Client1子网内连通性](/images/接入网综合课设/10.png)\n\nClient2(192.168.20.20)\n\n<img src=\"/images/接入网综合课设/11.png\" alt=\"image-20250308133215681\" style=\"zoom:80%;\" />\n\n### 任务三\n\n#### PPPoE服务器端\n\n[参考博客:基于Linux环境的PPPOE服务器搭建](https://zhuanlan.zhihu.com/p/41499761)\n\n1. 安装PPPoE服务器程序\n\n```shell\nsudo apt-get install pppoe\n```\n\n使用`pppoe-server -h`查看pppoe安装情况及版本,该PPPoE-Server版本为3.12。\n\n![PPPoE服务器版本](/images/接入网综合课设/12.png)\n\n2. 编辑/etc/ppp/options文件\n\n- PAP：明文密码认证协议。\n- CHAP：挑战握手认证协议，**三次握手**机制，使用哈希加密。\n\n```shell\n14+ ms-dns 8.8.8.8\n57  local\n144 #+pap  // 关闭pap\n147 -pap\n151 +chap  // 开启chap\n154 #-chap\n208 proxyarp\n```\n\n3. 编辑 pppoe-server-options文件\n\n创建/etc/ppp/pppoe-server-options文件，使用chap验证协议require-chap，如果使用pap验证协议则配置为 require-pap。\n\n```shell\nauth\nrequire-chap\nlcp-echo-interval 60\nlcp-echo-failure 5     \nlogfile /var/log/pppd.log\n```\n\n3. 编辑/etc/ppp/chap-secrets 文件\n\n```shell\n# Secrets for authentication using CHAP\n# client\tserver\tsecret\t\t\tIP addresses\ntest * test *\n```\n\n用户名为test，密码为test，服务器名和IP地址为任意。\n\n4.  开启IP转发功能\n\n​\t编辑/etc/sysctl.conf文件：\n\n```shell\n28 net.ipv4.ip_forward=1\n```\n\n​\t运行`sudo sysctl -p`生效配置。\n\n5. 启动PPPoE服务器\n\n```shell\nsudo pppoe-server -I ens37 -L 192.168.10.10 -R 192.168.10.11 -N 20   \nsudo pppoe-server -I ens38 -L 192.168.20.10 -R 192.168.20.11 -N 20   \n```\n\n**指令含义：**\n\n| pppoe-server | 启动 PPPoE 服务器进程                        |\n| ------------ | -------------------------------------------- |\n| -I xxx       | 监听物理网卡xxx，接受客户端的 PPPoE 拨号请求 |\n| -L IP地址    | PPP 服务器的 IP 地址                         |\n| -R IP地址    | 客户端分配 IP 的起始地址                     |\n| -N n         | 最多允许 n 个 PPPoE 客户端同时连接           |\n\n6. 查看PPPoE服务器的启用情况\n\n```shell\nps -ef|grep pppoe\n```\n\n![pppoe服务器的启用情况](/images/接入网综合课设/13.png)\n\n- 如果需要关闭PPPoE服务器，指令为：\n\n```shell\nsudo killall pppoe-server\n```\n\n- 每次电脑重启均需要重新运行PPPoE启动命令，设置开机自启动脚本：\n\n  1. 创建systemd服务文件：\n\n     ```shell\n     sudo gedit /etc/systemd/system/pppoe-server.service\n     ```\n\n     ```SHELL\n     [Unit]\n     Description=PPPoE Server Service\n     After=network.target # 等到网络启动后再启动\n     \n     [Service]\n     ExecStart=/usr/local/bin/start-pppoe.sh\n     Restart=always\n     RestartSec=5\n     User=root\n     \n     # 无限制重启\n     StartLimitIntervalSec=0\n     \n     [Install]\n     WantedBy=multi-user.target\n     ```\n\n     ```shell\n     sudo gedit /usr/local/bin/start-pppoe.sh\n     ```\n\n  2. 创建脚本文件：\n\n     ```shell\n     sudo gedit /usr/local/bin/start-pppoe.sh\n     ```\n\n     ```shell\n     #!/bin/bash\n     \n     pppoe-server -I ens37 -L 192.168.10.10 -R 192.168.10.11 -N 20\n     pppoe-server -I ens38 -L 192.168.20.10 -R 192.168.20.11 -N 20\n     \n     # 保持进程运行\n     tail -f /dev/null\n     ```\n\n     赋予执行权限：\n\n     ```shell\n     sudo chmod +x /usr/local/bin/start-pppoe.sh\n     ```\n\n  3. 重新加载配置，重启服务：\n\n     ```shell\n     sudo systemctl daemon-reload\n     sudo systemctl reset-failed\n     sudo systemctl enable pppoe-server\n     sudo systemctl start pppoe-server\n     ```\n\n  4. 重启后检查服务状态：\n\n     ```shell\n     ps -ef|grep pppoe\n     sudo systemctl status pppoe-server\n     ```\n\n     ![重启后的服务状态](/images/接入网综合课设/24.png)\n\n  - 注：如果systemd服务文件中没有添加`StartLimitIntervalSec=0`,脚本文件中没有`tail -f /dev/null`,则有可能报错：\n\n    ```shell\n    sudo systemctl status pppoe-server\n    ● pppoe-server.service - PPPoE Server Service\n         Loaded: loaded (/etc/systemd/system/pppoe-server.service; enabled; vendor>\n         Active: failed (Result: start-limit-hit) since Mon 2025-03-10 00:16:20 CS>\n        Process: 2386 ExecStart=/usr/local/bin/start-pppoe.sh (code=exited, status>\n       Main PID: 2386 (code=exited, status=0/SUCCESS)\n    \n    3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Scheduled>\n    3月 10 00:16:20 xu-virtual-machine systemd[1]: Stopped PPPoE Server Service.\n    3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Start req>\n    3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Failed wi>\n    3月 10 00:16:20 xu-virtual-machine systemd[1]: Failed to start PPPoE Server Se>\n    ```\n\n    失败的原因： `start-limit-hit`，短时间内该服务多次失败，触发了 systemd 的启动限制机制。原脚本`start-pppoe.sh` 脚本执行完后立即退出，systemd 误以为它崩溃并尝试重启，导致触发 `start-limit-hit`。\n\n    \n\n#### PPPoE客户端\n\nWindows端拨号步骤：\n\n1. 选择网络和Internet设置\n\n![选择网络和Internet设置](/images/接入网综合课设/14.png)\n\n2. 选择拨号-设置新连接-连接到Internet-下一页-宽带\n\n![拨号选择](/images/接入网综合课设/15.png)\n\n3. 输入用户名和密码\n\n   ![用户名和密码](/images/接入网综合课设/16.png)\n\n4. 连接成功\n\n![拨号成功](/images/接入网综合课设/17.png)\n\n#### 测试\n\n 客户端连接成功后，在服务器端输入`ifconfig`会看到PPP接口信息\n\n![PPP接口](/images/接入网综合课设/18.png)\n\n在客户端输入`ipconfig /all`  会看到PPP服务器分配的IP地址\n\n**Client1(192.168.10.20)**\n\n![Client1](/images/接入网综合课设/19.png)\n\n**测试ping通：**\n\n![Client1](/images/接入网综合课设/20.png)\n\n**Client2(192.168.20.20)**\n\n![Client2](/images/接入网综合课设/21.png)\n\n测试ping通：\n\n![Client2](/images/接入网综合课设/22.png)\n\n**抓包分析**\n\n**注意**：执行 `sudo wireshark` \n\nFilter 选择pppoe|ppoes。\n\n**PPPoE报文类型**\n\n| 阶段                      | 以太网协议号 | 报文类型                               |\n| ------------------------- | ------------ | -------------------------------------- |\n| **发现阶段**（Discovery） | `0x8863`     | PADI, PADO, PADR, PADS, PADT           |\n| **会话阶段**（Session）   | `0x8864`     | PPP 数据包（LCP、PAP/CHAP、IP 数据等） |\n\n**PPPoE交互过程**\n\n![PPPoE交互过程](/images/接入网综合课设/32.png)\n\n![抓包pppoed](/images/接入网综合课设/25.png)\n\n![抓包pppoes-1](/images/接入网综合课设/26.png)\n\n![抓包pppoes-2](/images/接入网综合课设/27.png)\n\n**PPPoE 发现阶段**\n\nPPPoE 发现阶段用于 建立 PPPoE 连接有5种报文：\n\n1.  PADI（PPPoE Active Discovery Initiation）\n\n- **客户端 → 广播** 发送 **PADI**（发现请求）。\n- 用于查找可用的 PPPoE 服务器（AC, Access Concentrator）。\n- **目标 MAC 地址：`FF:FF:FF:FF:FF:FF`**（广播）。\n- 只有Service-Name为空的服务器会响应。\n\n![抓包pppoed-PADI](/images/接入网综合课设/28.png)\n\n2. PADO（PPPoE Active Discovery Offer）\n\n- **服务器（AC）→ 客户端** 回复 **PADO**（提供服务）。\n- 服务器响应客户端，表明自己可用。\n- 包含 **服务器名称** 和 **支持的服务**。\n\n![抓包pppoed-PADO](./images/接入网综合课设/29.png)\n\n3. PADR（PPPoE Active Discovery Request）\n\n- **客户端 → 服务器（AC）** 发送 **PADR**（连接请求）。\n\n- 用户主机可能会收到多个 PADO，但仅查看它收到的 PADO 数据包并选择一个，并请求建立会话。\n\n- 包含 **服务名** 和 **唯一的标识符**。\n\n  ![抓包pppoed-PADR](/images/接入网综合课设/30.png)\n\n4. PADS（PPPoE Active Discovery Session-confirmation）\n\n- **服务器（AC）→ 客户端** 发送 **PADS**（会话确认）。\n- **分配一个 PPPoE 会话 ID**，表示连接已建立。\n\n![抓包pppoed-PADS](/images/接入网综合课设/31.png)\n\n5. PADT（PPPoE Active Discovery Terminate）\n\n- 客户端或服务器 发送 **PADT**（终止连接）。\n- 关闭 PPPoE 连接。\n\n**PPPoE 会话阶段**\n\nPPPoE 发现阶段完成后，客户端和服务器通过 **PPPoE 会话 ID** 进行通信。\n 此时 PPPoE 封装标准 PPP 报文，包括4种报文：\n\n1. **LCP（Link Control Protocol）**：链路协商。\n2. **PAP/CHAP（Password Authentication Protocol / Challenge Handshake Authentication Protocol）**:  用户身份认证。\n3. **NCP（Network Control Protocol)** : 分配 IP 地址。\n4. **IP 数据报文**: 网络通信数据（TCP/IP、UDP）。\n\n\n\n## 阶段二\n\n1.  设计PPPoE+RADIUS远程接入控制拓扑图及IP地址规划（客户机至少两个网段）。\n2.  选型RADIUS服务器软件，并在虚拟平台下完成PPPOE+RADIUS远程接入认证的搭建、配置、实验测试。\n\n### 任务一\n\n![42](/images/接入网综合课设/42.png)\n\n### 任务二\n\n- RADIUS服务器：FreeRADIUS 3.0.27 （最新stable版本）\n- RADIUS客户端：FreeRADIUS -client-1.1.7\n\n#### 配置Radius服务器及客户端静态IP\n\n```shell\nsudo gedit /etc/netplan/01-network-manager-all.yaml\n```\n\n- **服务器**\n\n```shell\n# Let NetworkManager manage all devices on this system\nnetwork:\n  version: 2\n  renderer: NetworkManager\n  ethernets:\n    ens33:            \n      dhcp4: true                           # 启用 DHCP\n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置\n        \n    ens37:\n      addresses: [192.168.30.2/24]        \n      routes:\n        - to: default\n          via: 192.168.30.1                \n      dhcp4: false                          \n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4] \n```\n\n配置完成后执行命令使配置生效。\n\n```shell\nsudo netplan apply\n```\n\n执行`ifconfig`命令查看当前IP地址\n\n![40](/images/接入网综合课设/40.png)\n\n- **客户端（PPPoE服务器）**\n\n``` shell\n# Let NetworkManager manage all devices on this system\nnetwork:\n  version: 2\n  renderer: NetworkManager\n  ethernets:\n    ens33:            \n      dhcp4: true                           # 启用 DHCP\n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置\n        \n    ens37:\n      addresses: [192.168.10.1/24]           # 静态 IP 地址\n      routes:\n        - to: default\n          via: 192.168.10.1  # 默认网关\n      dhcp4: false                           # 禁用 DHCP\n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置\n        \n    ens38:\n      addresses: [192.168.20.1/24]           # 静态 IP 地址\n      routes:\n        - to: default\n          via: 192.168.20.1  # 默认网关\n      dhcp4: false                           # 禁用 DHCP\n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置\n        \n    ens39:\n      addresses: [192.168.30.1/24]           # 静态 IP 地址\n      routes:\n        - to: default\n          via: 192.168.30.1  # 默认网关\n      dhcp4: false                           # 禁用 DHCP\n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置\n\n      link: ens37\n      addresses:\n        - 192.168.10.129/25\n```\n\n配置完成后执行命令使配置生效。\n\n```shell\nsudo netplan apply\n```\n\n执行`ifconfig`命令查看当前IP地址\n\n![41](/images/接入网综合课设/41.png)\n\n\n\n#### 安装Radius服务器\n\n1. 下载Radius：\n\n   freeradius官方网站：http://freeradius.org/download.html\n\n   freeradius官方文档：\n\n2. 解压：\n\n   ```shell\n   tar -zxvf freeradius-server-3.0.27.tar.gz \n   ```\n\n3. 安装依赖项\n\n   ```shell\n   sudo apt update\n   sudo apt install build-essential -y\n   sudo apt install libtalloc-dev -y\n   sudo apt install libssl-dev -y\n   sudo apt install libhiredis-dev -y\n   sudo apt install freeradius-mysql\n   ```\n\n4. 编译及安装\n\n   ```shell\n   cd  freeradius-server-3.0.26\n   ./configure \n   make\n   sudo make install # 默认安装在 /usr/local/etc/raddb下\n   ```\n\n5. 启动Radius\n\n   ```shell\n   # debug模式启动\n   sudo radiusd -X\n   \n   # 后台进程方式启动\n   systemctl start radiusd\n   systemctl enable radiusd\n   \n   # 日志\n   /var/log/radius/radius.log \n   ```\n\n6. 添加用户\n\n   在 /usr/local/etc/raddb/users 的末尾添加：\n\n   ```shell\n   # test 的用户设置明文密码为 \"test\"\n   # user Cleartext-Password := \"password\"\n   test Cleartext-Password := \"test\"\n   ```\n\n   ```shell \n   # radtest <用户名> <密码> <服务器地址> <端口> <共享密钥>\n   radtest testing password123 127.0.0.1 0 testing123  \n   ```\n\n   本地测试成功\n\n   ![34](/images/接入网综合课设/34.png)\n\n#### 创建数据库\n\n1.安装mariadb\n\n```shell\nsudo apt update\nsudo apt install mariadb-server mariadb-client\nsudo systemctl start mariadb\nsudo systemctl enable mariadb\n```\n\n若此时直接运行安全设置`mysql_secure_installation`，则报错：\n\n```shell\nxu@xu-virtual-machine:~/Desktop$ mysql_secure_installation\n\nNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB\n      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!\n\nIn order to log into MariaDB to secure it, we'll need the current\npassword for the root user.  If you've just installed MariaDB, and\nyou haven't set the root password yet, the password will be blank,\nso you should just press enter here.\n\nEnter current password for root (enter for none): \nERROR 1698 (28000): Access denied for user 'root'@'localhost'\nEnter current password for root (enter for none): \nAborting!\n\nCleaning up...\n```\n\n这是因为 MariaDB 默认使用 **`auth_socket` 插件** 进行身份验证，它不接受通过普通密码登录，只通过 Unix 套接字进行验证。\n\n解决方案：\n\n- 通过root用户登录:\n\n  ``` shell\n  sudo mysql -u root\n  ```\n\n- 禁用 `auth_socket` 插件并设置密码:\n\n  ``` shell\n  sudo mysql\n  USE mysql;\n  SET PASSWORD FOR 'root'@'localhost' = PASSWORD('1');\n  # 刷新权限并退出\n  FLUSH PRIVILEGES;\n  EXIT;\n  ```\n\n​\t运行`mysql_secure_installation`进行安全设置：\n\n<img src=\"/images/接入网综合课设/35.png\" alt=\"35\" style=\"zoom: 80%;\" />\n\n2. 进入数据库\n\n``` sql\n mysql -uroot -p\n```\n\n3. 创建数据库并授权\n\n``` sql\nMariaDB [(none)]> create database radius；\nQuery OK, 1 row affected (0.00 sec)\n\nMariaDB [(none)]> grant all on radius.* to radius@'localhost' identified by 'radius';\nQuery OK, 0 rows affected (0.00 sec)\n\nMariaDB [(none)]> flush privileges;\nQuery OK, 0 rows affected (0.00 sec)\n```\n\n\n\n#### 配置Radius服务器端和数据库\n\n1. 导入数据库\n\n``` shell\ncd /usr/local/etc/raddb/mods-config/sql/main/mysql\nmysql -u radius -p radius< schema.sql\n```\n\n如果报错：\n\n``` shell\nroot@xu-virtual-machine:/usr/local/etc/raddb/mods-config/sql/main/mysql# mysql -u radius -p radius< schema.sql\nEnter password: \nERROR 1045 (28000): Access denied for user 'radius'@'localhost' (using password: YES)\n```\n\n这是因为 MySQL 用户 `radius` 在 `localhost` 上的访问被拒绝，重新设置密码\n\n```sql\nmysql -uroot -p\nALTER USER 'radius'@'localhost' IDENTIFIED BY 'your_password';\nGRANT ALL PRIVILEGES ON radius.* TO 'radius'@'localhost';\nFLUSH PRIVILEGES;\n```\n\n2. 配置Radius\n\n   - 配置default文件\n\n     ```shell\n     sudo -i\n     gedit /usr/local/etc/raddb/sites-enabled/default\n     ```\n\n     使用数据库储存用户信息/计费：\n\n     在538行authenticate {}部分，注释files，解注释sql\n\n     在673行accounting{}部分，解注释 sql\n\n   - 配置sql文件\n\n     ```shell\n     sudo -i\n     gedit /usr/local/etc/raddb/mods-available/sql\n     \n     # 设置文件\n     tls_required = no\n     driver = \"rlm_sql_mysql\"  # 指定 FreeRADIUS 使用 MySQL 数据库作为后端数据库来进行认证和计费\n     dialect = \"mysql\"         # mysql 表示使用 MySQL 数据库的 SQL 方言\n     server = \"localhost\"      # 数据库运行在本地计算机上\n     port = 3306 \n     login = \"radius\"\n     password = \"radius\"\n     radius_db = \"radius\"\n     read_clients = yes         # 允许 FreeRADIUS 从数据库中读取客户端信息                                      、\n     ```\n\n3. 客户端认证设置\n\n```shell\nsudo gedit /usr/local/etc/raddb/clients.conf\n\n# 定义 PPPoE 客户端连接到服务器时需要使用的 IP 地址和密码（共享密钥）\nclient pppoe-server {\n    ipaddr = 192.168.30.1\n    secret = testing123\n}\n```\n\n4. 配置组与用户信息\n\n- 进入radius库\n\n```shell\nsudo mysql -u root -p radius\n```\n\n- 新建组\n\n```shell\ninsert into radgroupcheck (groupname,attribute,op,value) values  ('usr','Auth- Type',':=','Local');\ninsert into radgroupcheck (groupname,attribute,op,value) values ('usr','Service-Type',':=','Framed-User');\ninsert into radgroupcheck (groupname,attribute,op,value) values ('usr','Framed-IP-Address',':=','255.255.255.255');\ninsert into radgroupcheck (groupname,attribute,op,value) values ('usr','Framed-IP-Netmask',':=','255.255.255.0');\n```\n\n查看新建组 `select * from radgroupcheck; `\n\n![36](/images/接入网综合课设/36.png)\n\n可以看到，`usr` 组的认证方式为 **本地认证（Local）**， `Service-Type` 为 Framed-User，即拨号用户，用于 **PPP/PPPoE 认证**。分配给用户的 IP 地址为255.255.255.255，表示 不指定具体 IP 地址，由PPPoE 服务器动态分配。若分配了 IP 地址，默认子网掩码为 `255.255.255.0`。\n\n- 配置 RADIUS 认证用户\n\n  定义 RADIUS 用户，用于身份验证。\n\n```shell\nsudo gedit /usr/local/etc/raddb/users\n\n# 对于 client-1\nuser1 Cleartext-Password := \"test-1\"\n# 对于 client-2\nuser2 Cleartext-Password := \"test-2\"\n```\n\n- 插入用户\n\n```sql\nINSERT INTO radcheck (username, attribute, op, value) VALUES ('user1', 'Cleartext-Password', ':=', 'test-1'); \nINSERT INTO radcheck (username, attribute, op, value) VALUES ('user2', 'Cleartext-Password', ':=', 'test-2'); \n```\n\n查看用户信息 `SELECT * FROM radcheck; `\n\n![37](/images/接入网综合课设/37.png)\n\n- 关联用户和组\n\n```sql\nINSERT INTO radusergroup (username, groupname) VALUES ('user1', 'usr');\nINSERT INTO radusergroup (username, groupname) VALUES ('user2', 'usr');\n```\n\n查看用户和组的关联信息 `SELECT * FROM radusergroup; `\n\n![38](/images/接入网综合课设/38.png)\n\n- 建立软链接\n\n在 FreeRADIUS 服务器的配置目录中启用 SQL 模块\n\n```shell\nsudo -i\ncd /usr/local/etc/raddb/mods-enabled\nln -s /usr/local/etc/raddb/mods-available/sql ./\n```\n\n查看软链接信息 `ls -l /usr/local/etc/raddb/mods-enabled/sql `![39](/images/接入网综合课设/39.png)\n\n- 本地测试用户链接：\n\n```shell\nradtest user1 test-1 127.0.0.1 0 testing123\nradtest user2 test-2 127.0.0.1 0 testing123\n```\n\n![44](/images/接入网综合课设/44.png)\n\n\n\n#### 配置Radius客户端\n\n1. 下载并安装RADIUS -clients\n\n```shell\nwget ftp://ftp.freeradius.org/pub/freeradius/freeradius-client-1.1.7.tar.gz\ntar -xzvf freeradius-client-1.1.7.tar.gz \n\ncd freeradius-client-1.1.7/\n./configure \nsudo make\nsudo make install\n```\n\n2. 在 PPPoE 服务器中启用 RADIUS 认证\n\n​\t在/etc/ppp/pppoe-server-options中增加\n\n```shell\n# 加载 radius.so 插件\nplugin /usr/lib/pppd/2.4.7/radius.so\n# 指定 RADIUS 客户端配置文件\nradius-config-file /usr/local/etc/radiusclient/radiusclient.conf\n```\n\n3. 配置radiusclient.conf文件\n\n```shell\nsudo gedit /usr/local/etc/radiusclient/radiusclient.conf\n```\n\n在文件末尾添加：\n\n```shell\n# 认证顺序：先本地认证，再 RADIUS 远程认证\nauth_order      local,radius\n\n# RADIUS 认证服务器\nauthserver      192.168.30.2:1812\n# RADIUS 计费服务器\nacctserver      192.168.30.2:1813\n\n# RADIUS 共享密钥存放\nservers        /usr/local/etc/radiusclient/servers\n# RADIUS 共享密钥文件\nseqfile        /var/run/radius.seq\n# RADIUS映射文件\nmapfile        /usr/local/etc/radiusclient/port-id-map\ndictionary     /usr/local/etc/radiusclient/dictionary\nlogin_radius   /usr/local/sbin/login.radius\n```\n\n4. 配置 server 文件\n\n```shell\nsudo gedit /usr/local/etc/radiusclient/servers\n```\n\n在文件末尾添加：\n\n```shell\n# [RADIUS服务器IP]  [共享密钥]  [可选参数]\n192.168.30.2 testing123\n```\n\n5. 配置dictionary文件\n\n```shell\nsudo gedit /usr/local/etc/radiusclient/dictionary\n```\n\n在文件末尾添加：\n\n``` shell\nINCLUDE /usr/local/etc/radiusclient/dictionary.sip\nINCLUDE /usr/local/etc/radiusclient/dictionary.ascend\nINCLUDE /usr/local/etc/radiusclient/dictionary.merit\nINCLUDE /usr/local/etc/radiusclient/dictionary.compat\nINCLUDE /usr/local/etc/radiusclient/dictionary.microsoft\n```\n\n\n\n#### 测试\n\n- PPPoE服务器启动情况\n\n  ![43](/images/接入网综合课设/43.png)\n\n- Radius服务器启动情况\n\n![45](/images/接入网综合课设/45.png)\n\n- **Client1**\n\n输入正确用户及密码（user1，test-1），拨号成功\n\n![46](/images/接入网综合课设/46.png)\n\nPPPoE服务器已分配地址：\n\n![47](/images/接入网综合课设/47.png)\n\n上网测试：\n\n![49](/images/接入网综合课设/49.png)\n\n在Radius服务器端本次会话记录:\n\n![50](/images/接入网综合课设/50.png)\n\n输入错误用户及密码（user1，test-2），拨号失败\n\n![51](/images/接入网综合课设/51.png)\n\n在Radius服务器端本次会话记录:\n\n![53](/images/接入网综合课设/53.png)\n\n- **Client2**\n\n输入正确用户密码（user2，test-2），拨号成功\n\n![46](/images/接入网综合课设/46.png)\n\nPPPoE服务器已分配地址：\n\n![48](/images/接入网综合课设/48.png)\n\n上网测试：\n\n![49](/images/接入网综合课设/49.png)\n\n在Radius服务器端本次会话记录:\n\n![52](/images/接入网综合课设/52.png)\n\n输入错误用户及密码（user2，test-1），拨号失败\n\n![51](/images/接入网综合课设/51.png)\n\n![54](/images/接入网综合课设/54.png)\n\n\n\n#### 抓包分析\n\nRADIUS报文格式\n\n![55](/images/接入网综合课设/55.png)\n\nRADIUS 报文类型分为 认证报文 和 计费报文：\n\n**1. 认证报文（Authentication Messages）**\n\n认证报文用于 **用户身份验证**，确保用户合法，并为其分配相应权限。常见类型如下：\n\n| 报文类型             | 代码 | 作用                                                         |\n| -------------------- | ---- | ------------------------------------------------------------ |\n| **Access-Request**   | `1`  | 认证请求，客户端（NAS）向 RADIUS 服务器发送，包含用户名、密码等信息 |\n| **Access-Accept**    | `2`  | 认证通过，RADIUS 服务器返回，NAS 允许用户访问                |\n| **Access-Reject**    | `3`  | 认证失败，RADIUS 服务器拒绝用户访问                          |\n| **Access-Challenge** | `11` | 质询认证，要求客户端提供额外凭证（如 EAP 认证）              |\n\n** 2. 计费报文（Accounting Messages）**\n\n计费报文用于 **记录用户上网时长、流量等信息**，用于后续计费。常见类型如下：\n\n| 报文类型                | 代码 | 作用                                                 |\n| ----------------------- | ---- | ---------------------------------------------------- |\n| **Accounting-Request**  | `4`  | 计费请求，NAS 发送给 RADIUS 服务器，包含用户会话信息 |\n| **Accounting-Response** | `5`  | 计费响应，RADIUS 服务器收到计费信息后确认            |\n\n`Accounting-Request` 又分为：\n\n- **Start**（用户上线）：用户开始上网时发送，记录 `acctstarttime`。\n- **Interim-Update**（状态更新）：定期发送，更新流量、时长等数据。\n- **Stop**（用户下线）：用户断开时发送，记录 `acctstoptime`、`acctsessiontime`、流量。\n\n\n\nRADIUS客户端与服务器交互过程：\n\n![56](/images/接入网综合课设/56.png)\n\n![57](/images/接入网综合课设/57.png)\n\n**Access-Request**：\n\n![58](/images/接入网综合课设/58.png)\n\n**Access-Accept**\n\n![59](/images/接入网综合课设/59.png)\n\n**Access-Reject**\n\n![60](/images/接入网综合课设/60.png)\n\n**Accounting-Request**\n\n![61](/images/接入网综合课设/61.png)\n\n**Accounting-Response**\n\n![62](/images/接入网综合课设/62.png)\n\n\n\n#### 遇到的问题及调试方法\n\n在Radius全面配置好后，windows客户端无法直接拨号，否则显示691错误码，在radius端无信息反馈。推测PPPoE与客户端间传输存在问题。接回PPPoE本地测试可通。\n\n使用`sudo tail -f /var/log/syslog | grep ppp`监听PPPoE服务器信息\n\n当客户端拨号时，报错：\n\n```shell\nApr  3 11:19:13 xu-virtual-machine pppd[2901]: rc_read_dictionary: invalid type on line 92 of dictionary /usr/local/etc/radiusclient/dictionary\nApr  3 11:19:13 xu-virtual-machine pppd[2901]: RADIUS: Can't read dictionary file /usr/local/etc/radiusclient/dictionary\nApr  3 11:19:13 xu-virtual-machine pppd[2901]: Peer user2 failed CHAP authentication\n```\n\n- 把`/usr/local/etc/radiusclient/dictionary`文件中所有`ipv6addr`和`ipv6prdeix`改成`string`\n\n- 下载dictionary.microsoft，只有使用该文件才支持Windows拨号\n\n- 在`/usr/local/etc/radiusclient/dictionary`末尾加上\n\n  ```shell\n  INCLUDE /usr/local/etc/radiusclient/dictionary.sip\n  INCLUDE /usr/local/etc/radiusclient/dictionary.ascend\n  INCLUDE /usr/local/etc/radiusclient/dictionary.merit\n  INCLUDE /usr/local/etc/radiusclient/dictionary.compat\n  INCLUDE /usr/local/etc/radiusclient/dictionary.microsoft\n  ```\n\n  之后再拨号，Radius服务器端显示报错信息，根据具体报错信息修改即可。\n","tags":["网络","课设"]},{"title":"网络算法基础","url":"/2025/02/27/网络算法基础/","content":"\n# 算法与分治\n\nDivide and Conquer（DC）\n\nDivide：将源问题分解为规模较小的子问题，**拆分问题性质相同**，将子问题的解组合成原问题的解。\n\nConquer：如果子问题仍然困难，就继续对子问题进行分解，直到子问题可以被trivial。\n\nRecursion：用递归的方式实现。\n\n## 归并排序\n\n问题定义：\n\n- 输入：n个数构成的数组;\n\n- 输出：排列该n个数的有序数组。\n\nMerg Sort：\n\n- 分解：将原数组等分为两个子数组;\n- 求解：递归地对两个子数组分别排序;\n- 合并：将两个已排序的子数组合并。\n\n### Merge Step\n\n **CLAIM**：对于n ≥ 1的数组，MergeSort需要的运行时间T(n) ≤ $ 6n \\log_2 n + 6n $\n\n![图片](/images/网络算法基础/1.PNG \"证明\")\n\n### 函数增长的渐进符号\n\n**Big O**: 如果存在正数c和N，对于所有的n>=N，有f(n)<=c*g(n)，则f(n)=O(g(n))。\n\n**Big Omega**：如果存在正数c和N，对于所有的n>=N，有f(n)>=c*g(n)，则f(n)=Omega(g(n))。\n\n**Big Theta**：f(n)=Theta(g(n))，当且仅当f(n)=O(g(n))且f(n)=Omega(g(n))。\n\n### 基于比较的排序\n\n**CLAIM**：任何基于比较的排序算法，RT不可能低于O(nlogn)。\n\n任何基于两两比较的排序算法都可以表达为一棵决策树（完全二叉树）。\n\n完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。\n\n![图片](/images/网络算法基础/2.PNG \"决策树的性质\")\n\n### 主办法（Master Method）\n\n**主定理**\n\n![图片](/images/网络算法基础/3.PNG \"主定理的定义\")\n\n![图片](/images/网络算法基础/4.PNG \"主定理的证明\")\n\n![图片](/images/网络算法基础/5.PNG \"参数\")\n\n\n\n# 图简介\n\n## 树\n\n**树**：不包含任何圈的连通图。\n\n**生成树(Spanning Tree)**：如果图G的一个子图包含了G的全部顶点，且为树，则称之为G的生成树。\n\n\n\n## 图搜索\n\n### 循环不变式\n\n- 概念：每次循环开始时都要保持的性质 / 状态。\n- **INVARIANT**：已探索集合和未探索集合应该处于正确的状态。边界点集合应准备好了。\n  - 循环开始时，从边界点集合中选择一个顶点进行探索。\n  - 循环结束前，将新扩展的边界点纳入集合。\n- 维护边界点集合：\n  - **BFS：队列(FIFO)**\n  - **DFS：堆栈(LIFO)**\n\n### BFS\n\nBFS的伪代码：\n\n    BFS(Graph, start):\n    B.EnQueue(s)\n    WHILE B is not empty:\n        d=B.DeQueue();\n        标记d为“已探索”\n        FOR each neighbor t of d:\n            IF t is not in visited:\n                B.EnQueue(t)\n            ENDIF\n        ENDFOR\n    ENDWHILE\n\n**聚合分析复杂度**：O(n+m)\n\n### DFS\n\nDFS的伪代码：\n\n```\nDFS(Graph, start):\nB.Push(s)\nWHILE B is not empty:\n d = B.Pop()\n 标记 d 为“已探索”\n FOR each neighbor t of d:\n  IF t is not in visited:\n   B.Push(t)\n  ENDIF\n ENDFOR\nENDWHILE\n```\n\n**聚合分析复杂度**：O(n+m)\n\n\n\n## 图的连通性\n\n### <u>无向图</u>的连通分量\n\n下述等价关系的等价类：当且仅当图中具有u-v路径时，称u~v。\n\n#### BFS求无向连通分量\n\nBFS求无向连通分量的伪代码：\n\n```\nLoop-BFS(G):\nFOR i=1 to n\n\tIF t is not in visited:\n\t\tBFS(G,i);\nENDFOR\n```\n\n**聚合分析复杂度**：O(n+m)\n\n\n\n### <u>有向图</u>的强连通分量（Strongly Connected Component,SCC）\n\n下述等价关系的等价类：当且仅当有向图G中具有u -> v路径且具有v -> u路径时，称称u~v。\n\n#### TWO-PASS算法(Kosaraju算法)\n\n1. 构建逆图。\n2. **在逆图中进行 Loop-DFS**，记录每个节点的**完成时间** f(v)。\n3. **在原图中运行 Loop-DFS**，按照逆图 DFS 完成的节点顺序进行，确定每个节点的 Leader。\n\n![图片](/images/网络算法基础/6.PNG \"Kosaraju算法-1\")\n\n![图片](/images/网络算法基础/7.PNG \"Kosaraju算法-2\")\n\n**聚合分析复杂度**：O(n+m)\n\n#### **关键引理**\n\nKey Lemma：考虑有向图G中的两个临接SCC，f(v)表示顶点v在反向图G'中Loop-DFS的完成时间，则有：\n$$\n\\max_{v \\in C_1} f(v) < \\max_{v \\in C_2} f(v)\n$$\n推论：最大的f值必然在”sink“SCC中。\n\n\n\n# 贪心MST\n\n## 贪心vs分治\n\n- **决策过程**：\n  - **分治**：每个子问题的解都会考虑整个子问题的情况，逐步拆解，最终合并。\n  - **贪心**：每一步决策只关注当前的局部最优解，不回头。\n- **全局与局部**：\n  - **分治**：每个子问题的解可能涉及整个问题的全局结构。\n  - **贪心**：每一步只考虑局部最优解，期望通过局部最优解得到全局最优解。\n- **解决问题的方式**：\n  - **分治**：递归地分解问题，直到子问题足够简单直接求解。\n  - **贪心**：通过逐步选择当前最优的解来构建最终解。\n- **是否需要回溯**：\n  - **分治**：通常会回溯并合并结果。\n  - **贪心**：不会回溯，一旦做出选择就不再修改。\n\n## MST（前提：无向图）\n\n**定义**：最小权重生成树T。\n\n- 必须是无向图;\n- 生成树的权重定义为树上边权重之和;\n- 生成树定义为E的子集：\n  1. 必须覆盖V;\n  2. 无环;\n  3. 连通。\n\n![图片](/images/网络算法基础/8.PNG \"MST\")\n\n### 割\n\n割的概念：图G(V，E)的一个割(Cut)是V的一个划分，该划分将集合V分为两个非空的集合。\n\n![图片](/images/网络算法基础/9.PNG \"割\")\n\n- n个顶点的图最多有 $ 2^n-2 $ 个不同的割。\n\n**Empty-Cut引理**：图G不连通，当且仅当Cut(A，B)没有割边。\n\n**Double-Crossing Lemma**：如果某个圈C⊆E中有边跨越了Cut(A，B)，则C中**至少还有一条边**跨越Cut(A，B)。\n\n**Lonely-Cut Corollary**：如果边e是跨越了Cut(A，B)的唯一一条边，则e不可能在**任一**圈中。\n\n**The Cut Property**：考虑图G中的一条边e，如果存在Cut(A，B)，使得e是所有跨越该割的所有边中权最小者，则e一定在G的MST中。\n\n割的证明：\n\n![图片](/images/网络算法基础/10.PNG \"割的证明-1\")\n\n![图片](/images/网络算法基础/11.PNG \"割的证明-2\")\n\n\n\n### 堆（Heap）\n\n一个容器，其中元素具有key。\n\n常规操作及对应的RT：\n\n- Heapify：建堆 O(n)\n- Insert：加入一个新的对象 O(logn)\n- Extract-Min：从堆中取出具有最小key的元素 O(logn)\n- Delete：删除指定元素 O(logn)\n\n#### **Heap Property**\n\n- 堆是一颗有根，二叉，尽可能完全的树。\n- 任何节点的key都不大于其所有子代的key。 ——> **根元素具有最小key**\n\n#### **用数组实现堆**\n\n- Parent (i) = i / 2  （下标i为奇数时向下取整）\n- LeftC (i) = 2i\n- RightC (i) = 2i + 1\n\n![图片](/images/网络算法基础/12.PNG \"堆的操作-1\")\n\n![图片](/images/网络算法基础/13.PNG \"堆的操作-2\")\n\n\n\n### **Prime算法**\n\n基本思想：\n\n- 从一个节点开始（任意选择一个节点作为起点），将它加入生成树。\n- 找到当前生成树中所有节点与其他节点之间的边，选择权重最小的边。\n- 将与该边相连的节点加入生成树，更新最小边的权重，重复选择最小边的过程。\n- 直到所有节点都被加入到生成树中。\n\nPim的伪代码：\n\n```\nPrim(Graph, start):\n    初始化最小生成树的边集合 MST = {}\n    初始化一个优先队列 Q，用于存储每个节点及其最小边的权重\n    对于每个节点 v ∈ Graph:\n        设置 v 的最小权重为无穷大（∞）\n    设置 start 节点的最小权重为 0，并将其加入 Q\n\n    WHILE Q is not empty:\n        选择 Q 中最小的权重的节点 u\n        标记 u 为“已加入到最小生成树”\n\n        对于 u 的每个邻居 v:\n            IF v is not in MST AND weight(u, v) < v 的当前权重:\n                更新 v 的最小权重为 weight(u, v)\n                将 v 更新到 Q 中，以反映其新的最小权重\n\n        ENDFOR\n    ENDWHILE\n```\n\nPrim算法的证明：\n\n![图片](/images/网络算法基础/14.PNG \"Prim的证明-1\")\n\n![图片](/images/网络算法基础/15.PNG \"Prim的证明-2\")\n\n用堆实现Prim：\n\n    Prim(Graph, start):\n        初始化最小生成树 MST = {}\n        初始化最小堆 MinHeap\n        初始化一个集合 Visited，用于记录已加入 MST 的节点\n        将 (0, start) 插入 MinHeap  // (边的权重, 节点)\n        初始化 total_weight = 0  // 记录最小生成树的总权重\t\n    \tWHILE MinHeap is not empty:\n        \t(weight, node) = MinHeap.Pop()  // 取出当前权重最小的边\n       \t IF node 已在 Visited:\n        \t    CONTINUE  // 如果该节点已经在 MST 中，跳过\n    \n      \t  标记 node 为已访问\n      \t  total_weight += weight  // 累加权重\n      \t  MST.Add(node)\n    \n    \t    FOR each (neighbor, edge_weight) in Graph[node]:  // 遍历邻居\n         \t   IF neighbor 不在 Visited:\n           \t     MinHeap.Push((edge_weight, neighbor))  // 只加入未访问的节点\n    \n    \tRETURN MST, total_weight\n\n**复杂度分析**：\n\n- n次Extract-Min：O(nlogn)\n- m次Delete和m次Insert：O(mlogn)\n\n总RT = O(nlogn)+O(mlogn) = **O(mlogn)**\n\n\n\n## Kruskal算法\n\n基本思想：\n\n- 按权重升序对边排序。\n- 按序逐条检查边。\n- 只要不成环，就将边加入T。\n\nKruskal的伪代码：\n\n    Kruskal(Graph):\n        初始化最小生成树 MST = {}\n        初始化并查集（Union-Find）来管理连通性\n        按照权重从小到大排序 Graph 的所有边 EdgeList\n    \tFOR (u, v, weight) in EdgeList:  // 遍历排序后的边\n       \t IF u 和 v 不在同一个连通分量 (Find(u) ≠ Find(v)):\n        \t    MST.Add((u, v, weight))  // 加入最小生成树\n      \t      Union(u, v)  // 合并连通分量\n      \t  IF MST 的边数 == V - 1:\n         \t   BREAK  // 最小生成树构建完成\n    \tRETURN MST\n\nKruskal算法的证明：\n\n![图片](/images/网络算法基础/16.PNG \"Kruskal的证明-1\")\n\n![图片](/images/网络算法基础/17.PNG \"Kruskal的证明-2\")\n\n#### UNION-FIND算法\n\nUnion-Find（并查集）是一种高效的数据结构，主要用于**处理动态连通性问题**。它支持两种核心操作：\n\n1. **Find(x)**：查找元素 `x` 所属的集合（返回它的代表元素）。\n2. **Union(x, y)**：合并 `x` 和 `y` 所在的两个集合。\n\n核心思想：\n\n- **每个集合用一棵树表示**，树的根节点作为该集合的**代表元**（代表元素）。\n- **Find(x)** 操作用于查找 `x` 所在集合的代表元（根节点）。\n- **Union(x, y)** 操作用于合并两个集合，**将其中一个集合的根节点指向另一个集合的根**。\n\n\n\n# Dijkstra算法\n\nDijkstra的前提：**无负权图（源点到第一层点的权重可为负值），避免负圈。**\n\nDijkstra的基本思路：\n\n1. 初始化：\n\n- 设 `dist[s] = 0`（起点到自身的距离为 0），其他所有点 `dist[v] = ∞`（起始时认为未知）。\n- 用一个**优先队列（最小堆）**维护当前已发现的最短距离点。\n\n2. 贪心扩展：\n\n- 每次从**未访问的节点中选取当前 `dist[v]` 最小的点 `u`**。\n- 遍历 u的所有邻居 v，尝试松弛：\n  - **如果 `dist[u] + w(u, v) < dist[v]`，更新 `dist[v]`**，并将 `v` 加入优先队列。\n\n3. 终止：所有节点均已访问，或优先队列为空（所有可达点已确定最短路径）。\n\n\n\nDijkstra的伪代码：\n\n```\nDijkstra(Graph, start):\n    初始化 dist[]，所有点设为 ∞，dist[start] = 0\n    初始化优先队列 PQ，插入 (0, start)  // (当前最短距离, 顶点)\n    初始化 visited[] 记录已确定最短路径的点\n\n    WHILE PQ 不为空:\n        (d, u) = PQ.Pop()  // 取出当前最短距离的点\n        IF u 已访问:\n            CONTINUE\n        标记 u 为已访问\n\n        FOR each 邻居 (v, weight) of u:\n            IF dist[u] + weight < dist[v]:  // 进行松弛操作\n                dist[v] = dist[u] + weight\n                PQ.Push((dist[v], v))  // 将 v 加入优先队列\n    \n    RETURN dist[]\n```\n\n## 循环桶\n\n**桶（Bucket）** 是一种数据存储和分类的方法，可以根据某种规则（如哈希值、时间、范围等）**将数据映射到不同的桶中**，以加快查询、存储或计算的效率。\n\n循环桶将数据按照一定规则分配到有限个桶（Bucket）中，并循环使用这些桶。\n\n### 循环桶的核心特点\n\n1. 固定数量的桶（N 个）：\n   - 设定 `N` 个桶，编号从 `0` 到 `N-1`，它们按照顺序**排列成一个循环结构**。\n   - 访问时**基于取模（modulo）运算**，保证访问永远落在 `0 ~ N-1` 之间。\n2. 循环访问（Modulo 取模）：\n   - 计算索引 `index = (当前时间 t) % N`，从而使得时间到了 `N` 之后会回到 `0`，形成循环管理。\n\n### 用循环桶实现Dijkstra算法：\n\n**CLAIM**：Dijkstra算法中最多只需要C+1个桶。\n\n- 永久标记的顶点和非边界顶点不在桶中。\n- 边界点的距离标记不会超过A[i]+C（i为当前标记点）\n- 顶点x的桶的编号：A[x]mod(C+1)\n\n```\nDijkstra_CircularBucket(Graph, start):\n    初始化 dist[]，所有点设为 ∞，dist[start] = 0\n    初始化桶 Bucket[]，桶的数量为 C+1，存储每个距离区间的节点\n    初始化 visited[]，记录顶点是否已被永久标记\n    \n    将起点 start 放入 Bucket[0] 中（dist[start] = 0）\n    \n    WHILE 有节点未被永久标记:\n        从桶中找出具有最小距离的非永久标记的边界点 u\n        标记 u 为永久标记，并从桶中移除 u\n        \n        FOR 每个邻居 v of u:\n            IF v 没有被永久标记:\n                IF dist[u] + w(u, v) < dist[v]:\n                    dist[v] = dist[u] + w(u, v)  // 松弛操作\n                    将 v 放入 Bucket[dist[v] mod (C + 1)] 中  // 根据 dist[v] 放入桶\n                    更新 v 的距离标记\n\n    RETURN dist[]\n```\n\n**复杂度分析**：O(m+nC)\n\n\n\n## Dijsktra算法扩展\n\n### 单源单宿最短路问题\n\n问题描述：给定图G，给定顶点s和d，求从s到d的最小权重路径。\n\n解决方式：增加一个判断分支，d被永久标记时终止循环。\n\n\n\n1111111111111111\n","tags":["图","算法"]},{"title":"about","url":"/about/index.html","content":"\n\n\n![](/images/页面/1.jpg)\n\n# 个人介绍\n\n欢迎来到我的博客。\n\n这里是李双仪，INTJ-A / 一名RCer 。\n偶尔记录一些奇怪的想法，偶尔分享一些折腾的过程，偶尔写一些大学生活指南，可能有趣，也可能只是碎碎念。💬\n\n希望你能在这找到一点点灵感，随时交流，欢迎常来。 🌿\n\n\n\n# 技术栈\n\n- Linux\n- 深度相机\n- 2D/3D雷达\n- 机器人视觉\n- C / C++\n- Python\n- Pytorch\n\n\n\n# 联系方式\n\n- 邮箱：1365895688@qq.com\n- Github：https://github.com/Li-shuangyi\n\n"},{"title":"tags","url":"/tags/index.html"},{"title":"categories","url":"/categories/index.html"}]