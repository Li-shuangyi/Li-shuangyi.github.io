[{"title":"接入网综合课设","url":"/2025/03/10/接入网课设/","content":"\n1. #  接入网综合课设\n\n   ## 阶段一\n\n   1. 完成虚拟机选型，并配置至少两个网段， 分别测试子网内和子网间连通性； \n\n   2. 设计PPPOE本地认证拓扑图及IP地址规划 (客户至少两个网段)  ；\n\n   3. 选型PPPOE服务器软件，并在虚拟环境下 完成PPPoE接入本地认证的搭建、配置、 实验测试。\n\n   ### 任务一\n\n   #### 子网规划\n\n   虚拟机选型：ubuntu20.04\n\n   配置网段：\n\n   - Vmnet1:192.168.10.0/24\n   - Vmnet2:192.168.20.0/24 \n   - Vmnet3:192.168.30.0/24\n\n   ![子网规划](/images/接入网综合课设/1.png)\n\n   #### 配置流程\n\n   1. 在ubuntu编辑-虚拟网络编辑器中选择更改设置，赋予管理员权限后选择添加网络，类型为**仅主机模式**，修改子网IP和子网掩码。\n\n   ![虚拟网络编辑器](/images/接入网综合课设/2.png)\n\n   2. 在ubuntu虚拟机设置中添加网卡，三张为子网规划中定义所对应的网卡。\n\n   ![虚拟机设置](/images/接入网综合课设/3.png)\n\n   ![硬件设置](/images/接入网综合课设/4.png)\n\n   对应网络适配器选择自定义-特定虚拟网络-选择对应网卡-确定。\n\n   ![虚拟机设置](/images/接入网综合课设/5.png)\n\n   3. 在ubuntu中输入\n\n   ```shell\n   ifconfig\n   ```\n\n   出现对应网卡信息。\n\n   ![网卡信息](/images/接入网综合课设/6.png)\n\n   4. 配置静态IP。参考博客：[Ubuntu配置静态IP](https://blog.csdn.net/weixin_58305495/article/details/130554393)，注意与网卡名称匹配。\n\n   **Ubuntu 16.04 及更早版本**：网络管理工具使用 `ifupdown`，网络配置文件在 `/etc/network/interfaces`\n\n   ```shell\n   auto lo\n   iface lo inet loopback\n   \n   auto eth0\n   iface eth0 inet dhcp\n   \n   auto eth1\n   iface eth1 inet static\n   address 192.168.10.10\n   netmask 255.255.255.0\n   gateway 192.168.10.1\n   dns-nameservers 8.8.8.8 8.8.4.4\n   \n   auto eth2\n   iface eth2 inet static\n   address 192.168.20.10\n   netmask 255.255.255.0\n   gateway 192.168.20.1\n   \n   auto eth3\n   iface eth3 inet static\n   address 192.168.30.10\n   netmask 255.255.255.0\n   gateway 192.168.30.1\n   \n   ```\n\n   **Ubuntu 17.10 及更高版本**：网络管理工具使用 `Netplan`，配置文件位于 `/etc/netplan/00-installer-config.yaml`\n\n   ```yaml\n   # Let NetworkManager manage all devices on this system\n   network:\n     version: 2\n     renderer: NetworkManager\n     ethernets:\n       ens33:            \n         dhcp4: true                          \n         nameservers:\n           addresses: [8.8.8.8, 8.8.4.4]       \n   \n       ens37:\n         addresses: [192.168.10.10/24]        \n         routes:\n           - to: default\n             via: 192.168.10.1                \n         dhcp4: false                          \n         nameservers:\n           addresses: [8.8.8.8, 8.8.4.4]      \n   \n       ens38:\n         addresses: [192.168.20.10/24]         \n         routes:\n           - to: default\n             via: 192.168.20.1                \n         dhcp4: false                          \n         nameservers:\n           addresses: [8.8.8.8, 8.8.4.4]   \n   \n       ens39:\n         addresses: [192.168.30.10/24]        \n         routes:\n           - to: default\n             via: 192.168.30.1              \n         dhcp4: false                     \n         nameservers:\n           addresses: [8.8.8.8, 8.8.4.4]   \n   ```\n\n   配置完成后执行命令使配置生效。\n\n   ```shell\n   sudo netplan apply\n   ```\n\n   执行`ifconfig`命令查看当前IP地址。\n\n   \n\n   ####  测试\n\n   **子网间连通性**\n\n   ![Linux子网间连通性](/images/接入网综合课设/7.png)\n\n   Client1(192.168.10.20)\n\n   ![Client1子网间连通性](/images/接入网综合课设/8.png)\n\n   Client2(192.168.20.20)\n\n   <img src=\"/images/接入网综合课设/9.png\" alt=\"image-20250308132954522\" style=\"zoom: 80%;\" />\n\n   **子网内连通性**\n\n   Client1(192.168.10.20)\n\n   ![Client1子网内连通性](/images/接入网综合课设/10.png)\n\n   Client2(192.168.20.20)\n\n   <img src=\"/images/接入网综合课设/11.png\" alt=\"image-20250308133215681\" style=\"zoom:80%;\" />\n\n   ### 任务三\n\n   #### PPPoE服务器端\n\n   [参考博客:基于Linux环境的PPPOE服务器搭建](https://zhuanlan.zhihu.com/p/41499761)\n\n   1. 安装PPPoE服务器程序\n\n   ```shell\n   sudo apt-get install pppoe\n   ```\n\n   使用`pppoe-server -h`查看pppoe安装情况及版本,该PPPoE-Server版本为3.12。\n\n   ![PPPoE服务器版本](/images/接入网综合课设/12.png)\n\n   2. 编辑/etc/ppp/options文件\n\n   - PAP：明文密码认证协议。\n   - CHAP：挑战握手认证协议，**三次握手**机制，使用哈希加密。\n\n   ```shell\n   14+ ms-dns 8.8.8.8\n   57  local\n   144 #+pap  // 关闭pap\n   147 -pap\n   151 +chap  // 开启chap\n   154 #-chap\n   208 proxyarp\n   ```\n\n   3. 编辑 pppoe-server-options文件\n\n   创建/etc/ppp/pppoe-server-options文件，使用chap验证协议require-chap，如果使用pap验证协议则配置为 require-pap。\n\n   ```shell\n   auth\n   require-chap\n   lcp-echo-interval 60\n   lcp-echo-failure 5     \n   logfile /var/log/pppd.log\n   ```\n\n   3. 编辑/etc/ppp/chap-secrets 文件\n\n   ```shell\n   # Secrets for authentication using CHAP\n   # client\tserver\tsecret\t\t\tIP addresses\n   test * test *\n   ```\n\n   用户名为test，密码为test，服务器名和IP地址为任意。\n\n   4.  开启IP转发功能\n\n   ​\t编辑/etc/sysctl.conf文件：\n\n   ```shell\n   28 net.ipv4.ip_forward=1\n   ```\n\n   ​\t运行`sudo sysctl -p`生效配置。\n\n   5. 启动PPPoE服务器\n\n   ```shell\n   sudo pppoe-server -I ens37 -L 192.168.10.10 -R 192.168.10.11 -N 20   \n   sudo pppoe-server -I ens38 -L 192.168.20.10 -R 192.168.20.11 -N 20   \n   ```\n\n   **指令含义：**\n\n   | pppoe-server | 启动 PPPoE 服务器进程                        |\n   | ------------ | -------------------------------------------- |\n   | -I xxx       | 监听物理网卡xxx，接受客户端的 PPPoE 拨号请求 |\n   | -L IP地址    | PPP 服务器的 IP 地址                         |\n   | -R IP地址    | 客户端分配 IP 的起始地址                     |\n   | -N n         | 最多允许 n 个 PPPoE 客户端同时连接           |\n\n   6. 查看PPPoE服务器的启用情况\n\n   ```shell\n   ps -ef|grep pppoe\n   ```\n\n   ![pppoe服务器的启用情况](/images/接入网综合课设/13.png)\n\n   - 如果需要关闭PPPoE服务器，指令为：\n\n   ```shell\n   sudo killall pppoe-server\n   ```\n\n   - 每次电脑重启均需要重新运行PPPoE启动命令，设置开机自启动脚本：\n\n     1. 创建systemd服务文件：\n\n        ```shell\n        sudo gedit /etc/systemd/system/pppoe-server.service\n        ```\n\n        ```SHELL\n        [Unit]\n        Description=PPPoE Server Service\n        After=network.target # 等到网络启动后再启动\n        \n        [Service]\n        ExecStart=/usr/local/bin/start-pppoe.sh\n        Restart=always\n        RestartSec=5\n        User=root\n        \n        # 无限制重启\n        StartLimitIntervalSec=0\n        \n        [Install]\n        WantedBy=multi-user.target\n        ```\n\n        ```shell\n        sudo gedit /usr/local/bin/start-pppoe.sh\n        ```\n\n     2. 创建脚本文件：\n\n        ```shell\n        sudo gedit /usr/local/bin/start-pppoe.sh\n        ```\n\n        ```shell\n        #!/bin/bash\n        \n        pppoe-server -I ens37 -L 192.168.10.10 -R 192.168.10.11 -N 20\n        pppoe-server -I ens38 -L 192.168.20.10 -R 192.168.20.11 -N 20\n        \n        # 保持进程运行\n        tail -f /dev/null\n        ```\n\n        赋予执行权限：\n\n        ```shell\n        sudo chmod +x /usr/local/bin/start-pppoe.sh\n        ```\n\n     3. 重新加载配置，重启服务：\n\n        ```shell\n        sudo systemctl daemon-reload\n        sudo systemctl reset-failed\n        sudo systemctl enable pppoe-server\n        sudo systemctl start pppoe-server\n        ```\n\n     4. 重启后检查服务状态：\n\n        ```shell\n        ps -ef|grep pppoe\n        sudo systemctl status pppoe-server\n        ```\n\n        ![重启后的服务状态](/images/接入网综合课设/24.png)\n\n     - 注：如果systemd服务文件中没有添加`StartLimitIntervalSec=0`,脚本文件中没有`tail -f /dev/null`,则有可能报错：\n\n       ```shell\n       sudo systemctl status pppoe-server\n       ● pppoe-server.service - PPPoE Server Service\n            Loaded: loaded (/etc/systemd/system/pppoe-server.service; enabled; vendor>\n            Active: failed (Result: start-limit-hit) since Mon 2025-03-10 00:16:20 CS>\n           Process: 2386 ExecStart=/usr/local/bin/start-pppoe.sh (code=exited, status>\n          Main PID: 2386 (code=exited, status=0/SUCCESS)\n       \n       3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Scheduled>\n       3月 10 00:16:20 xu-virtual-machine systemd[1]: Stopped PPPoE Server Service.\n       3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Start req>\n       3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Failed wi>\n       3月 10 00:16:20 xu-virtual-machine systemd[1]: Failed to start PPPoE Server Se>\n       ```\n\n       失败的原因： `start-limit-hit`，短时间内该服务多次失败，触发了 systemd 的启动限制机制。原脚本`start-pppoe.sh` 脚本执行完后立即退出，systemd 误以为它崩溃并尝试重启，导致触发 `start-limit-hit`。\n\n       \n\n   #### PPPoE客户端\n\n   Windows端拨号步骤：\n\n   1. 选择网络和Internet设置\n\n   ![选择网络和Internet设置](/images/接入网综合课设/14.png)\n\n   2. 选择拨号-设置新连接-连接到Internet-下一页-宽带\n\n   ![拨号选择](/images/接入网综合课设/15.png)\n\n   3. 输入用户名和密码\n\n      ![用户名和密码](/images/接入网综合课设/16.png)\n\n   4. 连接成功\n\n   ![拨号成功](/images/接入网综合课设/17.png)\n\n   #### 测试\n\n    客户端连接成功后，在服务器端输入`ifconfig`会看到PPP接口信息\n\n   ![PPP接口](/images/接入网综合课设/18.png)\n\n   在客户端输入`ipconfig /all`  会看到PPP服务器分配的IP地址\n\n   **Client1(192.168.10.20)**\n\n   ![Client1](/images/接入网综合课设/19.png)\n\n   **测试ping通：**\n\n   ![Client1](/images/接入网综合课设/20.png)\n\n   **Client2(192.168.20.20)**\n\n   ![Client2](/images/接入网综合课设/21.png)\n\n   测试ping通：\n\n   ![Client2](/images/接入网综合课设/22.png)\n\n   **抓包分析**\n\n   **注意**：执行 `sudo wireshark` \n\n   Filter 选择pppoe|ppoes。\n\n   **PPPoE报文类型**\n\n   | 阶段                      | 以太网协议号 | 报文类型                               |\n   | ------------------------- | ------------ | -------------------------------------- |\n   | **发现阶段**（Discovery） | `0x8863`     | PADI, PADO, PADR, PADS, PADT           |\n   | **会话阶段**（Session）   | `0x8864`     | PPP 数据包（LCP、PAP/CHAP、IP 数据等） |\n\n   **PPPoE交互过程**\n\n   ![PPPoE交互过程](/images/接入网综合课设/32.png)\n\n   ![抓包pppoed](/images/接入网综合课设/25.png)\n\n   ![抓包pppoes-1](/images/接入网综合课设/26.png)\n\n   ![抓包pppoes-2](/images/接入网综合课设/27.png)\n\n   **PPPoE 发现阶段**\n\n   PPPoE 发现阶段用于 建立 PPPoE 连接有5种报文：\n\n   1.  PADI（PPPoE Active Discovery Initiation）\n\n   - **客户端 → 广播** 发送 **PADI**（发现请求）。\n   - 用于查找可用的 PPPoE 服务器（AC, Access Concentrator）。\n   - **目标 MAC 地址：`FF:FF:FF:FF:FF:FF`**（广播）。\n   - 只有Service-Name为空的服务器会响应。\n\n   ![抓包pppoed-PADI](/images/接入网综合课设/28.png)\n\n   2. PADO（PPPoE Active Discovery Offer）\n\n   - **服务器（AC）→ 客户端** 回复 **PADO**（提供服务）。\n   - 服务器响应客户端，表明自己可用。\n   - 包含 **服务器名称** 和 **支持的服务**。\n\n   ![抓包pppoed-PADO](./images/接入网综合课设/29.png)\n\n   3. PADR（PPPoE Active Discovery Request）\n\n   - **客户端 → 服务器（AC）** 发送 **PADR**（连接请求）。\n\n   - 用户主机可能会收到多个 PADO，但仅查看它收到的 PADO 数据包并选择一个，并请求建立会话。\n\n   - 包含 **服务名** 和 **唯一的标识符**。\n\n     ![抓包pppoed-PADR](/images/接入网综合课设/30.png)\n\n   4. PADS（PPPoE Active Discovery Session-confirmation）\n\n   - **服务器（AC）→ 客户端** 发送 **PADS**（会话确认）。\n   - **分配一个 PPPoE 会话 ID**，表示连接已建立。\n\n   ![抓包pppoed-PADS](/images/接入网综合课设/31.png)\n\n   5. PADT（PPPoE Active Discovery Terminate）\n\n   - 客户端或服务器 发送 **PADT**（终止连接）。\n   - 关闭 PPPoE 连接。\n\n   **PPPoE 会话阶段**\n\n   PPPoE 发现阶段完成后，客户端和服务器通过 **PPPoE 会话 ID** 进行通信。\n    此时 PPPoE 封装标准 PPP 报文，包括4种报文：\n\n   1. **LCP（Link Control Protocol）**：链路协商。\n   2. **PAP/CHAP（Password Authentication Protocol / Challenge Handshake Authentication Protocol）**:  用户身份认证。\n   3. **NCP（Network Control Protocol)** : 分配 IP 地址。\n   4. **IP 数据报文**: 网络通信数据（TCP/IP、UDP）。\n","tags":["网络","课设"]},{"title":"网络算法基础","url":"/2025/02/27/网络算法基础/","content":"\n# 算法与分治\n\nDivide and Conquer（DC）\n\nDivide：将源问题分解为规模较小的子问题，**拆分问题性质相同**，将子问题的解组合成原问题的解。\n\nConquer：如果子问题仍然困难，就继续对子问题进行分解，直到子问题可以被trivial。\n\nRecursion：用递归的方式实现。\n\n## 归并排序\n\n问题定义：\n\n- 输入：n个数构成的数组;\n\n- 输出：排列该n个数的有序数组。\n\nMerg Sort：\n\n- 分解：将原数组等分为两个子数组;\n- 求解：递归地对两个子数组分别排序;\n- 合并：将两个已排序的子数组合并。\n\n### Merge Step\n\n **CLAIM**：对于n ≥ 1的数组，MergeSort需要的运行时间T(n) ≤ $ 6n \\log_2 n + 6n $\n\n![图片](/images/网络算法基础/1.PNG \"证明\")\n\n### 函数增长的渐进符号\n\n**Big O**: 如果存在正数c和N，对于所有的n>=N，有f(n)<=c*g(n)，则f(n)=O(g(n))。\n\n**Big Omega**：如果存在正数c和N，对于所有的n>=N，有f(n)>=c*g(n)，则f(n)=Omega(g(n))。\n\n**Big Theta**：f(n)=Theta(g(n))，当且仅当f(n)=O(g(n))且f(n)=Omega(g(n))。\n\n### 基于比较的排序\n\n**CLAIM**：任何基于比较的排序算法，RT不可能低于O(nlogn)。\n\n任何基于两两比较的排序算法都可以表达为一棵决策树（完全二叉树）。\n\n完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。\n\n![图片](/images/网络算法基础/2.PNG \"决策树的性质\")\n\n### 主办法（Master Method）\n\n**主定理**\n\n![图片](/images/网络算法基础/3.PNG \"主定理的定义\")\n\n![图片](/images/网络算法基础/4.PNG \"主定理的证明\")\n\n![图片](/images/网络算法基础/5.PNG \"参数\")\n\n\n\n# 图简介\n\n## 树\n\n**树**：不包含任何圈的连通图。\n\n**生成树(Spanning Tree)**：如果图G的一个子图包含了G的全部顶点，且为树，则称之为G的生成树。\n\n\n\n## 图搜索\n\n### 循环不变式\n\n- 概念：每次循环开始时都要保持的性质 / 状态。\n- **INVARIANT**：已探索集合和未探索集合应该处于正确的状态。边界点集合应准备好了。\n  - 循环开始时，从边界点集合中选择一个顶点进行探索。\n  - 循环结束前，将新扩展的边界点纳入集合。\n- 维护边界点集合：\n  - **BFS：队列(FIFO)**\n  - **DFS：堆栈(LIFO)**\n\n### BFS\n\nBFS的伪代码：\n\n    BFS(Graph, start):\n    B.EnQueue(s)\n    WHILE B is not empty:\n        d=B.DeQueue();\n        标记d为“已探索”\n        FOR each neighbor t of d:\n            IF t is not in visited:\n                B.EnQueue(t)\n            ENDIF\n        ENDFOR\n    ENDWHILE\n\n**聚合分析复杂度**：O(n+m)\n\n### DFS\n\nDFS的伪代码：\n\n```\nDFS(Graph, start):\nB.Push(s)\nWHILE B is not empty:\n d = B.Pop()\n 标记 d 为“已探索”\n FOR each neighbor t of d:\n  IF t is not in visited:\n   B.Push(t)\n  ENDIF\n ENDFOR\nENDWHILE\n```\n\n**聚合分析复杂度**：O(n+m)\n\n\n\n## 图的连通性\n\n### <u>无向图</u>的连通分量\n\n下述等价关系的等价类：当且仅当图中具有u-v路径时，称u~v。\n\n#### BFS求无向连通分量\n\nBFS求无向连通分量的伪代码：\n\n```\nLoop-BFS(G):\nFOR i=1 to n\n\tIF t is not in visited:\n\t\tBFS(G,i);\nENDFOR\n```\n\n**聚合分析复杂度**：O(n+m)\n\n\n\n### <u>有向图</u>的强连通分量（Strongly Connected Component,SCC）\n\n下述等价关系的等价类：当且仅当有向图G中具有u -> v路径且具有v -> u路径时，称称u~v。\n\n#### TWO-PASS算法(Kosaraju算法)\n\n1. 构建逆图。\n2. **在逆图中进行 Loop-DFS**，记录每个节点的**完成时间** f(v)。\n3. **在原图中运行 Loop-DFS**，按照逆图 DFS 完成的节点顺序进行，确定每个节点的 Leader。\n\n![图片](/images/网络算法基础/6.PNG \"Kosaraju算法-1\")\n\n![图片](/images/网络算法基础/7.PNG \"Kosaraju算法-2\")\n\n**聚合分析复杂度**：O(n+m)\n\n#### **关键引理**\n\nKey Lemma：考虑有向图G中的两个临接SCC，f(v)表示顶点v在反向图G'中Loop-DFS的完成时间，则有：\n$$\n\\max_{v \\in C_1} f(v) < \\max_{v \\in C_2} f(v)\n$$\n推论：最大的f值必然在”sink“SCC中。\n\n\n\n# 贪心MST\n\n## 贪心vs分治\n\n- **决策过程**：\n  - **分治**：每个子问题的解都会考虑整个子问题的情况，逐步拆解，最终合并。\n  - **贪心**：每一步决策只关注当前的局部最优解，不回头。\n- **全局与局部**：\n  - **分治**：每个子问题的解可能涉及整个问题的全局结构。\n  - **贪心**：每一步只考虑局部最优解，期望通过局部最优解得到全局最优解。\n- **解决问题的方式**：\n  - **分治**：递归地分解问题，直到子问题足够简单直接求解。\n  - **贪心**：通过逐步选择当前最优的解来构建最终解。\n- **是否需要回溯**：\n  - **分治**：通常会回溯并合并结果。\n  - **贪心**：不会回溯，一旦做出选择就不再修改。\n\n## MST（前提：无向图）\n\n**定义**：最小权重生成树T。\n\n- 必须是无向图;\n- 生成树的权重定义为树上边权重之和;\n- 生成树定义为E的子集：\n  1. 必须覆盖V;\n  2. 无环;\n  3. 连通。\n\n![图片](/images/网络算法基础/8.PNG \"MST\")\n\n### 割\n\n割的概念：图G(V，E)的一个割(Cut)是V的一个划分，该划分将集合V分为两个非空的集合。\n\n![图片](/images/网络算法基础/9.PNG \"割\")\n\n- n个顶点的图最多有 $ 2^n-2 $ 个不同的割。\n\n**Empty-Cut引理**：图G不连通，当且仅当Cut(A，B)没有割边。\n\n**Double-Crossing Lemma**：如果某个圈C⊆E中有边跨越了Cut(A，B)，则C中**至少还有一条边**跨越Cut(A，B)。\n\n**Lonely-Cut Corollary**：如果边e是跨越了Cut(A，B)的唯一一条边，则e不可能在**任一**圈中。\n\n**The Cut Property**：考虑图G中的一条边e，如果存在Cut(A，B)，使得e是所有跨越该割的所有边中权最小者，则e一定在G的MST中。\n\n割的证明：\n\n![图片](/images/网络算法基础/10.PNG \"割的证明-1\")\n\n![图片](/images/网络算法基础/11.PNG \"割的证明-2\")\n\n\n\n### 堆（Heap）\n\n一个容器，其中元素具有key。\n\n常规操作及对应的RT：\n\n- Heapify：建堆 O(n)\n- Insert：加入一个新的对象 O(logn)\n- Extract-Min：从堆中取出具有最小key的元素 O(logn)\n- Delete：删除指定元素 O(logn)\n\n#### **Heap Property**\n\n- 堆是一颗有根，二叉，尽可能完全的树。\n- 任何节点的key都不大于其所有子代的key。 ——> **根元素具有最小key**\n\n#### **用数组实现堆**\n\n- Parent (i) = i / 2  （下标i为奇数时向下取整）\n- LeftC (i) = 2i\n- RightC (i) = 2i + 1\n\n![图片](/images/网络算法基础/12.PNG \"堆的操作-1\")\n\n![图片](/images/网络算法基础/13.PNG \"堆的操作-2\")\n\n\n\n### **Prime算法**\n\n基本思想：\n\n- 从一个节点开始（任意选择一个节点作为起点），将它加入生成树。\n- 找到当前生成树中所有节点与其他节点之间的边，选择权重最小的边。\n- 将与该边相连的节点加入生成树，更新最小边的权重，重复选择最小边的过程。\n- 直到所有节点都被加入到生成树中。\n\nPim的伪代码：\n\n```\nPrim(Graph, start):\n    初始化最小生成树的边集合 MST = {}\n    初始化一个优先队列 Q，用于存储每个节点及其最小边的权重\n    对于每个节点 v ∈ Graph:\n        设置 v 的最小权重为无穷大（∞）\n    设置 start 节点的最小权重为 0，并将其加入 Q\n\n    WHILE Q is not empty:\n        选择 Q 中最小的权重的节点 u\n        标记 u 为“已加入到最小生成树”\n\n        对于 u 的每个邻居 v:\n            IF v is not in MST AND weight(u, v) < v 的当前权重:\n                更新 v 的最小权重为 weight(u, v)\n                将 v 更新到 Q 中，以反映其新的最小权重\n\n        ENDFOR\n    ENDWHILE\n```\n\nPrim算法的证明：\n\n![图片](/images/网络算法基础/14.PNG \"Prim的证明-1\")\n\n![图片](/images/网络算法基础/15.PNG \"Prim的证明-2\")\n\n用堆实现Prim：\n\n    Prim(Graph, start):\n        初始化最小生成树 MST = {}\n        初始化最小堆 MinHeap\n        初始化一个集合 Visited，用于记录已加入 MST 的节点\n        将 (0, start) 插入 MinHeap  // (边的权重, 节点)\n        初始化 total_weight = 0  // 记录最小生成树的总权重\t\n    \tWHILE MinHeap is not empty:\n        \t(weight, node) = MinHeap.Pop()  // 取出当前权重最小的边\n       \t IF node 已在 Visited:\n        \t    CONTINUE  // 如果该节点已经在 MST 中，跳过\n    \n      \t  标记 node 为已访问\n      \t  total_weight += weight  // 累加权重\n      \t  MST.Add(node)\n    \n    \t    FOR each (neighbor, edge_weight) in Graph[node]:  // 遍历邻居\n         \t   IF neighbor 不在 Visited:\n           \t     MinHeap.Push((edge_weight, neighbor))  // 只加入未访问的节点\n    \n    \tRETURN MST, total_weight\n\n**复杂度分析**：\n\n- n次Extract-Min：O(nlogn)\n- m次Delete和m次Insert：O(mlogn)\n\n总RT = O(nlogn)+O(mlogn) = **O(mlogn)**\n\n\n\n## Kruskal算法\n\n基本思想：\n\n- 按权重升序对边排序。\n- 按序逐条检查边。\n- 只要不成环，就将边加入T。\n\nKruskal的伪代码：\n\n    Kruskal(Graph):\n        初始化最小生成树 MST = {}\n        初始化并查集（Union-Find）来管理连通性\n        按照权重从小到大排序 Graph 的所有边 EdgeList\n    \tFOR (u, v, weight) in EdgeList:  // 遍历排序后的边\n       \t IF u 和 v 不在同一个连通分量 (Find(u) ≠ Find(v)):\n        \t    MST.Add((u, v, weight))  // 加入最小生成树\n      \t      Union(u, v)  // 合并连通分量\n      \t  IF MST 的边数 == V - 1:\n         \t   BREAK  // 最小生成树构建完成\n    \tRETURN MST\n\nKruskal算法的证明：\n\n![图片](/images/网络算法基础/16.PNG \"Kruskal的证明-1\")\n\n![图片](/images/网络算法基础/17.PNG \"Kruskal的证明-2\")\n\n#### UNION-FIND算法\n\nUnion-Find（并查集）是一种高效的数据结构，主要用于**处理动态连通性问题**。它支持两种核心操作：\n\n1. **Find(x)**：查找元素 `x` 所属的集合（返回它的代表元素）。\n2. **Union(x, y)**：合并 `x` 和 `y` 所在的两个集合。\n\n核心思想：\n\n- **每个集合用一棵树表示**，树的根节点作为该集合的**代表元**（代表元素）。\n- **Find(x)** 操作用于查找 `x` 所在集合的代表元（根节点）。\n- **Union(x, y)** 操作用于合并两个集合，**将其中一个集合的根节点指向另一个集合的根**。\n\n\n\n# Dijkstra算法\n\nDijkstra的前提：**无负权图（源点到第一层点的权重可为负值），避免负圈。**\n\nDijkstra的基本思路：\n\n1. 初始化：\n\n- 设 `dist[s] = 0`（起点到自身的距离为 0），其他所有点 `dist[v] = ∞`（起始时认为未知）。\n- 用一个**优先队列（最小堆）**维护当前已发现的最短距离点。\n\n2. 贪心扩展：\n\n- 每次从**未访问的节点中选取当前 `dist[v]` 最小的点 `u`**。\n- 遍历 u的所有邻居 v，尝试松弛：\n  - **如果 `dist[u] + w(u, v) < dist[v]`，更新 `dist[v]`**，并将 `v` 加入优先队列。\n\n3. 终止：所有节点均已访问，或优先队列为空（所有可达点已确定最短路径）。\n\n\n\nDijkstra的伪代码：\n\n```\nDijkstra(Graph, start):\n    初始化 dist[]，所有点设为 ∞，dist[start] = 0\n    初始化优先队列 PQ，插入 (0, start)  // (当前最短距离, 顶点)\n    初始化 visited[] 记录已确定最短路径的点\n\n    WHILE PQ 不为空:\n        (d, u) = PQ.Pop()  // 取出当前最短距离的点\n        IF u 已访问:\n            CONTINUE\n        标记 u 为已访问\n\n        FOR each 邻居 (v, weight) of u:\n            IF dist[u] + weight < dist[v]:  // 进行松弛操作\n                dist[v] = dist[u] + weight\n                PQ.Push((dist[v], v))  // 将 v 加入优先队列\n    \n    RETURN dist[]\n```\n\n## 循环桶\n\n**桶（Bucket）** 是一种数据存储和分类的方法，可以根据某种规则（如哈希值、时间、范围等）**将数据映射到不同的桶中**，以加快查询、存储或计算的效率。\n\n循环桶将数据按照一定规则分配到有限个桶（Bucket）中，并循环使用这些桶。\n\n### 循环桶的核心特点\n\n1. 固定数量的桶（N 个）：\n   - 设定 `N` 个桶，编号从 `0` 到 `N-1`，它们按照顺序**排列成一个循环结构**。\n   - 访问时**基于取模（modulo）运算**，保证访问永远落在 `0 ~ N-1` 之间。\n2. 循环访问（Modulo 取模）：\n   - 计算索引 `index = (当前时间 t) % N`，从而使得时间到了 `N` 之后会回到 `0`，形成循环管理。\n\n### 用循环桶实现Dijkstra算法：\n\n**CLAIM**：Dijkstra算法中最多只需要C+1个桶。\n\n- 永久标记的顶点和非边界顶点不在桶中。\n- 边界点的距离标记不会超过A[i]+C（i为当前标记点）\n- 顶点x的桶的编号：A[x]mod(C+1)\n\n```\nDijkstra_CircularBucket(Graph, start):\n    初始化 dist[]，所有点设为 ∞，dist[start] = 0\n    初始化桶 Bucket[]，桶的数量为 C+1，存储每个距离区间的节点\n    初始化 visited[]，记录顶点是否已被永久标记\n    \n    将起点 start 放入 Bucket[0] 中（dist[start] = 0）\n    \n    WHILE 有节点未被永久标记:\n        从桶中找出具有最小距离的非永久标记的边界点 u\n        标记 u 为永久标记，并从桶中移除 u\n        \n        FOR 每个邻居 v of u:\n            IF v 没有被永久标记:\n                IF dist[u] + w(u, v) < dist[v]:\n                    dist[v] = dist[u] + w(u, v)  // 松弛操作\n                    将 v 放入 Bucket[dist[v] mod (C + 1)] 中  // 根据 dist[v] 放入桶\n                    更新 v 的距离标记\n\n    RETURN dist[]\n```\n\n**复杂度分析**：O(m+nC)\n\n\n\n## Dijsktra算法扩展\n\n### 单源单宿最短路问题\n\n问题描述：给定图G，给定顶点s和d，求从s到d的最小权重路径。\n\n解决方式：增加一个判断分支，d被永久标记时终止循环。\n","tags":["图","算法"]},{"url":"/categories/index.html","content":"---\n​---\ntitle:categories\nlayout:categories\n​---\n---\n"},{"url":"/about/index.html","content":"---\n​---\ntitle:about\nlayout:about\n​---\n---\n"},{"url":"/tags/index.html","content":"---\n​---\ntitle:tags\nlayout:tags\n​---\n---\n"}]