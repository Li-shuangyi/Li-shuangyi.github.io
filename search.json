[{"title":"网络算法基础","url":"/2025/02/27/网络算法基础/","content":"\n# 算法与分治\n\nDivide and Conquer（DC）\n\nDivide：将源问题分解为规模较小的子问题，**拆分问题性质相同**，将子问题的解组合成原问题的解。\n\nConquer：如果子问题仍然困难，就继续对子问题进行分解，直到子问题可以被trivial。\n\nRecursion：用递归的方式实现。\n\n## 归并排序\n\n问题定义：\n\n- 输入：n个数构成的数组;\n\n- 输出：排列该n个数的有序数组。\n\nMerg Sort：\n\n- 分解：将原数组等分为两个子数组;\n- 求解：递归地对两个子数组分别排序;\n- 合并：将两个已排序的子数组合并。\n\n### Merge Step\n\n **CLAIM**：对于n ≥ 1的数组，MergeSort需要的运行时间T(n) ≤ $ 6n \\log_2 n + 6n $\n\n![图片](/images/网络算法基础/1.PNG \"证明\")\n\n### 函数增长的渐进符号\n\n**Big O**: 如果存在正数c和N，对于所有的n>=N，有f(n)<=c*g(n)，则f(n)=O(g(n))。\n\n**Big Omega**：如果存在正数c和N，对于所有的n>=N，有f(n)>=c*g(n)，则f(n)=Omega(g(n))。\n\n**Big Theta**：f(n)=Theta(g(n))，当且仅当f(n)=O(g(n))且f(n)=Omega(g(n))。\n\n### 基于比较的排序\n\n**CLAIM**：任何基于比较的排序算法，RT不可能低于O(nlogn)。\n\n任何基于两两比较的排序算法都可以表达为一棵决策树（完全二叉树）。\n\n完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。\n\n![图片](/images/网络算法基础/2.PNG \"决策树的性质\")\n\n### 主办法（Master Method）\n\n**主定理**\n\n![图片](/images/网络算法基础/3.PNG \"主定理的定义\")\n\n![图片](/images/网络算法基础/4.PNG \"主定理的证明\")\n\n![图片](/images/网络算法基础/5.PNG \"参数\")\n\n\n\n# 图简介\n\n## 树\n\n**树**：不包含任何圈的连通图。\n\n**生成树(Spanning Tree)**：如果图G的一个子图包含了G的全部顶点，且为树，则称之为G的生成树。\n\n\n\n## 图搜索\n\n### 循环不变式\n\n- 概念：每次循环开始时都要保持的性质 / 状态。\n- **INVARIANT**：已探索集合和未探索集合应该处于正确的状态。边界点集合应准备好了。\n  - 循环开始时，从边界点集合中选择一个顶点进行探索。\n  - 循环结束前，将新扩展的边界点纳入集合。\n- 维护边界点集合：\n  - **BFS：队列(FIFO)**\n  - **DFS：堆栈(LIFO)**\n\n### BFS\n\nBFS的伪代码：\n\n    BFS(Graph, start):\n    B.EnQueue(s)\n    WHILE B is not empty:\n        d=B.DeQueue();\n        标记d为“已探索”\n        FOR each neighbor t of d:\n            IF t is not in visited:\n                B.EnQueue(t)\n            ENDIF\n        ENDFOR\n    ENDWHILE\n\n**聚合分析复杂度**：O(n+m)\n\n### DFS\n\nDFS的伪代码：\n\n```\nDFS(Graph, start):\nB.Push(s)\nWHILE B is not empty:\n d = B.Pop()\n 标记 d 为“已探索”\n FOR each neighbor t of d:\n  IF t is not in visited:\n   B.Push(t)\n  ENDIF\n ENDFOR\nENDWHILE\n```\n\n**聚合分析复杂度**：O(n+m)\n\n\n\n## 图的连通性\n\n### <u>无向图</u>的连通分量\n\n下述等价关系的等价类：当且仅当图中具有u-v路径时，称u~v。\n\n#### BFS求无向连通分量\n\nBFS求无向连通分量的伪代码：\n\n```\nLoop-BFS(G):\nFOR i=1 to n\n\tIF t is not in visited:\n\t\tBFS(G,i);\nENDFOR\n```\n\n**聚合分析复杂度**：O(n+m)\n\n\n\n### <u>有向图</u>的强连通分量（Strongly Connected Component,SCC）\n\n下述等价关系的等价类：当且仅当有向图G中具有u -> v路径且具有v -> u路径时，称称u~v。\n\n#### TWO-PASS算法(Kosaraju算法)\n\n1. 构建逆图。\n2. **在逆图中进行 Loop-DFS**，记录每个节点的**完成时间** f(v)。\n3. **在原图中运行 Loop-DFS**，按照逆图 DFS 完成的节点顺序进行，确定每个节点的 Leader。\n\n![图片](/images/网络算法基础/6.PNG \"Kosaraju算法-1\")\n\n![图片](/images/网络算法基础/7.PNG \"Kosaraju算法-2\")\n\n**聚合分析复杂度**：O(n+m)\n\n#### **关键引理**\n\nKey Lemma：考虑有向图G中的两个临接SCC，f(v)表示顶点v在反向图G'中Loop-DFS的完成时间，则有：\n$$\n\\max_{v \\in C_1} f(v) < \\max_{v \\in C_2} f(v)\n$$\n推论：最大的f值必然在”sink“SCC中。\n\n\n\n# 贪心MST\n\n## 贪心vs分治\n\n- **决策过程**：\n  - **分治**：每个子问题的解都会考虑整个子问题的情况，逐步拆解，最终合并。\n  - **贪心**：每一步决策只关注当前的局部最优解，不回头。\n- **全局与局部**：\n  - **分治**：每个子问题的解可能涉及整个问题的全局结构。\n  - **贪心**：每一步只考虑局部最优解，期望通过局部最优解得到全局最优解。\n- **解决问题的方式**：\n  - **分治**：递归地分解问题，直到子问题足够简单直接求解。\n  - **贪心**：通过逐步选择当前最优的解来构建最终解。\n- **是否需要回溯**：\n  - **分治**：通常会回溯并合并结果。\n  - **贪心**：不会回溯，一旦做出选择就不再修改。\n\n## MST（前提：无向图）\n\n**定义**：最小权重生成树T。\n\n- 必须是无向图;\n- 生成树的权重定义为树上边权重之和;\n- 生成树定义为E的子集：\n  1. 必须覆盖V;\n  2. 无环;\n  3. 连通。\n\n![图片](/images/网络算法基础/8.PNG \"MST\")\n\n### 割\n\n割的概念：图G(V，E)的一个割(Cut)是V的一个划分，该划分将集合V分为两个非空的集合。\n\n![图片](/images/网络算法基础/9.PNG \"割\")\n\n- n个顶点的图最多有 $ 2^n-2 $ 个不同的割。\n\n**Empty-Cut引理**：图G不连通，当且仅当Cut(A，B)没有割边。\n\n**Double-Crossing Lemma**：如果某个圈C⊆E中有边跨越了Cut(A，B)，则C中**至少还有一条边**跨越Cut(A，B)。\n\n**Lonely-Cut Corollary**：如果边e是跨越了Cut(A，B)的唯一一条边，则e不可能在**任一**圈中。\n\n**The Cut Property**：考虑图G中的一条边e，如果存在Cut(A，B)，使得e是所有跨越该割的所有边中权最小者，则e一定在G的MST中。\n\n割的证明：\n\n![图片](/images/网络算法基础/10.PNG \"割的证明-1\")\n\n![图片](/images/网络算法基础/11.PNG \"割的证明-2\")\n\n\n\n### **Prime算法**\n\n基本思想：\n\n- 从一个节点开始（任意选择一个节点作为起点），将它加入生成树。\n- 找到当前生成树中所有节点与其他节点之间的边，选择权重最小的边。\n- 将与该边相连的节点加入生成树，更新最小边的权重，重复选择最小边的过程。\n- 直到所有节点都被加入到生成树中。\n\nPim的伪代码：\n\n```\nPrim(Graph, start):\n    初始化最小生成树的边集合 MST = {}\n    初始化一个优先队列 Q，用于存储每个节点及其最小边的权重\n    对于每个节点 v ∈ Graph:\n        设置 v 的最小权重为无穷大（∞）\n    设置 start 节点的最小权重为 0，并将其加入 Q\n\n    WHILE Q is not empty:\n        选择 Q 中最小的权重的节点 u\n        标记 u 为“已加入到最小生成树”\n\n        对于 u 的每个邻居 v:\n            IF v is not in MST AND weight(u, v) < v 的当前权重:\n                更新 v 的最小权重为 weight(u, v)\n                将 v 更新到 Q 中，以反映其新的最小权重\n\n        ENDFOR\n    ENDWHILE\n```\n\nPrim算法的证明：\n\n![图片](/images/网络算法基础/12.PNG \"Prim的证明-1\")\n\n![图片](/images/网络算法基础/13.PNG \"Prim的证明-2\")\n","tags":["图","算法"]},{"url":"/categories/index.html","content":"---\n​---\ntitle:categories\nlayout:categories\n​---\n---\n"},{"url":"/about/index.html","content":"---\n​---\ntitle:about\nlayout:about\n​---\n---\n"},{"url":"/tags/index.html","content":"---\n​---\ntitle:tags\nlayout:tags\n​---\n---\n"}]