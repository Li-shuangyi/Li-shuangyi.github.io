<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ether Blog</title>
  
  <subtitle>Welcome to Ether Blog !!!</subtitle>
  <link href="http://example.com/rss.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-02-28T06:02:24.161Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Li-shuangyi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络算法基础</title>
    <link href="http://example.com/2025/02/27/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2025/02/27/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2025-02-27T06:35:01.000Z</published>
    <updated>2025-02-28T06:02:24.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法与分治"><a href="#算法与分治" class="headerlink" title="算法与分治"></a>算法与分治</h1><p>Divide and Conquer（DC）</p><p>Divide：将源问题分解为规模较小的子问题，<strong>拆分问题性质相同</strong>，将子问题的解组合成原问题的解。</p><p>Conquer：如果子问题仍然困难，就继续对子问题进行分解，直到子问题可以被trivial。</p><p>Recursion：用递归的方式实现。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>问题定义：</p><ul><li><p>输入：n个数构成的数组;</p></li><li><p>输出：排列该n个数的有序数组。</p></li></ul><p>Merg Sort：</p><ul><li>分解：将原数组等分为两个子数组;</li><li>求解：递归地对两个子数组分别排序;</li><li>合并：将两个已排序的子数组合并。</li></ul><h3 id="Merge-Step"><a href="#Merge-Step" class="headerlink" title="Merge Step"></a>Merge Step</h3><p> <strong>CLAIM</strong>：对于n ≥ 1的数组，MergeSort需要的运行时间T(n) ≤ $ 6n \log_2 n + 6n $</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/1.PNG" alt="图片" title="证明"></p><h3 id="函数增长的渐进符号"><a href="#函数增长的渐进符号" class="headerlink" title="函数增长的渐进符号"></a>函数增长的渐进符号</h3><p><strong>Big O</strong>: 如果存在正数c和N，对于所有的n&gt;&#x3D;N，有f(n)&lt;&#x3D;c*g(n)，则f(n)&#x3D;O(g(n))。</p><p><strong>Big Omega</strong>：如果存在正数c和N，对于所有的n&gt;&#x3D;N，有f(n)&gt;&#x3D;c*g(n)，则f(n)&#x3D;Omega(g(n))。</p><p><strong>Big Theta</strong>：f(n)&#x3D;Theta(g(n))，当且仅当f(n)&#x3D;O(g(n))且f(n)&#x3D;Omega(g(n))。</p><h3 id="基于比较的排序"><a href="#基于比较的排序" class="headerlink" title="基于比较的排序"></a>基于比较的排序</h3><p><strong>CLAIM</strong>：任何基于比较的排序算法，RT不可能低于O(nlogn)。</p><p>任何基于两两比较的排序算法都可以表达为一棵决策树（完全二叉树）。</p><p>完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/2.PNG" alt="图片" title="决策树的性质"></p><h3 id="主办法（Master-Method）"><a href="#主办法（Master-Method）" class="headerlink" title="主办法（Master Method）"></a>主办法（Master Method）</h3><p><strong>主定理</strong></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/3.PNG" alt="图片" title="主定理的定义"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/4.PNG" alt="图片" title="主定理的证明"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/4.PNG" alt="图片" title="参数"></p><h1 id="图简介"><a href="#图简介" class="headerlink" title="图简介"></a>图简介</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><strong>树</strong>：不包含任何圈的连通图。</p><p><strong>生成树(Spanning Tree)</strong>：如果图G的一个子图包含了G的全部顶点，且为树，则称之为G的生成树。</p><h2 id="图搜索"><a href="#图搜索" class="headerlink" title="图搜索"></a>图搜索</h2><h3 id="循环不变式"><a href="#循环不变式" class="headerlink" title="循环不变式"></a>循环不变式</h3><ul><li>概念：每次循环开始时都要保持的性质 &#x2F; 状态。</li><li><strong>INVARIANT</strong>：已探索集合和未探索集合应该处于正确的状态。边界点集合应准备好了。<ul><li>循环开始时，从边界点集合中选择一个顶点进行探索。</li><li>循环结束前，将新扩展的边界点纳入集合。</li></ul></li><li>维护边界点集合：<ul><li><strong>BFS：队列(FIFO)</strong></li><li><strong>DFS：堆栈(LIFO)</strong></li></ul></li></ul><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><pre><code>BFS(Graph, start):    Create an empty queue Q    Create an empty set visited to track visited nodes    Enqueue start node into Q    Add start node to visited setWhile Q is not empty:    Dequeue a node u from Q    Process node u (e.g., print, calculate, etc.)        For each neighbor v of u:        if v is not in visited:            Enqueue v into Q            Add v to visited set</code></pre><p><strong>聚合分析复杂度</strong>：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法与分治&quot;&gt;&lt;a href=&quot;#算法与分治&quot; class=&quot;headerlink&quot; title=&quot;算法与分治&quot;&gt;&lt;/a&gt;算法与分治&lt;/h1&gt;&lt;p&gt;Divide and Conquer（DC）&lt;/p&gt;
&lt;p&gt;Divide：将源问题分解为规模较小的子问题，&lt;stro</summary>
      
    
    
    
    
    <category term="图" scheme="http://example.com/tags/%E5%9B%BE/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
