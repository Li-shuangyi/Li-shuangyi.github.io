<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ether Blog</title>
  
  <subtitle>Welcome to Ether Blog !!!</subtitle>
  <link href="http://example.com/rss.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-12-05T08:05:16.320Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Li-shuangyi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LL-Flux：RTSP流视频链路延迟优化</title>
    <link href="http://example.com/2025/12/05/LL-Flux%EF%BC%9ARTSP-%E6%B5%81%E8%A7%86%E9%A2%91%E9%93%BE%E8%B7%AF%E5%BB%B6%E8%BF%9F%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2025/12/05/LL-Flux%EF%BC%9ARTSP-%E6%B5%81%E8%A7%86%E9%A2%91%E9%93%BE%E8%B7%AF%E5%BB%B6%E8%BF%9F%E4%BC%98%E5%8C%96/</id>
    <published>2025-12-05T02:21:52.000Z</published>
    <updated>2025-12-05T08:05:16.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LL-Flux：RTSP流视频链路延迟优化"><a href="#LL-Flux：RTSP流视频链路延迟优化" class="headerlink" title="LL-Flux：RTSP流视频链路延迟优化"></a>LL-Flux：RTSP流视频链路延迟优化</h1><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><img src="../images/LL-Flux：RTSP流视频链路延迟优化/1.png" alt="1" style="zoom:50%;" /><p style="text-align:center;">图1-RTSP视频流流程图</p><h2 id="RTP-RTSP"><a href="#RTP-RTSP" class="headerlink" title="RTP&#x2F;RTSP"></a>RTP&#x2F;RTSP</h2><p>RTSP &#x3D; 控制协议（control protocol）<br>RTP &#x3D; 承载媒体数据的实时传输协议（transport protocol）</p><h3 id="RTP"><a href="#RTP" class="headerlink" title="RTP"></a>RTP</h3><p>实时传输协议（Real-time Transport Protocol）,为数据提供了具有实时特征的端对端传送服务,用于实时传输数据。该协议提供的信息包括：时间戳（用于同步）、序列号（用于丢包和重排序检测）、以及负载格式（用于说明数据的编码格式）。</p><h3 id="RTSP"><a href="#RTSP" class="headerlink" title="RTSP"></a>RTSP</h3><p>实时流传输协议（Real Time Streaming Protocol，RTSP），TCP&#x2F;IP协议.该协议定义了一对多应用程序如何有效地通过IP网络传送多媒体数据。RTSP在体系结构上位于RTP和RTCP之上，它使用TCP或UDP完成数据传输。</p><p>延迟原因分析:</p><ol><li>缓冲区（Jitter Buffer）大小不同 → 延迟不同;</li><li>解码器实现不同 → 延迟不同;</li><li>是否等待时钟同步;</li><li>RTP depayload 的策略不同</li></ol><p>RTSP协议图:</p><p><img src="/../images/LL-Flux%EF%BC%9ARTSP%E6%B5%81%E8%A7%86%E9%A2%91%E9%93%BE%E8%B7%AF%E5%BB%B6%E8%BF%9F%E4%BC%98%E5%8C%96/2.webp" alt="图2-RTSP协议图"></p><p style="text-align:center;">图2-RTSP协议图</p><h2 id="视频编码-解码"><a href="#视频编码-解码" class="headerlink" title="视频编码&#x2F;解码"></a>视频编码&#x2F;解码</h2><ul><li>编码 (Encode)：把原始视频压缩成体积更小的数据（H.264&#x2F;H.265&#x2F;MJPEG）</li><li>解码 (Decode)：把压缩后的数据还原成可显示的图像帧（YUV&#x2F;RGB）</li></ul><p>视频编码格式</p><table><thead><tr><th align="center">格式</th><th align="center">类型</th><th align="center">特点</th><th align="center">带宽需求</th></tr></thead><tbody><tr><td align="center">H.264（AVC）</td><td align="center">有损视频编码（帧内+帧间）</td><td align="center">压缩效率高、延迟中等</td><td align="center">4–8 Mbps</td></tr><tr><td align="center">H.265（HEVC）</td><td align="center">有损视频编码（帧内+帧间），H.264 的升级版</td><td align="center">压缩效率更高（节省带宽）</td><td align="center">2–5 Mbps</td></tr><tr><td align="center">MJPEG（Motion JPEG）</td><td align="center">一系列 JPEG 图片组成的视频</td><td align="center">每帧独立，无帧间预测 → 低延迟</td><td align="center">100–300 Mbps</td></tr></tbody></table><h2 id="解码方式"><a href="#解码方式" class="headerlink" title="解码方式"></a>解码方式</h2><h3 id="VLC"><a href="#VLC" class="headerlink" title="VLC"></a>VLC</h3><p>VLC 使用 <strong>FFmpeg 解码器</strong>,直接打开一个 RTSP 链接,自带较大的 jitter buffer &#x2F; caching。许多缓存、时间同步都封装在内部，难以完全关闭。</p><p>###GStreamer</p><p>用于创建流媒体应用程序的框架,更加开源。GStreamer提供用于多媒体应用程序的API, 插件架构, 流水线架构, 流水线架构, 媒体类型处理&#x2F;协商机制, 同步机制等等。gstreamer基于glib实现,用C语言来实现面向对象思维。</p><p><img src="/../images/LL-Flux%EF%BC%9ARTSP%E6%B5%81%E8%A7%86%E9%A2%91%E9%93%BE%E8%B7%AF%E5%BB%B6%E8%BF%9F%E4%BC%98%E5%8C%96/3.png" alt="图3-GStreamer"></p><p style="text-align:center;">图3-GStreamer</p><p><strong>高性能</strong></p><ul><li>使用GLib的GSlice分配器。</li><li>插件之间极其轻量级的链接。数据可以以最小的开销在管道中传输。插件之间的数据传递只涉及典型管道中的指针取消引用。</li><li>提供一种直接在目标内存上工作的机制。例如，插件可以直接写入X服务器的共享内存空间。缓冲区也可以指向任意内存，例如声卡的内部硬件缓冲区。</li><li>写入时重新计数和复制最大限度地减少 memcpy 的使用。子缓冲区有效地将缓冲区拆分为可管理的部分。</li><li>专用流线程，调度由内核处理。</li><li>通过使用专门的插件允许硬件加速。</li><li>使用带有插件规范的插件注册表，以便可以延迟插件加载，直到实际使用插件。</li></ul><p><strong>基础概念</strong></p><ol><li><p><strong>元素(Elements):</strong></p><p>element 是执行某个媒体处理步骤的“功能模块”。每个 element 只做一件事，比如读取视频、拆包、解码、转换格式或输出画面。把多个 element 顺序连接起来，就形成一条完整的数据处理流水线（pipeline），数据会从源头一路经过这些模块处理后最终被播放或保存。</p><p>一个功能模块，例如：</p><table><thead><tr><th>元件</th><th>功能</th></tr></thead><tbody><tr><td>rtspsrc</td><td>RTSP 拉流</td></tr><tr><td>rtph265depay</td><td>RTP 去封包</td></tr><tr><td>avdec_h265</td><td>H.265 解码（来自 FFmpeg）</td></tr><tr><td>videoconvert</td><td>视频格式转换</td></tr><tr><td>x264enc</td><td>H.264 编码</td></tr><tr><td>autovideosink</td><td>显示</td></tr></tbody></table></li><li><p><strong>Pads:</strong></p><p>Pad 是 GStreamer 元素的输入&#x2F;输出接口：，用来把元件连接起来让数据从一个元件流向另一个。每个 Pad 有自己能处理的数据类型（Caps），只有当两个 Pad 的类型兼容时才能连接，从而保证解码、转换、播放等处理模块之间的数据能够正确流动。数据在 pipeline 中是通过这些 Pad 单向流动的。</p><ul><li><strong>src pad</strong>（输出）</li><li><strong>sink pad</strong>（输入）</li></ul><p>元素之间用 pad 连接成 pipeline。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">elementA.src → elementB.sink <br></code></pre></td></tr></table></figure></li><li><p><strong>Caps:</strong></p></li></ol><p>​描述媒体格式，确保上下游格式匹配如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">video/x-h264<br>video/x-raw,format=I420,width=1280,height=720<br></code></pre></td></tr></table></figure><ol start="4"><li><p><strong>Bin and Pipeline（管线）:</strong></p><p>Bin 是一组元素（element）的容器，本身也被当作一个元素来使用。它的作用是把多个元素打包成一个整体，让应用程序更容易管理复杂的 pipeline，例如一次性控制整个子系统的状态或统一接收内部元素产生的消息。</p><p>Pipeline 是最高级的 Bin，负责启动数据流、同步所有元素并管理媒体处理过程。Pipeline是多个元素的一条处理链路，即写的命令。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">gst-launch-1.0 rtspsrc ! rtph265depay ! avdec_h265 ! autovideosink<br></code></pre></td></tr></table></figure></li></ol><p><img src="/../images/LL-Flux%EF%BC%9ARTSP%E6%B5%81%E8%A7%86%E9%A2%91%E9%93%BE%E8%B7%AF%E5%BB%B6%E8%BF%9F%E4%BC%98%E5%8C%96/4.png" alt="图4-GStreamer-Pipeline"></p><p style="text-align:center;">图4-GStreamer-Pipeline</p><p>Pad是一个element的输入&#x2F;输出接口，分为src pad（生产数据）和sink  pad（消费数据）两种。两个element必须通过pad才能连接起来，pad拥有当前element能处理数据类型的能力（capabilities），会在连接时通过比较src pad和sink  pad中所支持的能力，来选择最恰当的数据类型用于传输，如果element不支持，程序会直接退出。在element通过pad连接成功后，数据会从上一个element的src pad传到下一个element的sink pad然后进行处理。当element支持多种数据处理能力时，我们可以通过Cap来指定数据类型.</p><p><strong>通讯</strong></p><ul><li><p>GStreamer为应用程序和管道之间的通信和数据交换提供了多种机制。</p></li><li><p>Buffers 是用于在管道中的元素之间传递流数据的对象。缓冲区总是从源传输到接收器（下游）。</p></li><li><p>Events 是在元素之间或从应用程序发送到元素的对象。事件可以上游和下游传输。下游事件可以与数据流同步。</p></li><li><p>messages 是由element发出的消息，通过bus，以异步的方式被应用程序处理。通常用于传递errors, tags, state changes,  buffering state,  redirects等消息。消息处理是线程安全的。由于大部分消息是通过异步方式处理，所以会在应用程序里存在一点延迟，如果要及时的相应消息，需要在streaming线程捕获处理。</p></li><li><p>queries 查询允许应用程序从管道请求信息，如持续时间或当前播放位置。查询总是同步回答。元素也可以使用查询从其对等元素请求信息（如文件大小或持续时间）。它们可以在管道中两种方式使用，但上游查询更常见。</p></li></ul><p><img src="/../images/LL-Flux%EF%BC%9ARTSP%E6%B5%81%E8%A7%86%E9%A2%91%E9%93%BE%E8%B7%AF%E5%BB%B6%E8%BF%9F%E4%BC%98%E5%8C%96/5.png" alt="图5-GStreamer-communicate"></p><p style="text-align:center;">图5-GStreamer-communicate</p><h2 id="相机测试"><a href="#相机测试" class="headerlink" title="相机测试"></a>相机测试</h2><h3 id="硬解码"><a href="#硬解码" class="headerlink" title="硬解码"></a>硬解码</h3><p>在非jetson环境下不推荐</p><p><strong>环境配置</strong></p><p>在新版Uubuntu22.04下安装Gstramer，会安装高版本的Gstreamer就不会出现该问题（Windows下高版本也不会），只有Ubuntu20.04及以下版本才会出现。</p><ol><li>linux平台下的gstreamer安装</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装Gstreamer软件</span><br><span class="hljs-built_in">sudo</span> apt install gstreamer1.0-tools  gstreamer1.0-alsa  gstreamer1.0-plugins-base  gstreamer1.0-plugins-good  gstreamer1.0-plugins-bad  gstreamer1.0-plugins-ugly  gstreamer1.0-libav  gtk-doc-tools -y<br><span class="hljs-comment"># 安装Gstreamer开发包</span><br><span class="hljs-built_in">sudo</span> apt install libgstreamer1.0-dev  libgstreamer-plugins-base1.0-dev  libgstreamer-plugins-good1.0-dev  libgstreamer-plugins-bad1.0-dev  libgstrtspserver-1.0-dev -y<br></code></pre></td></tr></table></figure><p>测试指令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gst-launch-1.0 -v videotestsrc pattern=0 ! <span class="hljs-string">&quot;video/x-raw,framerate=30/1,width=800,height=600&quot;</span> ! timeoverlay ! autovideosink<br></code></pre></td></tr></table></figure><ol><li>下载gst-plugins-bad</li></ol><p>查看gstreamer版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gst-launch-1.0 --version<br></code></pre></td></tr></table></figure><p>ubuntu20.04的版本为1.16.3，下载gst-plugins-bad源码包</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载源码并解压</span><br>wget &lt;https://gstreamer.freedesktop.org/src/gst-plugins-bad/gst-plugins-bad-1.16.3.tar.xz&gt;<br>tar -vxf gst-plugins-bad-1.16.3.tar.xz<br></code></pre></td></tr></table></figure><ol><li>安装Nvidia的Video Codec SDK</li></ol><p>gst-plugins-bad编译过程依赖的库及头文件，需要从NVIDIA官网下载，下载地址：<a href="https://developer.nvidia.com/nvidia-video-codec-sdk/download">NVIDIA VIDEO CODEC SDK - Get Started | NVIDIA Developerm</a></p><p>下载完成后并解压，将头文件和库文件拷贝至&#x2F;usr&#x2F;loocal下:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> Video_Codec_SDK_13.0.19/Interface/* /usr/local/cuda/include<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> Video_Codec_SDK_13.0.19/Lib/linux/stubs/x86_64/* /usr/local/cuda/lib64/stubs<br></code></pre></td></tr></table></figure><ol><li>编译</li></ol><p>在gst-plugins-bad目录下开启终端，运行以下命令，需要根据版本更改cuda。</p><p>查看cuda版本指令:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nvcc --version<br>./autogen.sh<br>NVENCODE_LIBS=<span class="hljs-string">&quot;-L/usr/local/cuda/lib64/stubs&quot;</span> NVENCODE_CFLAGS=<span class="hljs-string">&quot;-I/usr/local/cuda/include&quot;</span> ./configure --enable-nvdec --enable-nvenc --enable-openh264 --with-cuda-prefix=<span class="hljs-string">&quot;/usr/local/cuda-11.8&quot;</span><br></code></pre></td></tr></table></figure><p>进入sys&#x2F;nvdec目录进行编译硬解码</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> sys/nvdec<br>make -j8<br><span class="hljs-built_in">sudo</span> make install<br></code></pre></td></tr></table></figure><p>进入sys&#x2F;nvdec目录进行编译硬编码</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> sys/nvenc<br>make -j8<br><span class="hljs-built_in">sudo</span> make install<br></code></pre></td></tr></table></figure><ol><li>添加环境变量</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-built_in">export</span> GST_PLUGIN_PATH=<span class="hljs-string">&quot;/usr/local/lib/gstreamer-1.0&quot;</span> &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><ol><li>测试</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gst-inspect-1.0 nvdec<br>gst-inspect-1.0 nvh264enc<br></code></pre></td></tr></table></figure><h3 id="软解码"><a href="#软解码" class="headerlink" title="软解码"></a>软解码</h3><ol><li>TCP + latency&#x3D;0 ; rtph265depay + h265parse + avdec_h265 ; videoconvert + autovideosink</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gst-launch-1.0 -v rtspsrc location=rtsp://192.168.144.25:8554/main.264 protocols=tcp latency=0 ! \\<br>rtph265depay ! h265parse ! avdec_h265 ! videoconvert ! autovideosink<br></code></pre></td></tr></table></figure><p>delay &#x3D; 220ms+</p><ol><li>TCP + latency&#x3D;0 ; drop-on-latency&#x3D;true ; sync&#x3D;false</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gst-launch-1.0 -v \\<br>rtspsrc location=rtsp://192.168.144.25:8554/main.264 protocols=tcp latency=0 drop-on-latency=<span class="hljs-literal">true</span> ! \\<br>rtph265depay ! h265parse ! avdec_h265 ! videoconvert ! autovideosink <span class="hljs-built_in">sync</span>=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>delay &#x3D; 160ms+</p><ul><li>rtph265depay : RTP H.265 去封装,拼成连续 H.265 码流</li><li>h265parse : H.265 码流解析器,分析码流，让 decoder 正常工作</li><li>avdec_h265 : H.265 码流解码器,解码为 原始帧</li><li>videoconvert : 像素格式转换器,转换像素格式 → RGB 等可显示格式</li><li>autovideosink : 自动选择一个可用的视频输出设备显示到屏幕</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LL-Flux：RTSP流视频链路延迟优化&quot;&gt;&lt;a href=&quot;#LL-Flux：RTSP流视频链路延迟优化&quot; class=&quot;headerlink&quot; title=&quot;LL-Flux：RTSP流视频链路延迟优化&quot;&gt;&lt;/a&gt;LL-Flux：RTSP流视频链路延迟优化&lt;/</summary>
      
    
    
    
    
    <category term="Video Streaming" scheme="http://example.com/tags/Video-Streaming/"/>
    
  </entry>
  
  <entry>
    <title>复现SHAC</title>
    <link href="http://example.com/2025/12/03/%E5%A4%8D%E7%8E%B0SHAC/"/>
    <id>http://example.com/2025/12/03/%E5%A4%8D%E7%8E%B0SHAC/</id>
    <published>2025-12-03T05:51:02.000Z</published>
    <updated>2025-12-03T06:36:24.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目名称-SHAC复现"><a href="#项目名称-SHAC复现" class="headerlink" title="项目名称 : SHAC复现"></a>项目名称 : SHAC复现</h1><h2 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目名称-SHAC复现&quot;&gt;&lt;a href=&quot;#项目名称-SHAC复现&quot; class=&quot;headerlink&quot; title=&quot;项目名称 : SHAC复现&quot;&gt;&lt;/a&gt;项目名称 : SHAC复现&lt;/h1&gt;&lt;h2 id=&quot;论文阅读&quot;&gt;&lt;a href=&quot;#论文阅读&quot; cla</summary>
      
    
    
    
    
    <category term="project" scheme="http://example.com/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>난장판插件食用说明</title>
    <link href="http://example.com/2025/10/09/%EB%82%9C%EC%9E%A5%ED%8C%90%E6%8F%92%E4%BB%B6%E9%A3%9F%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://example.com/2025/10/09/%EB%82%9C%EC%9E%A5%ED%8C%90%E6%8F%92%E4%BB%B6%E9%A3%9F%E7%94%A8%E8%AF%B4%E6%98%8E/</id>
    <published>2025-10-09T01:36:09.000Z</published>
    <updated>2025-12-05T01:59:12.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BASH文件"><a href="#BASH文件" class="headerlink" title="BASH文件"></a>BASH文件</h1><h2 id="切换环境"><a href="#切换环境" class="headerlink" title="切换环境"></a>切换环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&gt;&gt; switch environment &gt;&gt;&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">!! Contents within this block are managed by <span class="hljs-string">&#x27;conda init&#x27;</span> !!</span><br>function use_conda() &#123;<br>    __conda_setup=&quot;$(&#x27;/home/xx/anaconda3/bin/conda&#x27; &#x27;shell.bash&#x27; &#x27;hook&#x27; 2&gt; /dev/null)&quot;<br>    if [ $? -eq 0 ]; then<br>        eval &quot;$__conda_setup&quot;<br>    else<br>        if [ -f &quot;/home/xx/anaconda3/etc/profile.d/conda.sh&quot; ]; then<br>            . &quot;/home/xx/anaconda3/etc/profile.d/conda.sh&quot;<br>        else<br>            export PATH=&quot;/home/xx/anaconda3/bin:$PATH&quot;<br>        fi<br>    fi<br>    unset __conda_setup<br>    conda activate LCCNet2<br>    echo &quot;Conda 环境已激活&quot;<br>&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;&lt;&lt; <span class="hljs-string">conda initialize &lt;&lt;&lt;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&gt;&gt;&gt; fishros initialize &gt;&gt;&gt;</span></span><br>function use_ros() &#123;<br>    source /opt/ros/noetic/setup.bash<br>    echo &quot;ROS 环境已激活&quot;<br>&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;&lt;&lt; fishros initialize &lt;&lt;&lt;</span></span><br></code></pre></td></tr></table></figure><p>新的终端默认不source任何环境。在终端中输入<code>use_conda</code> 启动conda环境，输入<code> use_ros</code> 启动ros环境。</p><h1 id="COKKI数据集准备"><a href="#COKKI数据集准备" class="headerlink" title="COKKI数据集准备"></a>COKKI数据集准备</h1><h2 id="小主机"><a href="#小主机" class="headerlink" title="小主机"></a>小主机</h2><p>运行livox_ws下的脚本”record.sh”</p><h2 id="本地处理"><a href="#本地处理" class="headerlink" title="本地处理"></a>本地处理</h2><ul><li><p>把bag放在<code>[COKKIBag](../../../home/qi/ros_ws/src/COKKIDataset/COKKIBag)</code>路径下，命名为“xx_indoor”或“xx_outdoor”。</p></li><li><p>在PrepareCOKKI功能包中，修改<code>/config/bag_exporter_config.yaml</code>中<code>bag_path</code>&#x2F;<code>image_save_path</code>&#x2F;<code>bin_save_path</code>参数。</p></li><li><p>运行launch文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch cokkidataset cokkidataset.launch<br></code></pre></td></tr></table></figure></li><li><p>在<code>/home/qi/home/qi/ros_ws/src/COKKIDataset/sequences/xx</code>中筛选图片，确保点云和图片一一对应。将同一序列的indoor和outdoor数据放在一起，使用rename.py修改当前数据集ID。</p></li></ul><h1 id="VSCODE插件"><a href="#VSCODE插件" class="headerlink" title="VSCODE插件"></a>VSCODE插件</h1><h2 id="Bookmarks"><a href="#Bookmarks" class="headerlink" title="Bookmarks"></a>Bookmarks</h2><p>用于代码标记及标记之间的跳转。</p><p>在当前工作区中按<code>ctrl+shift+p</code>，输入<code>bookmarks</code>自定义快捷键：</p><ul><li><code>ctrl+alt+shift+k</code>：标记&#x2F;取消标记（蓝色标记图标）</li><li><code>shift+j</code>：跳转到上一个标记</li><li><code>shift+l</code>：跳转到下一个标记</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BASH文件&quot;&gt;&lt;a href=&quot;#BASH文件&quot; class=&quot;headerlink&quot; title=&quot;BASH文件&quot;&gt;&lt;/a&gt;BASH文件&lt;/h1&gt;&lt;h2 id=&quot;切换环境&quot;&gt;&lt;a href=&quot;#切换环境&quot; class=&quot;headerlink&quot; title=&quot;切</summary>
      
    
    
    
    
    <category term="插件" scheme="http://example.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>复现FAST-LIVO2</title>
    <link href="http://example.com/2025/07/04/%E5%A4%8D%E7%8E%B0FAST-LIVO2/"/>
    <id>http://example.com/2025/07/04/%E5%A4%8D%E7%8E%B0FAST-LIVO2/</id>
    <published>2025-07-04T06:26:07.000Z</published>
    <updated>2025-11-27T12:15:33.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目名称-FAST-LIVO2复现"><a href="#项目名称-FAST-LIVO2复现" class="headerlink" title="项目名称 : FAST-LIVO2复现"></a>项目名称 : FAST-LIVO2复现</h1><h2 id="任务规划"><a href="#任务规划" class="headerlink" title="任务规划"></a>任务规划</h2><ul><li><p>设备:</p><ol><li>Livox AVIA</li><li>Livox Converter 2.0</li><li>海康相机MV-CS020-10UC</li></ol></li><li><p>硬件:</p><ol><li><p>手持设备支架设计(Solidworks)</p></li><li><p>STM32硬同步流程</p></li><li><p>相机-Lidar标定</p></li></ol></li><li><p>软件:</p><ol><li>环境,build</li><li>录包,跑包</li></ol></li></ul><h2 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h2><h3 id="FAST-LIVO"><a href="#FAST-LIVO" class="headerlink" title="FAST-LIVO"></a>FAST-LIVO</h3><ul><li><p>LIO 子系统: 反向传播补偿 LiDAR 扫描的运动畸变,计算帧到地图点到平面的残差。</p></li><li><p>VIO 子系统: 提取当前 FoV 中的视觉子映射,剔除异常值。</p></li><li><p>视觉对齐: 稀疏直接图像对齐,比较光流误差。</p></li><li><p>紧密耦合: 点到平面残差和图像光度误差与误差状态iKF中的IMU传播紧密耦合。</p></li><li><p>ikdTree添加新点至全局映射。</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/1.png" alt="图1-FAST-LIVO系统概述图"></p><p style="text-align:center;">图1-FAST-LIVO系统概述图</p></li></ul><h3 id="FAST-LIVO2"><a href="#FAST-LIVO2" class="headerlink" title="FAST-LIVO2"></a>FAST-LIVO2</h3><h4 id="新贡献"><a href="#新贡献" class="headerlink" title="新贡献"></a>新贡献</h4><ol><li><p>问题 : 激光雷达和视觉测量之间维度不匹配 (测量维度 &#x2F; 数据类型 &#x2F; 分布特性) , 而 FAST-LIVO中使用异步更新。</p><p>解决方案 : ESIKF框架,惯顺序更新(sequential update)。</p></li><li><p>问题 : FAST-LIVO中假设图像块中所有像素共享相同深度,该假设降低了对齐中仿射变换的准确性。</p><p>解决方案 : 使用并进一步优化来自激光雷达点的平面先验。</p></li><li><p>问题: FAST-LIVO 基于与当前视图的接近度选择参考块,导致参考块低质量,降低了准确性。</p><p>解决方案 : 提出了一种参考块 Reference Patch 更新策略 ,通过选择具有大视差和足够纹理细节的高质量内点参考块提高图像对齐的准确性。</p></li><li><p>问题 : 环境光照变化会降低图像对齐中的收敛性,FAST-LIVO中未解决该问题。</p><p>解决方案 : 在线曝光时间估计。</p></li><li><p>问题 : 激光雷达近距离盲区造成激光雷达点测量缺失,FAST-LIVO中未考虑该问题。</p><p>解决方案 : 提出按需进行体素射线投射的方法，以增强系统在因激光雷达近距离盲区造成的激光雷达点测量缺失情况下的鲁棒性。 </p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/34.png" alt="图2-FAST-LIVO2系统概述图"></p></li></ol><p style="text-align:center;">图2-FAST-LIVO2系统概述图</p><h4 id="Section-4-顺序更新的ESIKF"><a href="#Section-4-顺序更新的ESIKF" class="headerlink" title="Section 4 顺序更新的ESIKF"></a>Section 4 顺序更新的ESIKF</h4><ol><li><p>扫描重组 Scan Recombination</p><ol><li><p>将$t_k-1$时刻到$t_k$时刻的所有激光点都合并到$t_k$时刻。</p><p>将高频、连续采样的LiDAR原始点云数据，按照相机采样时刻进行分割，从而得到与相机采样时刻对应的独立LiDAR扫描帧。    </p></li><li><p>通过硬同步使雷达和相机采样一致</p><p>激光雷达和相机在$t_k-1$ 时刻同时触发采集，但相机在瞬间完成采集，激光雷达则在$t_k$时刻才完成一帧数据。虽然触发时间相同，系统实际处理的是$t_k$时刻图像与延迟 $t$ (约100ms) 的激光雷达帧。</p></li></ol></li><li><p>传播 Propagation</p></li></ol><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/35.png" alt="图3-前向传播与反向传播示意图"></p><p style="text-align:center;">图3-前向传播与反向传播示意图</p><p>​1. 前向传播：KF在预测阶段将噪声$W_i$ 设为0，预测$t_k-1$ 到$t_k$ 这段时间每个IMU输入时的状态。由KF预测可得此时状态量为$\hat{x}$，状态量对应的协方差$\hat{P}$作为更新阶段的先验。</p><p>​2. 反向传播 : 补偿激光雷达运动畸变，确保所有的点都是在tk时刻观测到的。</p><p>​运动畸变 : 由于激光雷达在移动过程中分时采点，若忽略每个点的具体采集时间,统一视为同一时刻采样，会导致点云在空间上的扭曲或错位。</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/36.png" alt="图4-反向传播示意图"></p><p style="text-align:center;">图4-反向传播示意图</p><p>​3. 顺序更新 : 利用激光雷达测量细化的状态将被更新地图的几何结构，该状态将在视觉更新被进一步收敛，其中视觉更新将在每个金字塔层面上进行，每层都要收敛。最终得到的状态被用于传播新到来的IMU测量，并更新地图的视觉结构（纹理）。</p><h4 id="Section-5-局部建图"><a href="#Section-5-局部建图" class="headerlink" title="Section 5 局部建图"></a>Section 5 局部建图</h4><ol><li><p>地图结构 Map Structure</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/37.png" alt="图5-Voxel Map示意图"></p><p style="text-align:center;">图5-Voxel Map示意图</p></li></ol><p>​<strong>自适应体素结构</strong>,按照哈希表和每个哈希条目的八叉树组织。</p><p>​哈希表管理根体素,每一个根体素为0.5x0.5x0.5m的固定维度,每个根体素包含一个八叉树结构。叶体素代表一个局部平面,存储一个平面特征(即平面中心、法向量和不确定性),以及一组位于该平面上的激光雷达原始点。<strong>叶体素的不同大小使其能够表示不同尺度的局部平面,从而适应具有不同结构的环境</strong>。部分点与三级图像块(8×8图块大小)相连(即视觉地图点),收敛的视觉地图点仅与参考块关联，未收敛的点与参考块和其他可见块都关联。</p><p>​为了防止地图大小无限增长,设置初始地图范围后, 在该范围进行进行探测和建图，当雷达探测范围触碰到范围边界，局部地图范围会在该边界方向上移动d距离。存储的A处点云数据将被重置为C处的数据,保持内存大小固定。每次ESIKF更新后检查一次地图是否移动。</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/38.png" alt="图6-局部地图滑动示意图"></p><p style="text-align:center;">图6-局部地图滑动示意图</p><p><em>在(a)中,灰色矩形是初 始地图区域,长度为 L。红色圆圈是以 p0 为中心的初始 检测区域。在(b)中,检测区域移动到新位置 p1,在此位 置触碰到地图边界。地图区域移动到新位置(蓝色矩形) ,移动距离为 d。在(c)中,内存空间B保持不变。存储绿色区域的内存空间A被重置为(b)中的蓝色区域C。</em></p><ol start="2"><li><p>几何构造及更新 : <strong>基于ESIKF对激光雷达点测量构建和更新实现</strong><a name="Section5-2"></a></p><p>在ESIKF中的激光雷达更新后,将激光雷达扫描的所有点注册到全局坐标系中。对于每个注册的激光雷达点,确定其在哈希图中的根体素位置。</p><ul><li><p>如果不存在,用新点初始化该体素并将其索引到哈希图中。</p></li><li><p>如果确定的体素已经存在于地图中, 将该点附加到现有体素中。</p></li></ul><p>在所有扫描中的点分配完成后,进行几何构建和更新。</p><ol><li><p>对于新创建的体素</p><p>通过奇异值分解来确定其所有包含的点是否位于一个平面上。</p><ul><li>如果是,计算中心点 $ q &#x3D; p ̄$ 、平面法线 $n$ 和平面的协方差矩阵$ Σ_{n,q} $。$ Σ_{n,q} $ 用于表征平面不确定性 (平面不确定性源于姿态估计的不确定性和点测量噪声)。</li><li>如果不是,体素将不断细分为八个更小的八分体,直到子体素中的点被确定为形成一个平面或达到最大层数。达到最大层数后,叶体素中的点将被丢弃。</li><li><strong>地图仅包含被识别为平面的体素(根体素或子体素)。</strong></li></ul></li><li><p>对于已存在的体素</p><p>评估新的点和已有的点能否构建为一个平面</p><ul><li>如果否：和前面一样，对体素进行划分。</li><li>如果是：更新平面参数和协方差。</li><li><strong>一旦平面参数是收敛的，该平面将被视为成熟面，平面参数将被视为固定，平面上的新点将被丢弃。</strong></li></ul></li><li><p>平面上的激光雷达点生成视觉地图点</p><ul><li><p>对于成熟的平面,最近的50个雷达点是生成视觉地图点的候选者。</p></li><li><p>对于未成熟的平面,所有雷达点都是候选者。</p></li><li><p>视觉地图点生成过程将识别其中一些候选点作为视觉地图点,并将它们与图像块附加以进行图像对齐。</p></li></ul></li></ol></li><li><p>视觉地图点生成和更新</p><p>选择地图中的候选激光雷达点用于生成和更新。(<a href="#Section7-1">详见第Section 7-1</a>)</p><p>候选点条件:</p><ol><li>在当前帧视角可见</li><li>在当前图像中表现出显著灰度梯度</li></ol><p>在视觉更新后,将候选点投影到当前图像上,并<strong>在每个体素中保留最小深度的候选点作为局部平面。将当前图像划分为每个30 × 30像素的均匀网格单元。</strong></p><ul><li><p>若一个栅格元没有包含任何投影到这的视觉地图点,则使用<strong>带有最高灰度梯度的候选点新建一个新的视觉地图点</strong>。将该点与当前图像块、估计的当前状态（位姿&#x2F;曝光时间）以及平面法向量相关联。与视觉地图点相关联的块有三个相同大小的层（每层11x11像素）,构成块金字塔。</p></li><li><p>若一个栅格元包含了投影的视觉地图点，并满足以下条件之一就添加新的块到当前视觉地图点上:</p><ol><li>超过20帧没有添加新的块到视觉地图点。</li><li>视觉地图点在当前帧中的像素位置比其在上一个块的位置相差至少40像素（晃得太厉害，点在屏幕里移动了一大段距离，重新拍一张）。</li></ol></li></ul><p><strong>地图点将拥有视角分布均匀的有效块Patch。</strong></p></li><li><p>Reference Patch 参考块更新 : 一个视觉地图点会拥有不止一个块。需要选择一个作为参考块用于视觉更新中的图像对齐，基于光度相似性和视角给每个块 f 评分。在所有附加到视觉地图点的Patch中,得分最高的Patch被更新为参考块。</p></li></ol><p>   上述评分机制倾向于选择:</p><pre><code>1. 外观与大多数其他补丁相似(以NCC为标准)的参考补丁, 以避免动态目标上的补丁;2. 视角方向与平面正交,从而在高分辨率下保持纹理细节。</code></pre><p>   FAST-LIVO 中的参考块更新策略直接选择与当前帧视角方向差异最小的补丁,导致所选参考补丁与当前帧非常接近,从而对当前姿态更新施加了弱约束。</p><ol start="5"><li><p>法向量细化</p><p>每个视觉地图点都被假设位于一个小的局部平面上。（以前的研究假设像素块上的所有像素拥有同样深度）</p><p>使用源于雷达点的平面参数取得更好的精度<a href="#Section5-2">(详见第Section 5-2)</a>。 </p><p>平面法向量对于视觉更新过程中的图像仿射变换对齐至关重要,平面法向量细化能够增强仿射变换的精度。 </p><p>具体：<strong>通过最小化参考块与视觉地图点关联的其他块之间的光度误差，来优化参考块中的平面法向量。</strong></p></li></ol><h4 id="Section-6-激光雷达测量模型"><a href="#Section-6-激光雷达测量模型" class="headerlink" title="Section 6 激光雷达测量模型"></a>Section 6 激光雷达测量模型</h4><p>用于ESIKF LiDAR更新的LiDAR测量模型$y_l &#x3D; h_l(x, v_l)$。</p><ol><li><p>点到平面的雷达测量模型</p><ul><li><p>投影无畸变点到世界系;</p></li><li><p>确定该世界点所在哈希图的根&#x2F;子体素，并构建观测公式</p><p>如果没有体素被发现或该体素不包含平面则丢弃该点。 否则，构建该体素中平面与这个点的观测公式。 假设一个激光真值点，准确的到世界系变换阵，这个点与平面中心点应该是在一个平面上的。</p></li><li><p>带入激光点测量和噪声，平面法向量估计和中心点估计及协方差,</p><p>得到测量噪声的形式:$v_l&#x3D;(δ^L\mathbf{p}_j,δ\mathbf{n}_j,δ\mathbf{q}_j)$</p></li></ul></li><li><p>带有光束发散效应的Lidar测量噪声</p><p>测量噪声主要由两个元素构成，飞行时间导致的测距不确定性和编码导致的轴承方向不确定性，除此外，还有激光的发散角度。随着方位方向与法向量之间的角度 $φ$的增加，激光雷达点的测距不确定性显著增加，而方位方向的不确定性不受影响。当从地面和墙面选的点更多时，位姿估计的精度更高。 <strong>$φ$越小越好</strong>。</p></li></ol><h4 id="Section-7-视觉测量模型"><a href="#Section-7-视觉测量模型" class="headerlink" title="Section 7 视觉测量模型"></a>Section 7 视觉测量模型</h4><p>用于ESIKF视觉更新的视觉测量模型$y_c &#x3D; h_c(x, v_c)$。</p><p>1.视觉地图点选择<a name="Section7-1"></a></p><p>为了视觉更新中的稀疏对齐，首先选择合适的视觉地图点。 </p><ul><li><p>使用体素和投射查询来提取当前相机FoV中的可见的地图点集合（视觉的子地图）。 </p></li><li><p>来自这个子地图中视觉地图点将被挑选并剔除离群点。 </p></li><li><p>这个过程能够为<strong>视觉测量模型中构建视觉光度误差提供一个精细的视觉地图点集合</strong>。</p><ol><li><p>可见体素的查询 : </p><p>问题: 地图中体素数量庞大,从地图中的大量体素中确定当前帧FoV中的地图体素困难。</p><p>解决：利用当前LiDAR扫描直接命中的体素作为候选，大幅减少需处理的体素数量。 </p><p>实现：1、使用测量的点位置来查询体素哈希表</p><p>​       2、筛选上一图像帧中通过相同体素查询和光线投射确认为可见的地图点所命中的体素。 </p><p>最后,通过检查这两种体素中包含的地图点并进行视场检查,得到当前的视觉子图。</p></li><li><p>按需投射 :</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/39.png" alt="图7-按需体素光线投射的示意图"></p><p style="text-align:center;">图7-按需体素光线投射的示意图</p><p>当雷达距离目标太近而没有点返回时&#x2F;摄像机FOV可能不会被激光雷达FOV完全覆盖。流程如下 :</p><ol><li><p>图像划分<br>将图像划分为30x30的均匀栅格元，投影体素查询获得的视觉地图点到栅格元上。</p></li><li><p>对未被占据栅格元的射线投射<br>对于每个未被视觉地图点占据的栅格元，光线沿着中心像素向后投射，其中采样点沿着光线在深度方向上从dmin到dmax均匀分布</p></li><li><p>降低计算量<br>相机机体系下每个光线上的采样点的位置都被预先算好了。</p></li><li><p>处理每个采样点<br>对每个采样点，评估其对应的体素状态：<br>若该体素包含投影后位于此网格单元内的地图点，则将这些地图点纳入视觉子地图，并终止当前射线的处理。<br>否则：继续射线上的下一个采样点，直到达到最大深度DMAX。</p></li><li><p>所有未被占据栅格元处理完成<br>获得了一组在整个图像上分布的视觉地图点集合。</p></li></ol></li><li><p>视觉地图点中离群点剔除</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/40.png" alt="图8-剔除离群点示意图"></p><p style="text-align:center;">图8-剔除离群点示意图</p><p>存在的问题: 将会严重降低图像对齐精度</p><p>​    (1) 在当前帧中被遮挡</p><p>​    (2) 存在深度不连续性</p><p>​    (3) 拥有这些点的参考块采集视角过大</p><p>​    (4) 在当前帧中观测视角过大</p><ol><li><p>投影所有点–解决问题1</p><p>在雷达更新后，将子图中的所有视觉地图点用位姿投影至当前帧，并在每个栅格元中保留深度最小的点。</p></li><li><p>深度图–解决问题2</p><p>将当前雷达帧的点投影至当前帧生成深度图，用9x9的邻域在深度图中比较视觉地图点的深度，并判断遮挡和深度变化。被占据的&#x2F;深度不连续的点将被剔除。</p></li><li><p>点移除–解决问题3&amp;4</p><p>移除参考块与当前块的视角太大（法向量与从视觉地图点到块光学中心的方向之间的角度超过80°）的点。</p></li></ol></li></ol></li></ul><ol start="2"><li>稀疏直接的视觉测量模型</li></ol><p>上面提取的视觉地图点 {$G_{pi}$} 用于构建视觉测量模型。 其基本原理是,利用真值状态将地图点投影至当前图像，参考块与当前块之间的光度误差应当为0. </p><p>要根据测量方程估算反向曝光时间 $τ_k$，将初始反向曝光时间固定为 $τ_0$ &#x3D; 1 ，以消除方程在所有反向曝光时间都为零时的退化现象。后续帧的估计反向曝光时间是相对于第一帧的曝光时间。测量方程被用于三个层次的视觉更新步骤,估计的状态随后用于生成可视化地图点和更新参考块。</p><h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><p>雷达点云格式</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// roslaunch livox_ros_driver livox_lidar.launch / livox_ros_driver2所有launch</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LivoxPoint</span> &#123;<br>    <span class="hljs-type">float</span> x;<br>    <span class="hljs-type">float</span> y;<br>    <span class="hljs-type">float</span> z;<br>    <span class="hljs-type">uint8_t</span> reflectivity;   <span class="hljs-comment">// 反射率</span><br>    <span class="hljs-type">uint8_t</span> tag;            <span class="hljs-comment">// 标志位</span><br>    <span class="hljs-type">uint8_t</span> line;           <span class="hljs-comment">// 扫描线编号</span><br>&#125;;<br><br><span class="hljs-comment">// roslaunch livox_ros_driver livox_lidar_msg.launch</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CustomMsg</span> &#123;<br>    <span class="hljs-type">uint64_t</span> timebase;      <span class="hljs-comment">// 当前包的基准时间</span><br>    <span class="hljs-type">uint32_t</span> point_num;     <span class="hljs-comment">// 点数</span><br>    <span class="hljs-type">uint8_t</span>  lidar_id;      <span class="hljs-comment">// 雷达ID</span><br>    <span class="hljs-type">uint8_t</span>  rsvd[<span class="hljs-number">3</span>];       <span class="hljs-comment">// 保留</span><br>    std::vector&lt;LivoxPoint&gt; points;<br>&#125;;<br></code></pre></td></tr></table></figure><p>结构体：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StatesGroup</span><br>&#123;<br>    M3D rot_end;     <span class="hljs-comment">// 姿态（旋转矩阵），表示当前时刻的坐标系方向</span><br>    V3D pos_end;     <span class="hljs-comment">// 位置（世界系坐标）</span><br>    V3D vel_end;     <span class="hljs-comment">// 速度（世界系坐标）</span><br>    <span class="hljs-type">double</span> inv_expo_time; <span class="hljs-comment">// 逆曝光时间 (通常和相机或雷达扫描速度相关)</span><br>    V3D bias_g;      <span class="hljs-comment">// 陀螺仪零偏</span><br>    V3D bias_a;      <span class="hljs-comment">// 加速度计零偏</span><br>    V3D gravity;     <span class="hljs-comment">// 重力向量（世界坐标系下的估计）</span><br>    Matrix&lt;<span class="hljs-type">double</span>, DIM_STATE, DIM_STATE&gt; cov; <span class="hljs-comment">// 状态协方差</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="LIVMapper-h-LIVMapper-cpp"><a href="#LIVMapper-h-LIVMapper-cpp" class="headerlink" title="LIVMapper.h &#x2F; LIVMapper.cpp"></a>LIVMapper.h &#x2F; LIVMapper.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">LIVMapper类：<br><span class="hljs-comment">//------------初始化----------------------</span><br><span class="hljs-comment">// 初始化Subscribers和Publishers</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LIVMapper::initializeSubscribersAndPublishers</span><span class="hljs-params">(ros::NodeHandle &amp;nh, image_transport::ImageTransport &amp;it)</span></span>;<br><span class="hljs-comment">// 初始化参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LIVMapper::initializeComponents</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 文件初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initializeFiles</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 对齐重力</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LIVMapper::gravityAlignment</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 处理第一帧</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleFirstFrame</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 选择当前模式（LIO/VIO/LIVO）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stateEstimationAndMapping</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 处理VIO帧外部接口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleVIO</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 处理LIO帧外部接口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleLIO</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 处理IMU数据外部接口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processImu</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    sync_packages → 时间切割LiDAR → 数据准备 → handleLIO → SLAM处理</span><br><span class="hljs-comment">                                          ↓</span><br><span class="hljs-comment">                                      handleVIO → 视觉处理</span><br><span class="hljs-comment">**/</span><br><span class="hljs-comment">// 多传感器数据同步</span><br><span class="hljs-comment">// LIO处理：IMU切分</span><br><span class="hljs-comment">// VIO处理：图像时间同步至LIO</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sync_packages</span><span class="hljs-params">(LidarMeasureGroup &amp;meas)</span></span>;<br><span class="hljs-comment">// 前向传播</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prop_imu_once</span><span class="hljs-params">(StatesGroup &amp;imu_prop_state, <span class="hljs-type">const</span> <span class="hljs-type">double</span> dt, V3D acc_avr, V3D angvel_avr)</span></span>;<br><span class="hljs-comment">// imu状态传播回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">imu_prop_callback</span><span class="hljs-params">(<span class="hljs-type">const</span> ros::TimerEvent &amp;e)</span></span>;<br><br><span class="hljs-comment">// 将LiDAR点云从机体坐标系变换到世界坐标系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transformLidar</span><span class="hljs-params">(<span class="hljs-type">const</span> Eigen::Matrix3d rot, <span class="hljs-type">const</span> Eigen::Vector3d t, <span class="hljs-type">const</span> PointCloudXYZI::Ptr &amp;input_cloud, PointCloudXYZI::Ptr &amp;trans_cloud)</span></span>;<br><span class="hljs-comment">// 将单个点云从机体坐标系变换到世界坐标系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pointBodyToWorld</span><span class="hljs-params">(<span class="hljs-type">const</span> PointType &amp;pi, PointType &amp;po)</span></span>;<br><span class="hljs-comment">// 将单个RGB点云从机体坐标系变换到世界坐标系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RGBpointBodyToWorld</span><span class="hljs-params">(PointType <span class="hljs-type">const</span> *<span class="hljs-type">const</span> pi, PointType *<span class="hljs-type">const</span> po)</span></span>;<br><br><span class="hljs-comment">// 点云回调函数</span><br><span class="hljs-comment">// LivoxPoint格式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">standard_pcl_cbk</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::PointCloud2::ConstPtr &amp;msg)</span></span>;<br><span class="hljs-comment">// CustomMsg格式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">livox_pcl_cbk</span><span class="hljs-params">(<span class="hljs-type">const</span> livox_ros_driver::CustomMsg::ConstPtr &amp;msg_in)</span></span>;<br><br><span class="hljs-comment">// imu回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">imu_cbk</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::Imu::ConstPtr &amp;msg_in)</span></span>;<br><span class="hljs-comment">// 图像回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">img_cbk</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::ImageConstPtr &amp;msg_in)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="IMU-Processing-h-IMU-Processing-cpp"><a href="#IMU-Processing-h-IMU-Processing-cpp" class="headerlink" title="IMU_Processing.h &#x2F; IMU_Processing.cpp"></a>IMU_Processing.h &#x2F; IMU_Processing.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 结构体 class ImuProcess</span><br><br><span class="hljs-comment">//  IMU数据处理主函数（外部接口）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ImuProcess::Process2</span><span class="hljs-params">(LidarMeasureGroup &amp;lidar_meas, StatesGroup &amp;stat, PointCloudXYZI::Ptr cur_pcl_un_)</span></span>;<br><span class="hljs-comment">// 点云去畸变（前向传播+反向传播）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ImuProcess::UndistortPcl</span><span class="hljs-params">(LidarMeasureGroup &amp;lidar_meas, StatesGroup &amp;state_inout, PointCloudXYZI &amp;pcl_out)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="vio-h-vio-cpp"><a href="#vio-h-vio-cpp" class="headerlink" title="vio.h &#x2F; vio.cpp"></a>vio.h &#x2F; vio.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 结构体 VIOManager</span><br><br><span class="hljs-comment">// 更新当前帧，将系统的IMU状态转换为相机帧的变换矩阵</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VIOManager::updateFrameState</span><span class="hljs-params">(StatesGroup state)</span></span>;<br><br><span class="hljs-comment">// 网格</span><br><span class="hljs-comment">// 特征检测：新帧图像 → 网格划分 → 每个网格内检测特征 → 控制特征密度</span><br><span class="hljs-comment">// 特征匹配：当前帧特征 → 定位网格 → 在对应网格内搜索匹配 → 提高匹配效率</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VIOManager::processFrame</span><span class="hljs-params">(cv::Mat &amp;img, vector&lt;pointWithVar&gt; &amp;pg, <span class="hljs-type">const</span> unordered_map&lt;VOXEL_LOCATION, VoxelOctoTree *&gt; &amp;feat_map, <span class="hljs-type">double</span> img_time)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="订阅器"><a href="#订阅器" class="headerlink" title="订阅器"></a>订阅器</h3><p><strong>sub_pcl</strong><br>livox_pcl_cbk() - Livox LiDAR回调函数</p><ul><li>功能：处理Livox品牌激光雷达的自定义点云消息</li><li>消息类型：livox_ros_driver::CustomMsg</li></ul><p>standard_pcl_cbk()- 标准点云回调函数</p><ul><li>功能：处理标准ROS点云消息（如Velodyne、Ouster等）</li><li>消息类型：<code>sensor_msgs::PointCloud2</code></li></ul><p><strong>sub_imu</strong></p><p>imu_cbk() - IMU回调函数</p><ul><li>功能：处理惯性测量单元数据</li><li>消息类型：sensor_msgs::Imu</li></ul><p><strong>sub_img</strong></p><p>img_cbk() - 图像回调函数</p><ul><li>功能：处理相机图像数据</li><li>消息类型：sensor_msgs::Image</li></ul><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LIVMapper <span class="hljs-title">mapper</span><span class="hljs-params">(nh)</span></span>; <br>mapper.<span class="hljs-built_in">initializeSubscribersAndPublishers</span>(nh, it);<br>mapper.<span class="hljs-built_in">run</span>();<br></code></pre></td></tr></table></figure><p><strong>雷达-相机外参用于VIO（第5&#x2F;7部分）</strong></p><p>函数setLidarToCameraExtrinsic</p><h2 id="本机环境-和Fast-Livo2无关"><a href="#本机环境-和Fast-Livo2无关" class="headerlink" title="本机环境 (和Fast-Livo2无关)"></a>本机环境 (和Fast-Livo2无关)</h2><p>只是电脑又坏了。</p><ol><li><p>NVIDIA驱动 : </p><ul><li><p><strong>关闭bios security boot</strong></p></li><li><p>在命令行模式下删除之前安装的nvidia驱动</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Ctrl + Alt + F3<br>sudo systemctl stop gdm<br>sudo apt-get purge &#x27;^nvidia-.*&#x27;<br>sudo apt-get autoremove<br>sudo rm -rf /etc/X11/xorg.conf<br>sudo rm -rf /lib/modules/$(uname -r)/kernel/drivers/video/nvidia*<br>sudo rm -rf /usr/src/nvidia*<br>sudo rm -rf /usr/share/doc/NVIDIA_GLX-1.0*<br>sudo rm -rf /usr/share/man/man1/nvidia*<br>sudo rm -rf /usr/bin/nvidia*<br>sudo rm -rf /etc/modprobe.d/blacklist-nvidia.conf<br></code></pre></td></tr></table></figure></li><li><p>重新安装,选择recommend的版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo ubuntu-drivers devices # 查看可以使用的驱动版本<br></code></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reboot<br></code></pre></td></tr></table></figure></li><li><p>检查</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nvidia-smi<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="NUC环境搭建"><a href="#NUC环境搭建" class="headerlink" title="NUC环境搭建"></a>NUC环境搭建</h2><h3 id="1-修网卡"><a href="#1-修网卡" class="headerlink" title="1. 修网卡"></a>1. 修网卡</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">fast@fast:~/WIFI/backport-iwlwifi$ lspci | grep -i wireless<br>fast@fast:~/WIFI/backport-iwlwifi$ lsmod | grep iwl<br></code></pre></td></tr></table></figure><p>系统没有识别出无线网卡设备,疑似硬件问题.最后使用网线上网.</p><h3 id="2-依赖项"><a href="#2-依赖项" class="headerlink" title="2. 依赖项"></a>2. 依赖项</h3><ul><li><p>PCL&gt;&#x3D;1.8, Follow <a href="https://pointclouds.org/">PCL Installation</a>.</p></li><li><p>Eigen&gt;&#x3D;3.3.4, Follow <a href="https://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen Installation</a>.</p></li><li><p>OpenCV&gt;&#x3D;4.2, Follow <a href="http://opencv.org/">Opencv Installation</a>.</p></li><li><p><a href="https://connecthkuhk-my.sharepoint.com/:u:/g/personal/zhengcr_connect_hku_hk/Ed0Xq17d6udNqYn4vkR71bQBFz0z6_Kru3cz1gD95FIgrQ?e=FPvfkT">MVS-2.1.2</a> </p></li><li><p>Livox_SDK2 :</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/Livox-SDK/Livox-SDK2.git<br>cd ./Livox-SDK2/<br>mkdir build<br>cd build<br>cmake .. &amp;&amp; make -j<br>sudo make install<br></code></pre></td></tr></table></figure></li><li><p>Sophus : Sophus Installation for the non-templated&#x2F;double-only version.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/strasdat/Sophus.git<br>cd Sophus<br>git checkout a621ff<br>mkdir build &amp;&amp; cd build &amp;&amp; cmake ..<br>make<br>sudo make install<br></code></pre></td></tr></table></figure></li><li><p>如果 Sophus 编译报错:</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">/Sophus/sophus/so<span class="hljs-number">2.</span>cpp:<span class="hljs-number">32</span>:<span class="hljs-number">26</span>: error: lvalue required as left operand of assignment<br>   <span class="hljs-number">32</span> |   unit_complex_.<span class="hljs-built_in">real</span>() = <span class="hljs-number">1.</span>;<br>      |                          ^~<br>/Sophus/sophus/so<span class="hljs-number">2.</span>cpp:<span class="hljs-number">33</span>:<span class="hljs-number">26</span>: error: lvalue required as left operand of assignment<br>   <span class="hljs-number">33</span> |   unit_complex_.<span class="hljs-built_in">imag</span>() = <span class="hljs-number">0.</span>;<br>      |                          ^~<br></code></pre></td></tr></table></figure><p>参考<a href="https://github.com/hku-mars/FAST-LIVO2/issues/339">issue</a>,把so2.cpp中30-34行改为:</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">SO2::<span class="hljs-built_in">SO2</span>()<br>&#123;<br>  unit_complex_.<span class="hljs-built_in">real</span>(<span class="hljs-number">1.</span>);<br>  unit_complex_.<span class="hljs-built_in">imag</span>(<span class="hljs-number">0.</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>重新编译即可.</p></li></ul><h3 id="3-工作空间配置"><a href="#3-工作空间配置" class="headerlink" title="3. 工作空间配置"></a>3. 工作空间配置</h3><p>Avia只支持livox_ros_driver</p><p>livox_ros_driver可以不着急先编译,等最后一起build</p><ul><li><p>FAST_LIVO2 : <a href="https://github.com/hku-mars/FAST-LIVO2.git">https://github.com/hku-mars/FAST-LIVO2.git</a></p></li><li><p>livox_ros_ driver :  <a href="https://github.com/xuankuzcr/LIV_handhold.git">https://github.com/xuankuzcr/LIV_handhold.git</a></p><p> <a href="#change">&lt;说明&gt;</a>硬同步需要使用这个github库中的livox_ros_driver,<strong>对比官方,这里做了硬同步的改动，增加了对共享内存写入时间戳的功能</strong> </p></li><li><p>mvs_ros_pkg : <a href="https://github.com/xuankuzcr/LIV_handhold.git">https://github.com/xuankuzcr/LIV_handhold.git</a> <a name="mvs_ros_pkg"></a></p><p> &lt;说明&gt;硬同步需要使用这个github库中的相机ros驱动</p></li><li><p>rpg_vikit : <a href="https://github.com/xuankuzcr/rpg_vikit.git">https://github.com/xuankuzcr/rpg_vikit.git</a> (使用这个url,否则编译时出错)</p></li></ul><h3 id="4-Build"><a href="#4-Build" class="headerlink" title="4. Build"></a>4. Build</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd ~/fast_livo2_ws/<br>catkin_make<br>source ~/fast_livo2_ws/devel/setup.bash<br></code></pre></td></tr></table></figure><p>​<a name="change"></a></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li><p>关于<a href="https://github.com/xuankuzcr/LIV_handhold">LIV_handhold</a>中<strong>livox_ros_driver</strong>的改动</p><p>使用meld对比两份文件夹 ,  新的livox_ros_driver增加了共享内存以及对共享内存写入时间戳的功能.</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">+ livox_ros_driver.cpp<br> <span class="hljs-comment">// 将文件映射为一个共享内存区域，大小为sizeof(time_stamp)，通过指针pointt可以直接读写它。</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *user_name = <span class="hljs-built_in">getlogin</span>();<br>      std::string path_for_time_stamp = <span class="hljs-string">&quot;/home/&quot;</span> + std::<span class="hljs-built_in">string</span>(user_name) + <span class="hljs-string">&quot;/timeshare&quot;</span>;<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *shared_file_name = path_for_time_stamp.<span class="hljs-built_in">c_str</span>();<br>      <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(shared_file_name, O_CREAT | O_RDWR | O_TRUNC, <span class="hljs-number">0666</span>);<br>      <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">ERR_EXIT</span>(<span class="hljs-string">&quot;open&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open code: %d\n&quot;</span>, fd);<br>      &#125;<br>      <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-built_in">sizeof</span>(time_stamp) * <span class="hljs-number">1</span>, SEEK_SET);<br>      <span class="hljs-built_in">write</span>(fd, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">1</span>);<br>      pointt = (time_stamp *)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">sizeof</span>(time_stamp) * <span class="hljs-number">1</span>,<br>                                  PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li><p>关于<a href="https://github.com/xuankuzcr/LIV_handhold">LIV_handhold</a>中<strong>livox_ros_driver2</strong>的改动</p><p>新的livox_ros_driver2增加了共享内存以及对共享内存写入时间戳的功能.</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">+lddc.cpp<br>    <span class="hljs-comment">// 实现了用一个普通文件作为共享内存的载体，进程间可以通过映射该文件进行数据共享。</span><br>    <span class="hljs-comment">// 结构体time_stamp用于在多个进程（或设备驱动与应用程序）间共享硬件时间戳。</span><br>    <span class="hljs-comment">//******************************************************************** add code</span><br>    <span class="hljs-keyword">if</span> (isOpended == <span class="hljs-literal">false</span>)<br>    &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *user_name = <span class="hljs-built_in">getlogin</span>();<br>      std::string path_for_time_stamp = <span class="hljs-string">&quot;/home/&quot;</span> + std::<span class="hljs-built_in">string</span>(user_name) + <span class="hljs-string">&quot;/timeshare&quot;</span>;<br><br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *shared_file_name = path_for_time_stamp.<span class="hljs-built_in">c_str</span>();<br>      <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(shared_file_name, O_CREAT | O_RDWR | O_TRUNC, <span class="hljs-number">0666</span>);<br>      <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)<br>      &#123;<br>        <span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;open failed\n&quot;</span>);<br>        isOpended = <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;open code: %d\n&quot;</span>, fd);<br>        isOpended = <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-built_in">sizeof</span>(time_stamp) * <span class="hljs-number">1</span>, SEEK_SET);<br>      <span class="hljs-built_in">write</span>(fd, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">1</span>);<br>      pointt = (time_stamp *)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">sizeof</span>(time_stamp) * <span class="hljs-number">1</span>,<br>                                  PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//********************************************************************</span><br></code></pre></td></tr></table></figure><h2 id="STM32硬同步"><a href="#STM32硬同步" class="headerlink" title="STM32硬同步"></a>STM32硬同步</h2><h3 id="1-材料"><a href="#1-材料" class="headerlink" title="1. 材料"></a>1. 材料</h3><ul><li>工程文件 : <a href="https://github.com/xuankuzcr/LIV_handhold/tree/main/stm32_timersync-open">stm32_timersync-open</a></li><li>烧录器 : ST-LINK V2</li><li>STM32F103C8T6</li><li>TTL to USB</li><li>TTL to RS485</li></ul><h3 id="2-原理图"><a href="#2-原理图" class="headerlink" title="2. 原理图"></a>2. 原理图</h3><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/15.png" alt="图9-硬件同步方案"></p><p style="text-align:center;">图9-硬件同步方案</p><p>Livox_avia不支持直接读取GPRMC格式的指令,mid360支持直接读取.如果使用mid360连线原理图将会改变.本篇只考虑Livox_avia.</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/16.png" alt="图10-硬件同步原理图"></p><p style="text-align:center;">图10-硬件同步原理图</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/19.png" alt="图11-时间对齐原理图"></p><p style="text-align:center;">图11-时间对齐原理图</p><h3 id="3-硬件连线图"><a href="#3-硬件连线图" class="headerlink" title="3. 硬件连线图"></a>3. 硬件连线图</h3><p>**硬件连线参考图 : ** </p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/31.png" alt="图12-硬件连线参考图"></p><p style="text-align:center;">图12-硬件连线参考图</p><p>相机线说明 :</p><p>相机的电源及 I&#x2F;O 接口为 6-pin P7 接口。</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/32.png" alt="图13-相机同步线线序图"></p><p style="text-align:center;">图13-相机同步线线序图</p><p>Livox Converter 2.0 同步线说明 :</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/33.png" alt="图14-雷达同步线线序图"></p><p style="text-align:center;">图14-雷达同步线线序图</p><h3 id="4-串口绑定"><a href="#4-串口绑定" class="headerlink" title="4. 串口绑定"></a>4. 串口绑定</h3><p>为了赋予特定串口权限,且防止串口在ubuntu下名称跳变，本片介绍ubuntu系统下如何绑定串口。</p><h4 id="1-建立udev规则"><a href="#1-建立udev规则" class="headerlink" title="1. 建立udev规则"></a>1. 建立udev规则</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /etc/udev/rules.d/my_rule.rules<br></code></pre></td></tr></table></figure><h4 id="2-获取串口设备详情"><a href="#2-获取串口设备详情" class="headerlink" title="2. 获取串口设备详情"></a>2. 获取串口设备详情</h4><p>列出当前串口设备。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls /dev/ttyUSB*<br></code></pre></td></tr></table></figure><p>以ttyUSB0为例。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">udevadm info --attribute-walk --name=/dev/ttyUSB0<br></code></pre></td></tr></table></figure><p>获得详细信息，我习惯以第四行&#x3D;&#x3D;looking …&#x3D;&#x3D;以下的信息作为信息绑定的依靠。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">looking at device &#x27;/devices/pci0000:00/0000:00:14.0/usb3/3-3/3-3:1.0/ttyUSB0/tty/ttyUSB0&#x27;:<br>    KERNEL==&quot;ttyUSB0&quot;<br>    SUBSYSTEM==&quot;tty&quot;<br>    DRIVER==&quot;&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0/usb3/3-3/3-3:1.0/ttyUSB0&#x27;:<br>    KERNELS==&quot;ttyUSB0&quot;<br>    SUBSYSTEMS==&quot;usb-serial&quot;<br>    DRIVERS==&quot;cp210x&quot;<br>    ATTRS&#123;port_number&#125;==&quot;0&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0/usb3/3-3/3-3:1.0&#x27;:<br>    KERNELS==&quot;3-3:1.0&quot;<br>    SUBSYSTEMS==&quot;usb&quot;<br>    DRIVERS==&quot;cp210x&quot;<br>    ATTRS&#123;interface&#125;==&quot;CP2102 USB to UART Bridge Controller&quot;<br>    ATTRS&#123;authorized&#125;==&quot;1&quot;<br>    ATTRS&#123;bAlternateSetting&#125;==&quot; 0&quot;<br>    ATTRS&#123;bInterfaceProtocol&#125;==&quot;00&quot;<br>    ATTRS&#123;bNumEndpoints&#125;==&quot;02&quot;<br>    ATTRS&#123;supports_autosuspend&#125;==&quot;1&quot;<br>    ATTRS&#123;bInterfaceSubClass&#125;==&quot;00&quot;<br>    ATTRS&#123;bInterfaceClass&#125;==&quot;ff&quot;<br>    ATTRS&#123;bInterfaceNumber&#125;==&quot;00&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0/usb3/3-3&#x27;:<br>    KERNELS==&quot;3-3&quot;<br>    SUBSYSTEMS==&quot;usb&quot;<br>    DRIVERS==&quot;usb&quot;<br>    ATTRS&#123;idProduct&#125;==&quot;ea60&quot;<br>    ATTRS&#123;bConfigurationValue&#125;==&quot;1&quot;<br>    ATTRS&#123;tx_lanes&#125;==&quot;1&quot;<br>    ATTRS&#123;bNumInterfaces&#125;==&quot; 1&quot;<br>    ATTRS&#123;maxchild&#125;==&quot;0&quot;<br>    ATTRS&#123;avoid_reset_quirk&#125;==&quot;0&quot;<br>    ATTRS&#123;devpath&#125;==&quot;3&quot;<br>    ATTRS&#123;bDeviceSubClass&#125;==&quot;00&quot;<br>    ATTRS&#123;bDeviceClass&#125;==&quot;00&quot;<br>    ATTRS&#123;ltm_capable&#125;==&quot;no&quot;<br>    ATTRS&#123;quirks&#125;==&quot;0x0&quot;<br>    ATTRS&#123;serial&#125;==&quot;0001&quot;<br>    ATTRS&#123;bDeviceProtocol&#125;==&quot;00&quot;<br>    ATTRS&#123;speed&#125;==&quot;12&quot;<br>    ATTRS&#123;busnum&#125;==&quot;3&quot;<br>    ATTRS&#123;bNumConfigurations&#125;==&quot;1&quot;<br>    ATTRS&#123;manufacturer&#125;==&quot;Silicon Labs&quot;<br>    ATTRS&#123;bMaxPacketSize0&#125;==&quot;64&quot;<br>    ATTRS&#123;version&#125;==&quot; 1.10&quot;<br>    ATTRS&#123;bcdDevice&#125;==&quot;0100&quot;<br>    ATTRS&#123;devnum&#125;==&quot;6&quot;<br>    ATTRS&#123;rx_lanes&#125;==&quot;1&quot;<br>    ATTRS&#123;authorized&#125;==&quot;1&quot;<br>    ATTRS&#123;removable&#125;==&quot;removable&quot;<br>    ATTRS&#123;product&#125;==&quot;CP2102 USB to UART Bridge Controller&quot;<br>    ATTRS&#123;configuration&#125;==&quot;&quot;<br>    ATTRS&#123;bMaxPower&#125;==&quot;100mA&quot;<br>    ATTRS&#123;urbnum&#125;==&quot;12&quot;<br>    ATTRS&#123;bmAttributes&#125;==&quot;80&quot;<br>    ATTRS&#123;idVendor&#125;==&quot;10c4&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0/usb3&#x27;:<br>    KERNELS==&quot;usb3&quot;<br>    SUBSYSTEMS==&quot;usb&quot;<br>    DRIVERS==&quot;usb&quot;<br>    ATTRS&#123;devpath&#125;==&quot;0&quot;<br>    ATTRS&#123;authorized_default&#125;==&quot;1&quot;<br>    ATTRS&#123;ltm_capable&#125;==&quot;no&quot;<br>    ATTRS&#123;speed&#125;==&quot;480&quot;<br>    ATTRS&#123;bNumInterfaces&#125;==&quot; 1&quot;<br>    ATTRS&#123;configuration&#125;==&quot;&quot;<br>    ATTRS&#123;bMaxPower&#125;==&quot;0mA&quot;<br>    ATTRS&#123;bmAttributes&#125;==&quot;e0&quot;<br>    ATTRS&#123;avoid_reset_quirk&#125;==&quot;0&quot;<br>    ATTRS&#123;serial&#125;==&quot;0000:00:14.0&quot;<br>    ATTRS&#123;manufacturer&#125;==&quot;Linux 5.15.0-139-generic xhci-hcd&quot;<br>    ATTRS&#123;busnum&#125;==&quot;3&quot;<br>    ATTRS&#123;interface_authorized_default&#125;==&quot;1&quot;<br>    ATTRS&#123;bConfigurationValue&#125;==&quot;1&quot;<br>    ATTRS&#123;bDeviceClass&#125;==&quot;09&quot;<br>    ATTRS&#123;bMaxPacketSize0&#125;==&quot;64&quot;<br>    ATTRS&#123;quirks&#125;==&quot;0x0&quot;<br>    ATTRS&#123;bcdDevice&#125;==&quot;0515&quot;<br>    ATTRS&#123;idProduct&#125;==&quot;0002&quot;<br>    ATTRS&#123;tx_lanes&#125;==&quot;1&quot;<br>    ATTRS&#123;rx_lanes&#125;==&quot;1&quot;<br>    ATTRS&#123;product&#125;==&quot;xHCI Host Controller&quot;<br>    ATTRS&#123;urbnum&#125;==&quot;98&quot;<br>    ATTRS&#123;removable&#125;==&quot;unknown&quot;<br>    ATTRS&#123;bNumConfigurations&#125;==&quot;1&quot;<br>    ATTRS&#123;devnum&#125;==&quot;1&quot;<br>    ATTRS&#123;bDeviceProtocol&#125;==&quot;01&quot;<br>    ATTRS&#123;version&#125;==&quot; 2.00&quot;<br>    ATTRS&#123;idVendor&#125;==&quot;1d6b&quot;<br>    ATTRS&#123;maxchild&#125;==&quot;12&quot;<br>    ATTRS&#123;bDeviceSubClass&#125;==&quot;00&quot;<br>    ATTRS&#123;authorized&#125;==&quot;1&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0&#x27;:<br>    KERNELS==&quot;0000:00:14.0&quot;<br>    SUBSYSTEMS==&quot;pci&quot;<br>    DRIVERS==&quot;xhci_hcd&quot;<br>    ATTRS&#123;local_cpus&#125;==&quot;ffff&quot;<br>    ATTRS&#123;dma_mask_bits&#125;==&quot;64&quot;<br>    ATTRS&#123;power_state&#125;==&quot;D0&quot;<br>    ATTRS&#123;device&#125;==&quot;0x51ed&quot;<br>    ATTRS&#123;subsystem_device&#125;==&quot;0x3037&quot;<br>    ATTRS&#123;ari_enabled&#125;==&quot;0&quot;<br>    ATTRS&#123;class&#125;==&quot;0x0c0330&quot;<br>    ATTRS&#123;msi_bus&#125;==&quot;1&quot;<br>    ATTRS&#123;vendor&#125;==&quot;0x8086&quot;<br>    ATTRS&#123;revision&#125;==&quot;0x01&quot;<br>    ATTRS&#123;local_cpulist&#125;==&quot;0-15&quot;<br>    ATTRS&#123;label&#125;==&quot;Onboard - Other&quot;<br>    ATTRS&#123;numa_node&#125;==&quot;-1&quot;<br>    ATTRS&#123;driver_override&#125;==&quot;(null)&quot;<br>    ATTRS&#123;consistent_dma_mask_bits&#125;==&quot;64&quot;<br>    ATTRS&#123;subsystem_vendor&#125;==&quot;0x8086&quot;<br>    ATTRS&#123;dbc&#125;==&quot;disabled&quot;<br>    ATTRS&#123;enable&#125;==&quot;1&quot;<br>    ATTRS&#123;broken_parity_status&#125;==&quot;0&quot;<br>    ATTRS&#123;irq&#125;==&quot;145&quot;<br>    ATTRS&#123;d3cold_allowed&#125;==&quot;1&quot;<br>    ATTRS&#123;index&#125;==&quot;7&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00&#x27;:<br>    KERNELS==&quot;pci0000:00&quot;<br>    SUBSYSTEMS==&quot;&quot;<br>    DRIVERS==&quot;&quot;<br>    ATTRS&#123;waiting_for_supplier&#125;==&quot;0&quot;<br></code></pre></td></tr></table></figure><h4 id="3-在udev规则下写入串口信息"><a href="#3-在udev规则下写入串口信息" class="headerlink" title="3. 在udev规则下写入串口信息"></a>3. 在udev规则下写入串口信息</h4><p>如果没有相同ID设备的话可直接写入。</p><p>其中<code>KERNEL==&quot;ttyUSB*&quot;</code>表明绑定的设备是串口，<code>ATTRS&#123;idVendor&#125;==&quot;10c4&quot;, ATTRS&#123;idProduct&#125;==&quot;ea60&quot;</code>是Step2中设备的信息，<code>MODE:=&quot;0777&quot;</code>给予设备最高权限，<code>SYMLINK+=&quot;ttyUSB_TTL2USB&quot;</code>为绑定后设备的名称。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">KERNEL==&quot;ttyUSB*&quot;, ATTRS&#123;idVendor&#125;==&quot;10c4&quot;, ATTRS&#123;idProduct&#125;==&quot;ea60&quot;, MODE:=&quot;0777&quot;, SYMLINK+=&quot;ttyUSB_TTL2USB&quot;<br></code></pre></td></tr></table></figure><p>若有相同ID设备，则可再添加<code>ATTRS&#123;devpath&#125;==&quot;5.2&quot;</code>信息，该量一般与设备与电脑链接的端口号有关。</p><h4 id="4-重启udev"><a href="#4-重启udev" class="headerlink" title="4. 重启udev"></a>4. 重启udev</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo service udev reload<br>sudo service udev restart<br></code></pre></td></tr></table></figure><p>再次查看串口设备，即可看到绑定成功后的名称。若还没成功，可尝试重启电脑或者热插拔设备。</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/50.jpg" alt="图15-绑定串口显示"></p><p style="text-align:center;">图15-绑定串口显示</p><h3 id="5-雷达设置"><a href="#5-雷达设置" class="headerlink" title="5. 雷达设置"></a>5. 雷达设置</h3><p>雷达选型 : Livox AVIA</p><p>转换器 : Livox Converter 2.0</p><h4 id="Livox雷达时间同步说明"><a href="#Livox雷达时间同步说明" class="headerlink" title="Livox雷达时间同步说明"></a>Livox雷达时间同步说明</h4><p>参考:<a href="https://github.com/Livox-SDK/Livox-SDK/wiki/livox-device-time-synchronization-manual-cn#%E9%99%84%E5%BD%95">https://github.com/Livox-SDK/Livox-SDK/wiki/livox-device-time-synchronization-manual-cn#%E9%99%84%E5%BD%95</a></p><p>Livox设备支持3种时间同步方式：</p><ul><li>PTP：IEEE 1588v2.0 PTP 网络协议同步；</li><li>GPS：秒脉冲+GPRMC时间数据，组成GPS时间同步方式；</li><li>PPS：秒脉冲同步，需要上层应用程序通过其他途径（如：uart）获取每个脉冲的时间信息，并修正点云时间。</li></ul><p>FAST-LIO只涉及GPS和PPS两种,只介绍这两种。</p><h5 id="GPS"><a href="#GPS" class="headerlink" title="GPS"></a>GPS</h5><p>GPS时钟源的PPS端口每秒发送一次硬件脉冲（PPS信号），随后数据端口发送一次对应这个脉冲上升沿的时间信息（GPRMC格式）。Livox设备接收到PPS信号上升沿，并由GPRMC数据解析出正确的时间信息后，会设置点云时间为GPS时间，并保持此时间基准持续累加，来实现和GPS设备的时间同步。</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/17.png" alt="图17-GPS信号示意图"></p><p style="text-align:center;">图17-GPS信号示意图</p><p><strong>Livox Converter 2.0</strong>将GPS模块的时间信号（GPRMC）通过TTL转usb模块接入PC，PPS信号接入LiDAR转接盒同步口（Sync Port）。</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/18.png" alt="图18-Livox Converter 2.0连线图"></p><p style="text-align:center;">图18-Livox Converter 2.0连线图</p><h5 id="PPS"><a href="#PPS" class="headerlink" title="PPS"></a>PPS</h5><p>Livox LiDAR每次接收到PPS信号的上升沿后，会将当前时刻的点云时间置为0，然后重新开始计时直到下一个PPS脉冲到来,利用这个特性，来实现PPS脉冲对LiDAR时间的同步。</p><p>伪代码:</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// PPS Time Synchronization</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span> lidar_time_last;<br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span> lidar_time_real;<br><br><span class="hljs-comment">// 1. Read the PPS rising edge time, Unit is nanosecond.</span><br><span class="hljs-type">uint64_t</span> pps_time_ns = get_pps_rising_nsecond();<br><span class="hljs-comment">// 2. Read LiDAR point time, Unit is nanosecond.</span><br><span class="hljs-type">uint64_t</span> lidar_time = get_lidar_pack_time();<br><span class="hljs-comment">// 3. Update real time.</span><br><span class="hljs-keyword">if</span> (lidar_time &lt; lidar_time_last)<br>&#123;<br>    <span class="hljs-comment">//LiDAR time jump indicates the generation of PPS rising edge.</span><br>    lidar_time_real = pps_time_ns + lidar_time%(<span class="hljs-number">1000000000</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    lidar_time_real += lidar_time - lidar_time_last;<br>&#125;<br><span class="hljs-comment">//Update history</span><br>lidar_time_last = lidar_time;<br></code></pre></td></tr></table></figure><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><h4 id="1-安装Livox-Viewer"><a href="#1-安装Livox-Viewer" class="headerlink" title="1. 安装Livox Viewer"></a>1. 安装Livox Viewer</h4><p> Livox Viewer 0.10.0(64bit) : <a href="https://www.livoxtech.com/downloads">https://www.livoxtech.com/downloads</a></p><blockquote><p>注：Livox Viewer2并不支持Avia</p></blockquote><p>以太网设置:</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/47.jpg" alt="图19-Livox雷达以太网设置"></p><p style="text-align:center;">图19-Livox雷达以太网设置</p><p>点击左上角播放按钮,出现点云.</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/48.jpg" alt="图20-Livox Viewer点云示意图"></p><p style="text-align:center;">图20-Livox Viewer点云示意图</p><p>插上硬同步设备后,查看雷达的连接转态和数据的读取状态，来确认雷达是否已进入PPS同步状态 <strong>(在这里不能修改TIme Sync &#x2F; PPS State,此设置为连接硬同步后自动触发)</strong></p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/49.png" alt="图21-Livox Viewer设置状态图"></p><p style="text-align:center;">图21-Livox Viewer设置状态图</p><h4 id="2-修改livox-lidar-config-json"><a href="#2-修改livox-lidar-config-json" class="headerlink" title="2. 修改livox_lidar_config.json"></a>2. 修改livox_lidar_config.json</h4><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/51.jpg" alt="图22-livox_lidar_config.json参数设置"></p><p style="text-align:center;">图22-livox_lidar_config.json参数设置</p><h4 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs SHELL">roslaunch livox_ros_driver livox_lidar_rviz.launch<br></code></pre></td></tr></table></figure><p>可以在自动弹出来的rviz中查看是否有点云正常输出和显示</p><h3 id="6-相机设置"><a href="#6-相机设置" class="headerlink" title="6. 相机设置"></a>6. 相机设置</h3><p>相机 : 海康相机MV-CS020-10UC</p><p>驱动 : MVS_STD_V3.0.1</p><h4 id="1-安装驱动"><a href="#1-安装驱动" class="headerlink" title="1. 安装驱动"></a>1. 安装驱动</h4><p>海康威视工业相机SDK的ros驱动依赖MVS的库文件，先安装MVS客户端.</p><p>官方下载地址：<a href="https://gitee.com/link?target=https://www.hikrobotics.com/cn/machinevision/service/download/?module=0">https://www.hikrobotics.com/cn/machinevision/service/download/?module=0</a></p><h4 id="2-下载和编译相机的雷达ros驱动"><a href="#2-下载和编译相机的雷达ros驱动" class="headerlink" title="2. 下载和编译相机的雷达ros驱动"></a>2. 下载和编译相机的雷达ros驱动</h4><p> (见<a href="#mvs_ros_pkg">NUC环境搭建 - 3.工作空间配置</a>)</p><h4 id="3-调整配置文件"><a href="#3-调整配置文件" class="headerlink" title="3. 调整配置文件"></a>3. 调整配置文件</h4><p>路径 : mvs_ros_driver&#x2F;config</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">%YAML:1.0</span><br><br><span class="hljs-comment">#--------------------------------------------------------------------------------------------</span><br><span class="hljs-comment"># Camera Parameters. Adjust them!</span><br><span class="hljs-comment">#--------------------------------------------------------------------------------------------</span><br><span class="hljs-attr">SerialNumber:</span> <span class="hljs-string">&quot;DA2099368&quot;</span> <span class="hljs-comment"># Not needed for single camera. Specify serial number for multiple cameras. </span><br><span class="hljs-attr">TopicName:</span> <span class="hljs-string">&quot;left_camera/image&quot;</span><br><br><span class="hljs-attr">TriggerEnable:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 0 stands for Off, 1 stands for On</span><br><br><span class="hljs-attr">ExposureAutoMode:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 0 stands for Off, 1 stands for Once, 2 stands for Continues</span><br><span class="hljs-attr">ExposureTime:</span> <span class="hljs-number">5000</span> <span class="hljs-comment"># us</span><br><br><span class="hljs-comment"># ExposureAutoMode: 2</span><br><span class="hljs-comment"># AutoExposureTimeLower: 100</span><br><span class="hljs-comment"># AutoExposureTimeUpper: 20000</span><br><br><span class="hljs-attr">image_scale:</span> <span class="hljs-number">0.5</span> <span class="hljs-comment"># 1 0.5</span><br><span class="hljs-attr">GainAuto:</span> <span class="hljs-number">2</span> <span class="hljs-comment"># Gain Auto, 0 stands for Off, 1 stands for Once, 2 stands for Continues</span><br><span class="hljs-attr">Gain:</span> <span class="hljs-number">15</span> <span class="hljs-comment"># min: 0   max: 17.0166</span><br><span class="hljs-attr">Gamma:</span> <span class="hljs-number">0.7</span>  <span class="hljs-comment"># min: 0   max: 17.0166</span><br><span class="hljs-attr">GammaSelector:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 0 stands for user, 1 stands for sRGB</span><br><span class="hljs-comment"># GammaEnable: 1</span><br><br><span class="hljs-attr">PixelFormat:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 0: RGB8, 1: BayerRG8, 2: BayerRG12Packed, 3: BayerGB12Packed, 4: BayerGB8</span><br></code></pre></td></tr></table></figure><p>最重要的参数是<strong>PixelFormat</strong>,需要根据相机型号调整。遍历一遍看哪个数值可用当然可以,代价是报错的时候不能理解其中原因,会造成很多麻烦。</p><p><strong>如何找到适合本相机的PixelFormat :</strong></p><ul><li>查阅海康相机官网<a href="https://www.hikrobotics.com/cn/machinevision/productdetail/?id=12379">https://www.hikrobotics.com/cn/machinevision/productdetail/?id=12379</a></li></ul><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/41.png" alt="图23-相机支持像素格式"></p><p style="text-align:center;">图23-相机支持像素格式</p><p>​看似这个相机支持RGB8 &#x2F; BayerRG8 &#x2F; BayerRG12Packed, PixelFormat选择0&#x2F;1&#x2F;2都可以, 实则不然。</p><p>​当选择1或2的时候,运行<code>roslaunch mvs_ros_driver mvs_camera_trigger.launch</code>时, 出现报错 :</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/42.jpg" alt="图24-mvs_camera_trigger报错图"></p><p style="text-align:center;">图24-mvs_camera_trigger报错图</p><p>​针对这个报错, 打开MVS的官方图形化界面看一下 : </p><p>​图形化界面参数太多了,再查阅海康机器人USB3.0工业面阵相机用户手册,发现Gamma参数应该在Analog Control 属性中.</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/43.png" alt="图25-海康相机用户手册详细参数"></p><p style="text-align:center;">图25-海康相机用户手册详细参数</p><p>​在Bayer RG 8 &#x2F; BayerRG12Packed模式下 , 没有Gamma这个参数 ．只有在RGB8模式下才有Gamma参数．</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/44.jpg" alt="图26-海康相机图形化界面参数"></p><p style="text-align:center;">图26-海康相机图形化界面参数</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/45.jpg" alt="图27-海康相机图形化界面参数"></p><p style="text-align:center;">图27-海康相机图形化界面参数</p><p>​探究一下原理：</p><ul><li><p>Bayer 格式是原始图像数据（Raw），<code>Bayer RG8</code> 是未经过处理的原始图像数据格式，每个像素仅包含单色信息（红、绿或蓝中的一个）。在这种格式下，图像还没有完成 去马赛克（Demosaicing）、白平衡、Gamma 校正等ISP流程。</p></li><li><p>RGB8 是处理后的彩色图像格式，可以进行Gamma调节．</p><blockquote><p>注 : 如果把yaml文件中的Gamma和GammaSelector注释掉,该驱动包也能正常跑.但是之后我都选择使用<strong>RGB8</strong>格式,故BayerRG8 &#x2F; BayerRG12Packed能否跑完全流程并不确定．</p></blockquote></li></ul><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h4><ul><li><p>如果需要<strong>单独测试相机驱动</strong>,需要把mvs_ros_driver&#x2F;config中的<strong>TriggerEnable参数改为0</strong>,否则节点无图像数据！</p></li><li><p>相机插NUC的<strong>USB3.0</strong>的插口</p></li><li><p>指令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch mvs_ros_pkg mvs_camera_trigger.launch<br></code></pre></td></tr></table></figure><p>rviz中查看图像是否正常输出．</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/46.jpg" alt="图28-mvs_camera_trigger的rviz界面"></p><p style="text-align:center;">图28-mvs_camera_trigger的rviz界面</p></li></ul><h3 id="7-烧录"><a href="#7-烧录" class="headerlink" title="7. 烧录"></a>7. 烧录</h3><ol><li><p>STLINK驱动安装</p><p><a href="https://docs.qq.com/doc/DT2hyS2ZjY21WQkZt">https://docs.qq.com/doc/DT2hyS2ZjY21WQkZt</a></p></li><li><p>硬件连接</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/20.png" alt="图29-烧录硬件连接原理图"></p><p style="text-align:center;">图29-烧录硬件连接原理图</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/21.jpg" alt="图30-实物图(stlink正面)"></p><p style="text-align:center;">图30-实物图(stlink正面)</p></li></ol><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/22.jpg" alt="图31-实物图(stlink侧面)"></p><p style="text-align:center;">图31-实物图(stlink侧面)</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/23.jpg" alt="图32-实物图(stm32背面)"></p><p style="text-align:center;">图32-实物图(stm32背面)</p><ol start="3"><li><p>Keil烧录</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/24.png" alt="图33-烧录步骤-1"></p><p style="text-align:center;">图33-烧录步骤-1</p></li></ol><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/25.png" alt="图34-烧录步骤-2"></p><p style="text-align:center;">图34-烧录步骤-2</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/26.png" alt="图35-烧录步骤-3"></p><p style="text-align:center;">图35-烧录步骤-3</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/27.png" alt="图36-烧录步骤-4"></p><p style="text-align:center;">图36-烧录步骤-4</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/28.png" alt="图37-烧录步骤-5"></p><p style="text-align:center;">图37-烧录步骤-5</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/29.png" alt="图38-烧录步骤-6"></p><p style="text-align:center;">图38-烧录步骤-6</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/30.png" alt="图39-烧录步骤-7"></p><p style="text-align:center;">图39-烧录步骤-7</p><h2 id="标定"><a href="#标定" class="headerlink" title="标定"></a>标定</h2><h3 id="相机内参标定"><a href="#相机内参标定" class="headerlink" title="相机内参标定"></a>相机内参标定</h3><p>张正友平面标定法</p><ol><li><p>准备标定素材</p><p>海康相机不能直接用opencv打开,必须调用mvs_ros_driver包,在自己写的订阅相机图片节点捕获图像.</p><blockquote><p>注意mvs_ros_driver发布图片话题时有scale &#x3D; 0.5,后面标定得到的参数需要*2。</p></blockquote></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">订阅相机图像话题并截图的ros_node</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sensor_msgs/Image.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cv_bridge/cv_bridge.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/filesystem.hpp&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> fs = boost::filesystem;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageCapture</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ImageCapture</span>(ros::NodeHandle&amp; nh, <span class="hljs-type">const</span> std::string&amp; save_dir)<br>        : <span class="hljs-built_in">save_dir_</span>(save_dir)<br>    &#123;<br>        sub_ = nh.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;/left_camera/image&quot;</span>, <span class="hljs-number">1</span>, &amp;ImageCapture::imageCallback, <span class="hljs-keyword">this</span>);<br>        <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;等待按下空格键保存图像，按 &#x27;q&#x27; 退出&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (!fs::<span class="hljs-built_in">exists</span>(save_dir_))<br>        &#123;<br>            fs::<span class="hljs-built_in">create_directories</span>(save_dir_);<br>            <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;创建保存目录: %s&quot;</span>, save_dir_.<span class="hljs-built_in">c_str</span>());<br>        &#125;<br><br>        cv::<span class="hljs-built_in">namedWindow</span>(<span class="hljs-string">&quot;View&quot;</span>, cv::WINDOW_NORMAL);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spin</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">ros::Rate <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<br>        <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>        &#123;<br>            &#123;<br>                <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>                <span class="hljs-keyword">if</span> (!latest_image_.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    cv::<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;View&quot;</span>, latest_image_);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-type">int</span> key = cv::<span class="hljs-built_in">waitKey</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (key == <span class="hljs-number">32</span>) <span class="hljs-comment">// 空格</span><br>            &#123;<br>                <span class="hljs-built_in">saveImage</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&#x27;q&#x27;</span> || key == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            &#123;<br>                <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;用户退出程序&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            ros::<span class="hljs-built_in">spinOnce</span>();<br>            rate.<span class="hljs-built_in">sleep</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ros::Subscriber sub_;<br>    cv::Mat latest_image_;<br>    std::mutex mutex_;<br>    std::string save_dir_;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">imageCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::ImageConstPtr&amp; msg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            cv::Mat image = cv_bridge::<span class="hljs-built_in">toCvShare</span>(msg, <span class="hljs-string">&quot;bgr8&quot;</span>)-&gt;image;<br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>            latest_image_ = image.<span class="hljs-built_in">clone</span>();<br>        &#125;<br>        <span class="hljs-built_in">catch</span> (cv_bridge::Exception&amp; e)<br>        &#123;<br>            <span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;cv_bridge 异常: %s&quot;</span>, e.<span class="hljs-built_in">what</span>());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">saveImage</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        <span class="hljs-keyword">if</span> (!latest_image_.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            std::string filename = save_dir_ + <span class="hljs-string">&quot;/image_&quot;</span> + std::<span class="hljs-built_in">to_string</span>(ros::Time::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">toNSec</span>()) + <span class="hljs-string">&quot;.jpg&quot;</span>;<br>            cv::<span class="hljs-built_in">imwrite</span>(filename, latest_image_);<br>            <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;图像已保存为 %s&quot;</span>, filename.<span class="hljs-built_in">c_str</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">ROS_WARN</span>(<span class="hljs-string">&quot;没有图像可保存&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;image_capture_node&quot;</span>);<br>    <span class="hljs-function">ros::NodeHandle <span class="hljs-title">nh</span><span class="hljs-params">(<span class="hljs-string">&quot;~&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 获取保存目录参数（默认当前目录）</span><br>    std::string save_dir;<br>    nh.<span class="hljs-built_in">param</span>&lt;std::string&gt;(<span class="hljs-string">&quot;save_dir&quot;</span>, save_dir, <span class="hljs-string">&quot;./&quot;</span>);<br><br>    <span class="hljs-function">ImageCapture <span class="hljs-title">ic</span><span class="hljs-params">(nh, save_dir)</span></span>;<br>    ic.<span class="hljs-built_in">spin</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>使用MATLAB进行标定:</li></ol><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/77.png" alt="图40-在matlab中选择标定"></p><p style="text-align:center;">图40-在matlab中选择标定</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/78.png" alt="图41-标定过程"></p><p style="text-align:center;">图41-标定过程</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/79.png" alt="图42-标定得到的数据"></p><p style="text-align:center;">图42-标定得到的数据</p><blockquote><p>得到参数:</p><p>&gt;&gt; cameraParams.IntrinsicMatrix</p><p>   671.9949         0          0         </p><p>   0                672.0204   0  </p><p>  410.0420    323.3874  1.0000 </p><p> &gt;&gt; cameraParams.RadialDistortion     -0.0572    0.0895</p></blockquote><p>对应camera_pinhole.yaml中</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cam_model:</span> <span class="hljs-string">Pinhole</span><br><span class="hljs-attr">cam_width:</span> <span class="hljs-number">1624</span><br><span class="hljs-attr">cam_height:</span> <span class="hljs-number">1240</span><br><span class="hljs-attr">scale:</span> <span class="hljs-number">0.5</span><br><span class="hljs-attr">cam_fx:</span> <span class="hljs-number">1343.9898</span><br><span class="hljs-attr">cam_fy:</span> <span class="hljs-number">1344.0408</span><br><span class="hljs-attr">cam_cx:</span> <span class="hljs-number">820.0840</span><br><span class="hljs-attr">cam_cy:</span> <span class="hljs-number">646.7748</span><br><span class="hljs-attr">cam_d0:</span> <span class="hljs-number">-0.0572</span><br><span class="hljs-attr">cam_d1:</span> <span class="hljs-number">0.0895</span><br><span class="hljs-attr">cam_d2:</span> <span class="hljs-number">0.0</span><br><span class="hljs-attr">cam_d3:</span> <span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><h3 id="外参标定"><a href="#外参标定" class="headerlink" title="外参标定"></a>外参标定</h3><ul><li><p>将相机内参同步到<code>FAST-Calib/config/qr_params.yaml</code>中。</p></li><li><p>运行roslaunch livox_ros_driver livox_lidar_msg<br>在<code>/FAST-Calib/calib_data</code> 下运行 <code> rosbag record -a</code></p></li><li><p>拍照当前相机图片</p><p>标定数据组织如下 (data.txt为自行记录标定数据,不需要预先创建)</p></li></ul><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/80.jpg" alt="图43-FAST-Calib标定数据组织"></p><p style="text-align:center;">图43-FAST-Calib标定数据组织</p><p>运行:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch fast_calib calib.launch<br></code></pre></td></tr></table></figure><blockquote><p>注意修改qr_params.yaml中和filter相关的参数.</p><p>否则会报错 :</p><p>[pcl::TransformationEstimationSVD::estimateRigidTransformation] Number or points in source (0) differs than target (4)! [Result] RMSE:  [computeRMSE] Point cloud sizes do not match, cannot compute RMSE.  -1.0000 m</p></blockquote><p>参考qr_params.yaml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Camera intrinsics  </span><br>  <span class="hljs-comment"># mid360</span><br>  <span class="hljs-comment"># fx: 522.123514287681</span><br>  <span class="hljs-comment"># fy: 522.275153384482</span><br>  <span class="hljs-comment"># cx: 773.466430504725</span><br>  <span class="hljs-comment"># cy: 534.053165700174</span><br>  <span class="hljs-comment"># k1: 0.00324949759262203</span><br>  <span class="hljs-comment"># k2: -0.0171040538369167</span><br>  <span class="hljs-comment"># p1: 0.000669657443377146</span><br>  <span class="hljs-comment"># p2: -0.000350205468789575</span><br><br>  <span class="hljs-comment"># avia</span><br>  <span class="hljs-attr">fx:</span> <span class="hljs-number">1343.9898</span><br>  <span class="hljs-attr">fy:</span> <span class="hljs-number">1344.0408</span><br>  <span class="hljs-attr">cx:</span> <span class="hljs-number">820.0840</span><br>  <span class="hljs-attr">cy:</span> <span class="hljs-number">646.7748</span><br>  <span class="hljs-attr">k1:</span> <span class="hljs-number">-0.0572</span><br>  <span class="hljs-attr">k2:</span> <span class="hljs-number">0.0895</span><br>  <span class="hljs-attr">p1:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">p2:</span> <span class="hljs-number">0</span><br><br>  <span class="hljs-comment"># ouster</span><br>  <span class="hljs-comment"># fx: 1466.16500795563</span><br>  <span class="hljs-comment"># fy: 1465.32657394431</span><br>  <span class="hljs-comment"># cx: 1214.39964380518</span><br>  <span class="hljs-comment"># cy: 1010.97681425650</span><br>  <span class="hljs-comment"># k1: -0.0458344972140773</span><br>  <span class="hljs-comment"># k2: 0.0896961240772692</span><br>  <span class="hljs-comment"># p1: -0.000731746350601389</span><br>  <span class="hljs-comment"># p2: -0.000201478932371979</span><br><br><span class="hljs-comment"># Calibration target parameters</span><br>  <span class="hljs-attr">marker_size:</span> <span class="hljs-number">0.17</span> <span class="hljs-comment"># ArUco marker size (our test data uses 0.16m; adjust to match your marker size)</span><br>  <span class="hljs-attr">delta_width_qr_center:</span> <span class="hljs-number">0.55</span> <span class="hljs-comment"># Half the distance between the centers of two markers in the horizontal direction </span><br>  <span class="hljs-attr">delta_height_qr_center:</span> <span class="hljs-number">0.35</span> <span class="hljs-comment"># Half the distance between the centers of two markers in the vertical direction</span><br>  <span class="hljs-attr">delta_width_circles:</span> <span class="hljs-number">0.5</span> <span class="hljs-comment"># Distance between the centers of two circles in the horizontal direction</span><br>  <span class="hljs-attr">delta_height_circles:</span> <span class="hljs-number">0.4</span> <span class="hljs-comment"># Distance between the centers of two circles in the vertical direction</span><br>  <span class="hljs-attr">circle_radius:</span> <span class="hljs-number">0.12</span> <span class="hljs-comment"># Radius of the circle </span><br><br><span class="hljs-comment"># Distance filter</span><br>  <span class="hljs-attr">x_min:</span> <span class="hljs-number">1.8</span><br>  <span class="hljs-attr">x_max:</span> <span class="hljs-number">2.4</span><br>  <span class="hljs-attr">y_min:</span> <span class="hljs-number">-1</span><br>  <span class="hljs-attr">y_max:</span> <span class="hljs-number">1.0</span><br>  <span class="hljs-attr">z_min:</span> <span class="hljs-number">-0.2</span> <span class="hljs-comment"># avia and mid360: -0.5 ouster: -0.8</span><br>  <span class="hljs-attr">z_max:</span> <span class="hljs-number">2.5</span><br><br><span class="hljs-comment"># Input</span><br>  <span class="hljs-attr">lidar_topic:</span> <span class="hljs-string">&quot;/livox/lidar&quot;</span> <span class="hljs-comment"># /ouster/points /livox/lidar</span><br>  <span class="hljs-attr">bag_path:</span> <span class="hljs-string">&quot;$(find fast_calib)/calib_data/1.bag&quot;</span><br>  <span class="hljs-attr">image_path:</span> <span class="hljs-string">&quot;$(find fast_calib)/calib_data/1.png&quot;</span><br><br><span class="hljs-comment"># Output</span><br>  <span class="hljs-attr">output_path:</span> <span class="hljs-string">&quot;$(find fast_calib)/output&quot;</span><br></code></pre></td></tr></table></figure><p>标定结果:</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/82.png" alt="图44-FAST-Calib标定的点云"></p><p style="text-align:center;">图44-FAST-Calib标定的点云</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/83.png" alt="图45-FAST-Calib标定的彩色图像"></p><p style="text-align:center;">图45-FAST-Calib标定的彩色图像</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/81.png" alt="图46-FAST-Calib得到的数据"></p><p style="text-align:center;">图46-FAST-Calib得到的数据</p><blockquote><p>输出:</p><p>[Result] Extrinsic parameters T_cam_lidar:<br>-0.096829 -0.994963 -0.025938 -1.142585<br>-0.081987  0.033945 -0.996055 -0.876730<br> 0.991919 -0.094320 -0.084861  2.192050<br> 0.000000  0.000000  0.000000  1.000000</p><p>对应的Rcl和Pcl:</p><p>Rcl: [-0.096829, -0.994963, -0.025938,<br>      -0.081987,  0.033945, -0.996055,<br>       0.991919, -0.094320, -0.084861]<br>Pcl: [-1.142585, -0.876730, 2.192050]</p><p>和真值偏移很大,彩色点云图中也有畸变,怀疑是标定板形变,以及标定板没有按照FAST-Calib官方推荐固定并悬挂的原因.</p></blockquote><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="跑包"><a href="#跑包" class="headerlink" title="跑包"></a>跑包</h3><p>HKU_Lecture_Center_02.bag</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch fast_livo mapping_avia.launch<br>rosbag play HKU_Lecture_Center_02.bag<br></code></pre></td></tr></table></figure><h4 id="建图精度"><a href="#建图精度" class="headerlink" title="建图精度"></a>建图精度</h4><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/2.jpg" alt="图47-rviz-1"></p><p style="text-align:center;">图47-rviz-1</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/3.jpg" alt="图48-rviz-2"></p><p style="text-align:center;">图48-rviz-2</p><p>墙面与地面分界线清晰</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/4.jpg" alt="图49-rviz-3"></p><p style="text-align:center;">图49-rviz-3</p><p>图片处理(拉高亮度)后,可以看到墙面纹路,转角非常清晰</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/5.jpg" alt="图50-rviz-4"></p><p style="text-align:center;">图50-rviz-4</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/6.jpg" alt="图51-rviz-5"></p><p style="text-align:center;">图51-rviz-5</p><h4 id="系统资源占用"><a href="#系统资源占用" class="headerlink" title="系统资源占用"></a>系统资源占用</h4><p>运行launch和rviz : 资源主要由rviz占用,且初始rviz config中点云queue数值极大,rviz实时看全局着色点云很卡</p><ol><li>可以把queue值 &#x2F; decay值适当改小;</li><li>可以重建完成后保存pcd文件,通过pcl_viewer（最好+显卡 +opengl）或者cloud compare等软件离线查看;</li><li>使用带gpu的电脑提升实时rviz性能.</li></ol><table><thead><tr><th align="center"><strong>字段</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">PRI</td><td align="center">Priority（优先级）</td></tr><tr><td align="center">NI</td><td align="center">Nice 值（友好度）</td></tr><tr><td align="center">VIRT</td><td align="center">Virtual Memory（虚拟内存大小）</td></tr><tr><td align="center">RES</td><td align="center">Resident Memory（常驻内存） 当前进程实际占用的物理内存大小</td></tr><tr><td align="center">SHR</td><td align="center">Shared Memory（共享内存）</td></tr><tr><td align="center">S</td><td align="center">State（进程状态）R：运行（Running）S：休眠（Sleeping）</td></tr><tr><td align="center">CPU%</td><td align="center">进程当前使用的 CPU 百分比（所有核总和）</td></tr><tr><td align="center">MEM%</td><td align="center">进程使用的物理内存占系统总内存的百分比</td></tr></tbody></table><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/7.jpg" alt="图52-htop查看资源占用"></p><p style="text-align:center;">图52-htop查看资源占用</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/8.jpg" alt="图53-fast-livo2运行占用资源"></p><p style="text-align:center;">图53-fast-livo2运行占用资源</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/9.jpg" alt="图54-fast-livo2的rviz占用资源"></p><p style="text-align:center;">图54-fast-livo2的rviz占用资源</p><p>只运行launch: </p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/10.jpg" alt="图55-只运行launch系统占用资源"></p><p style="text-align:center;">图55-只运行launch系统占用资源</p><h4 id="里程计数据"><a href="#里程计数据" class="headerlink" title="里程计数据"></a>里程计数据</h4><p>纵轴单位(m) ,三条曲线分别是x轴,y轴,z轴里程计数据变化</p><ul><li><p>蓝色-x轴</p></li><li><p>红色-y轴</p></li><li><p>绿色-z轴</p><p>取最后一段平稳曲线部分放大 : 静态波动在厘米级,峰峰值4-6cm</p></li></ul><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/11.jpg" alt="图56-里程计数据总览"></p><p style="text-align:center;">图56-里程计数据总览</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/12.png" alt="图57-里程计数据细节(图56蓝色框部分)"></p><p style="text-align:center;">图57-里程计数据细节(图56蓝色框部分)</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/13.jpg" alt="图58-里程计数据统计(统计图57中数据部分)"></p><p style="text-align:center;">图58-里程计数据统计(统计图57中数据部分)</p><h4 id="处理时间"><a href="#处理时间" class="headerlink" title="处理时间"></a>处理时间</h4><p>参考该帧处理时间数量级</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/14.jpg" alt="图59-处理时间参考"></p><p style="text-align:center;">图59-处理时间参考</p><p>###可行性初测试</p><h4 id="修改参数"><a href="#修改参数" class="headerlink" title="修改参数"></a>修改参数</h4><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/53.png" alt="图60-fast-livo2文件结构"></p><p style="text-align:center;">图60-fast-livo2文件结构</p><ul><li><p>&#x2F;congfig&#x2F;avia.yaml: Avia雷达的参数配置</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/54.png" alt="图61-雷达参数配置文件"></p><p style="text-align:center;">图61-雷达参数配置文件</p><blockquote><ul><li><p><strong>extrin_calib</strong> 中：</p><ol><li><p>extrinsic_T 和extrinsic_R 为雷达到IMU的外参（平移与旋转）</p></li><li><p>Rcl 和 Pcl 为相机到 LiDAR 的旋转矩阵和平移向量, 需要外参标定得出，更新到该位置即可</p><p>-作者在issue中的原回答:</p><p>The extrinsic_R in avia_resize.yaml doesn’t have to be an identity matrix.<br>extrinsic_R represents the rotation matrix of LiDAR frame w.r.t. IMU frame.<br>extrinsic_T represents the translation of LiDAR frame w.r.t. IMU frame.<br>If you set them correctly according to the physical meaning, there should be no wrong alignment of the image and LiDAR scan.</p></li></ol></li><li><p><strong>preprocess</strong> 预处理中：</p><p>1.lidar_type： LiDAR 类型<br> 保持值仍为1 （1：Livox Avia &#x2F; Mid360）</p><p>2.scan_line:  扫描线数量<br> 这里仍为6  （Avia：6，Mid360：4）</p></li><li><p><strong>time_offset</strong>时间偏移: </p><p>-作者在issue中的原回答:</p><p>img_time_offset: 0.1，在我们提供的<a href="https://github.com/xuankuzcr/LIV_handhold">同步方案</a>中，LiDAR会将其时间戳存储到共享内存中，相机帧则会读取内存中最新的时间戳。由于LiDAR scan是一个段时间测量，需要等0.1秒扫完后才会将其header的时间戳存到内存里。此时被触发的相机读取的时间戳实际上是0.1秒前的，因此其真实采样时间戳需要+0.1s。 对于NTU-VIRAL数据集，我设置lidar_time_offset: -0.1，因为该数据集中的LiDAR scan提供的是帧末时间戳，而我们的系统需要的是header时间戳，因此需要-0.1s。这一判断是基于在静止条件下观察EKF估计出的位姿抖动程度得出的。 </p><p>时间没对上不影响，只要在一个时间轴上就可以，evo会用高频的真值轨迹插值出LiDAR或相机采样时刻的位姿的。</p></li></ul></blockquote></li><li><p>&#x2F;congfig&#x2F;camara_pinhole.yaml: 相机的参数配置</p><p>相机选型: 海康相机MV-CS020-10UC</p><p>相机原始图像尺寸大小 : 1624*1240</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs SHELL">cam_model: Pinhole<br>cam_width: 1624<br>cam_height: 1240<br>scale: 0.5<br>cam_fx: 1343.9898<br>cam_fy: 1344.0408<br>cam_cx: 820.0840<br>cam_cy: 646.7748<br>cam_d0: -0.0572<br>cam_d1: 0.0895<br>cam_d2: 0.0<br>cam_d3: 0.0<br></code></pre></td></tr></table></figure><blockquote><p>除了要修改雷达的内参参数外,还要注意<code>cam_width</code> &#x2F; <code>cam_height</code> &#x2F; <code>scale</code> 三个参数 :</p><ul><li>在 mvs_ros_driver &#x2F; config &#x2F; left_camera_trigger.yaml中,scale默认为0.5,camara_pinhole.yaml中的值需要与其保持一致</li><li>mvs_ros_driver中默认不修改相机图像大小,<code>cam_width</code> &#x2F; <code>cam_height</code> 为相机原尺寸</li><li>图像传输时缩放了 0.5 倍，尺寸变为 812×620。</li></ul></blockquote><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>启动雷达：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch livox_ros_driver livox_lidar_msg.launch<br></code></pre></td></tr></table></figure><p>注意：这里我们启动的是Avia雷达的自定义消息格式，而非PointCloud2格式</p><p>启动相机:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch mvs_ros_pkg mvs_camera_trigger.launch<br></code></pre></td></tr></table></figure><p>Fast Livo2主节点启动:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch fast_livo mapping_avia.launch<br></code></pre></td></tr></table></figure><p>建图效果，如下方所示：</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/52.jpg" alt="图62-实时rviz"></p><p style="text-align:center;">图62-实时rviz</p><h4 id="包数据分析"><a href="#包数据分析" class="headerlink" title="包数据分析"></a>包数据分析</h4><p>对齐效果 :</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/56.jpg" alt="图63-包对齐总览"></p><p style="text-align:center;">图63-包对齐总览</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/55.jpg" alt="图64-包对齐细节"></p><p style="text-align:center;">图64-包对齐细节</p><blockquote><ul><li>雷达 &#x2F; imu &#x2F; 图像均为10hz</li></ul></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="完全测试"><a href="#完全测试" class="headerlink" title="完全测试"></a>完全测试</h3><h4 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h4><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/59.jpg" alt="图65-硬件设备设计图"></p><p style="text-align:center;">图65-硬件设备设计图</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/57.jpg" alt="图66-硬件设备实物图"></p><p style="text-align:center;">图66-硬件设备实物图</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/58.jpg" alt="图67-硬件设备实物图"></p><p style="text-align:center;">图67-硬件设备实物图</p><p>设备标注:</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/76.jpeg" alt="图68-硬件设备标注"></p><p style="text-align:center;">图68-硬件设备标注</p><p>设备接线:</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/75.jpeg" alt="图69-设备接线标注"></p><p style="text-align:center;">图69-设备接线标注</p><p>设备供电:</p><ol><li><p>使用一块4S航模电池为雷达 &#x2F; NUC供电</p><ul><li><p>4S航模电池直供NUC</p></li><li><p>4S航模电池经过Livox Converter 2.0降压连接雷达</p></li></ul></li><li><p>NUC为相机 &#x2F; 屏幕供电</p><ol><li><p>使用一块4S航模电池为雷达 &#x2F; NUC供电</p><ol><li>4S航模电池直供NUC</li><li>4S航模电池经过Livox Converter 2.0降压连接雷达</li></ol></li><li><p>NUC为相机 &#x2F; 屏幕供电</p></li></ol></li></ol><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/84.png" alt="图70-设备供电展示"></p><p style="text-align:center;">图70-设备供电展示</p><h4 id="建图精度-1"><a href="#建图精度-1" class="headerlink" title="建图精度"></a>建图精度</h4><p>表现 : 基本可以看清大色块纹理,也许需要更准确的标定数据?<strong>(存疑)</strong></p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/62.jpg" alt="图71-复杂墙面建图总览"></p><p style="text-align:center;">图71-复杂墙面建图总览</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/60.png" alt="图72-复杂墙面建图细节-1"></p><p style="text-align:center;">图72-复杂墙面建图细节-1</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/61.png" alt="图73-复杂墙面建图细节-2"></p><p style="text-align:center;">图73-复杂墙面建图细节-2</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/63.jpg" alt="图74-大号文字墙面建图"></p><p style="text-align:center;">图74-大号文字墙面建图</p><h4 id="回环精度"><a href="#回环精度" class="headerlink" title="回环精度"></a>回环精度</h4><p>表现 : 长距离回环 z轴有1.8m左右的漂移, x轴,y轴回环较为稳定</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/64.png" alt="图75-回环路径展示"></p><p style="text-align:center;">图75-回环路径展示</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/65.png" alt="图76-回环里程计数据-z轴"></p><p style="text-align:center;">图76-回环里程计数据-z轴</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/66.png" alt="图77-回环里程计数据-x轴(蓝)&#x2F;y轴(绿)"></p><p style="text-align:center;">图77-回环里程计数据-x轴(蓝)/y轴(绿)</p><h4 id="不同场景"><a href="#不同场景" class="headerlink" title="不同场景"></a>不同场景</h4><ol><li><p>12分钟+室内+室外</p><p>表现 : 里程计数据基本平滑 , 室外相机有过曝情况 , 代码里没有看到和论文中对应的自动调整曝光的部分,也没有发布自动曝光话题 <strong>(存疑)</strong></p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/71.jpg" alt="图78-室外场景实时rviz"></p><p style="text-align:center;">图78-室外场景实时rviz</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/67.jpg" alt="图79-室外场景里程计数据总览"></p><p style="text-align:center;">图79-室外场景里程计数据总览</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/68.png" alt="图80-室外场景里程计数据细节"></p><p style="text-align:center;">图80-室外场景里程计数据细节</p></li><li><p>室内</p><p>表现 : 玻璃会影响建图精度,从开发空间进入密闭空间(推门走进楼梯间)易造成错误建图</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/72.jpg" alt="图81-室内场景rviz-1"></p><p style="text-align:center;">图81-室内场景rviz-1</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/73.jpg" alt="图82-室内场景rviz-2"></p><p style="text-align:center;">图82-室内场景rviz-2</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/74.jpg" alt="图83-室内场景rviz-3"></p><p style="text-align:center;">图83-室内场景rviz-3</p></li><li><p>楼梯间</p><p>表现 : 跑飞,窗户处建图错误</p><p>推测 : 楼梯间狭窄且全为白墙,特征点少,avia雷达1-2m处点云质量差,存在盲区</p></li></ol><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/69.jpg" alt="图84-楼梯间rviz-1"></p><p style="text-align:center;">图84-楼梯间rviz-1</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/70.jpg" alt="图85-楼梯间rviz-2"></p><p style="text-align:center;">图85-楼梯间rviz-2</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目名称-FAST-LIVO2复现&quot;&gt;&lt;a href=&quot;#项目名称-FAST-LIVO2复现&quot; class=&quot;headerlink&quot; title=&quot;项目名称 : FAST-LIVO2复现&quot;&gt;&lt;/a&gt;项目名称 : FAST-LIVO2复现&lt;/h1&gt;&lt;h2 id=&quot;任</summary>
      
    
    
    
    
    <category term="project" scheme="http://example.com/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>课程设计_背单词软件调试记录</title>
    <link href="http://example.com/2025/05/22/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1_%E8%83%8C%E5%8D%95%E8%AF%8D%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2025/05/22/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1_%E8%83%8C%E5%8D%95%E8%AF%8D%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</id>
    <published>2025-05-21T18:05:19.000Z</published>
    <updated>2025-10-16T06:29:47.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h1><h2 id="5-21测试记录"><a href="#5-21测试记录" class="headerlink" title="5.21测试记录"></a>5.21测试记录</h2><p>目前采用静态网页进行可视化</p><ol><li>用户登录未测试,现在根据用户名区分不同用户,密码不管是什么都能登录</li><li>增加home界面,在该页面可选择词书,查询单词,选择学习&#x2F;复习,复习下选择释义测试&#x2F;拼写测试</li><li>查询单词后可选择标记</li><li>个人中心中增加我的数据&#x2F;学习进度.我的数据子菜单下可展开每个掌握度的单词</li><li>将不同词书隔离,不同词书学习进度独立,学习的单词独立</li><li>在Learning界面中乱序展示所有单词,可进行标记</li></ol><h2 id="5-22测试记录"><a href="#5-22测试记录" class="headerlink" title="5.22测试记录"></a>5.22测试记录</h2><p>目前采用静态网页进行可视化</p><ol><li>增加每日学习部分.</li><li>增加profile中学习成果及可视化部分.</li><li>增加复习规则&#x2F;learn帮助&#x2F;review帮助</li><li>缺少按记忆曲线进行复习部分.</li></ol><p>代码已推送至dictionary的visual分支</p><p>&#96;在home界面可更改每日学习词数</p><h2 id="5-23测试记录"><a href="#5-23测试记录" class="headerlink" title="5.23测试记录"></a>5.23测试记录</h2><p>现在复习的逻辑已经完善了<br>可以在个人中心看到今日学习数据&#x2F;复习曲线&#x2F;待复习列表,复习只会在当天对应复习列表的词汇中抽取</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;调试记录&quot;&gt;&lt;a href=&quot;#调试记录&quot; class=&quot;headerlink&quot; title=&quot;调试记录&quot;&gt;&lt;/a&gt;调试记录&lt;/h1&gt;&lt;h2 id=&quot;5-21测试记录&quot;&gt;&lt;a href=&quot;#5-21测试记录&quot; class=&quot;headerlink&quot; title=&quot;5</summary>
      
    
    
    
    
    <category term="课设" scheme="http://example.com/tags/%E8%AF%BE%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>Path_planning_learning</title>
    <link href="http://example.com/2025/04/06/Path-planning-learning/"/>
    <id>http://example.com/2025/04/06/Path-planning-learning/</id>
    <published>2025-04-06T10:04:20.000Z</published>
    <updated>2025-05-18T16:26:24.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h1><h2 id="前端-路径寻找"><a href="#前端-路径寻找" class="headerlink" title="前端:路径寻找"></a>前端:路径寻找</h2><h3 id="基于搜索"><a href="#基于搜索" class="headerlink" title="基于搜索"></a>基于搜索</h3><ul><li>图搜索基础</li><li>Dijkstra and A*</li><li>Jump Point Search</li></ul><h3 id="基于采样"><a href="#基于采样" class="headerlink" title="基于采样"></a>基于采样</h3><ul><li>Probabilstic Road Map</li><li>RRT</li><li>RRT* &#x2F; Informed RRT</li></ul><h3 id="基于运动学动态路径寻找"><a href="#基于运动学动态路径寻找" class="headerlink" title="基于运动学动态路径寻找"></a>基于运动学动态路径寻找</h3><ul><li>State-state Boundary Value Optimal Control Problem</li><li>State Lattic Search</li><li>Kinodynamic RRT*</li><li>Hybrid A*</li></ul><h2 id="后端-轨迹生成"><a href="#后端-轨迹生成" class="headerlink" title="后端:轨迹生成"></a>后端:轨迹生成</h2><h3 id="MINIMUN-SNAP-TRAJECTORY-GENERATION"><a href="#MINIMUN-SNAP-TRAJECTORY-GENERATION" class="headerlink" title="MINIMUN SNAP TRAJECTORY GENERATION"></a>MINIMUN SNAP TRAJECTORY GENERATION</h3><h3 id="SOFT-AND-HARD-CONSTRAINED-TRAJECTORY-OPTIMIZATION"><a href="#SOFT-AND-HARD-CONSTRAINED-TRAJECTORY-OPTIMIZATION" class="headerlink" title="SOFT AND HARD CONSTRAINED TRAJECTORY OPTIMIZATION"></a>SOFT AND HARD CONSTRAINED TRAJECTORY OPTIMIZATION</h3><h1 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h1><h2 id="Occupancy-grid-map"><a href="#Occupancy-grid-map" class="headerlink" title="Occupancy grid map"></a>Occupancy grid map</h2><p>github:<a href="https://github.com/ANYbotics/grid_map">https://github.com/ANYbotics/grid_map</a></p><ul><li>排列紧密</li><li>结构化</li><li>索引队列访问</li></ul><p>缺点:当切分过于细密时空间占用率大.</p><h2 id="Octo-map"><a href="#Octo-map" class="headerlink" title="Octo-map"></a>Octo-map</h2><p>github:<a href="https://github.com/OctoMap/octomap_mapping">https://github.com/OctoMap/octomap_mapping</a></p><p>地图中大部分为稀疏部分,使用八叉树的数据结构储存.如果一个区块没有障碍物,不再细分该区块;如果一个区块有障碍物则细分至最小包含该障碍物的区块.</p><p><strong>Octree</strong></p><p>八叉树（Octree）是一种用于描述三维空间的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，将八个子节点所表示的体积元素加在一起就等于父节点的体积。八叉树是四叉树在三维空间上的扩展，二维上我们有四个象限，而三维上，我们有8个卦限。八叉树主要用于空间划分和最近邻搜索。</p><p>实现Octree的原理:</p><ul><li>将当前的立方体细分为八个子立方体。</li><li>如果任何一个子立方体内包含多个点，则将其进一步细分为八个子立方体。</li><li>重复以上操作使得每个子立方体内包含最多一个点。</li></ul><p><img src="/images/path_planning_learning/1.png" alt="八叉树1"></p><p><img src="/images/path_planning_learning/2.webp" alt="八叉树2"></p><ul><li>排列稀疏</li><li>结构化</li><li>非直接索引访问(树的查询)</li></ul><h2 id="Voxel-hashing"><a href="#Voxel-hashing" class="headerlink" title="Voxel hashing"></a>Voxel hashing</h2><p>github:<a href="https://github.com/niessner/VoxelHashing">https://github.com/niessner/VoxelHashing</a></p><p>记录存在碰撞的区块 —-&gt; 哈希表,<strong>字典</strong></p><p>一个bucket中划分为更小的voxel blocks</p><p><img src="/images/path_planning_learning/3.png" alt="Voxel"></p><ul><li>排列最稀疏</li><li>结构化</li><li>非直接索引访问(字典查询)</li></ul><h2 id="Point-Cloud-Map"><a href="#Point-Cloud-Map" class="headerlink" title="Point Cloud Map"></a>Point Cloud Map</h2><ul><li>无序</li><li>无法通过索引队列访问(除非自发遍历)</li></ul><h2 id="TSDF-map"><a href="#TSDF-map" class="headerlink" title="TSDF map"></a>TSDF map</h2><p><strong>Truncated Signed Distance Functions (截断&#x2F;有符号&#x2F;距离函数)</strong></p><p>github:</p><p>TSDF 是一种用于表示3D空间表面的体素网格地图.</p><h3 id="Signed-Distance-Function-SDF"><a href="#Signed-Distance-Function-SDF" class="headerlink" title="Signed Distance Function (SDF)"></a>Signed Distance Function (SDF)</h3><p>对于空间中任意一点 x，SDF 给出它到最近表面的距离 d：<br>$$<br>SDF(x)&#x3D;±d<br>$$</p><ul><li>+d：点在<strong>表面外部</strong>（通常指相机方向）</li><li>−d：点在<strong>表面内部</strong></li><li>d&#x3D;0：点在表面上（即零交叉点）</li></ul><h3 id="Truncated-SDF（TSDF）"><a href="#Truncated-SDF（TSDF）" class="headerlink" title="Truncated SDF（TSDF）"></a>Truncated SDF（TSDF）</h3><p>真实计算中远离表面部分的距离信息不重要且不准确，因此会进行截断：</p><ul><li>若 ∣d∣&gt; μ，则 TSDF 值为截断值。</li><li>μ 是截断距离阈值（truncation distance）。</li></ul><h3 id="Voxel-Grid（体素网格）"><a href="#Voxel-Grid（体素网格）" class="headerlink" title="Voxel Grid（体素网格）"></a>Voxel Grid（体素网格）</h3><p>TSDF 存在于一个 3D 网格中（类似立方体像素）：</p><ul><li>每个体素（voxel）存储：<ul><li>当前体素的 TSDF 值</li><li>加权平均值（来自多个观测帧）</li><li>权重（用于融合多个观测）</li></ul></li></ul><p><img src="/images/path_planning_learning/4.png" alt="TSDF1"></p><p><img src="/images/path_planning_learning/5.png" alt="TSDF2"></p><h2 id="ESDF-Map"><a href="#ESDF-Map" class="headerlink" title="ESDF Map"></a>ESDF Map</h2><p><strong>Euclidean Signed Distance Field 欧几里得有符号距离场</strong></p><p>以 3D 网格（体素）的形式表示环境中每一点<strong>到障碍物最近点的欧几里得距离</strong>，并附带符号来表示点位于障碍物内部或外部。局部ESDF地图:只记忆感兴趣部分的ESDF值.</p><p><img src="/images/path_planning_learning/6.png" alt="ESDF1"></p><p><img src="/images/path_planning_learning/7.png" alt="ESDF2"></p><h2 id="Free-space-Roadmap"><a href="#Free-space-Roadmap" class="headerlink" title="Free-space Roadmap"></a>Free-space Roadmap</h2><p>概率路线图 —-&gt; 安全通行区域,使用<strong>凸多边体</strong>表示</p><p>得到的是一个宽阔的解空间</p><h2 id="Voronoi-Diagram-Map"><a href="#Voronoi-Diagram-Map" class="headerlink" title="Voronoi Diagram Map"></a>Voronoi Diagram Map</h2><p>高效利用ESDF提取地图骨架 —-&gt; 稀疏</p><h1 id="基于搜索的路径寻找"><a href="#基于搜索的路径寻找" class="headerlink" title="基于搜索的路径寻找"></a>基于搜索的路径寻找</h1><h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><p>A*算法在Dijkstra算法的基础上引入了启发函数(贪心思想)，启发函数是对当前节点到目标节点所需代价的预估.启发式函数一般使用曼哈顿距离、欧几里德距离。</p><blockquote><ol><li><p>从起点开始，将其加入待探索的节点集合（open set）。</p></li><li><p>每次选择 f 值最小的节点进行扩展，其中 <code>f(n) = g(n) + h(n)</code></p></li></ol><ul><li><code>g(n)</code> 是从起点到当前节点的实际代价</li><li><code>h(n)</code> 是从当前节点到终点的启发式估计（如直线距离）</li></ul><ol start="3"><li><p>对当前节点的所有相邻节点，计算新的 g 值，更新路径记录。</p></li><li><p>如果发现更优路径（g 值更小），则更新该邻居的记录，并加入 open set。</p></li><li><p>重复以上步骤，直到终点被选中扩展，表示找到最短路径。</p></li><li><p>通过路径记录表回溯，重建从起点到终点的完整路径。</p></li></ol></blockquote><p>伪代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">• 维护一个优先级队列来存储所有待扩容节点<br>• 所有节点的启发式函数<span class="hljs-built_in">h</span>(n)是预定义的<br>• 优先级队列初始化为起始状态 X S<br>• 对图中所有其他节点赋值<span class="hljs-built_in">g</span>(X S) = <span class="hljs-number">0</span>, <span class="hljs-built_in">g</span>(n) = infinite<br>• Loop<br>    •如果队列为空，则返回FALSE；BREAK;<br>    •从优先级队列中删除<span class="hljs-built_in">f</span>(n)=<span class="hljs-built_in">g</span>(n)+<span class="hljs-built_in">h</span>(n)最小的节点“n”<br>    •将节点“n”标记为展开<br>    •如果节点“n”是目标状态，返回TRUE；BREAK;<br>    •对于节点n的所有未展开的邻居 m<br>•<span class="hljs-function">If <span class="hljs-title">g</span><span class="hljs-params">(m)</span> </span>= infinite<br>• <span class="hljs-built_in">g</span>(m)= <span class="hljs-built_in">g</span>(n) + Cnm<br>    •对于节点n的所有未展开的邻居 m<br>•If <span class="hljs-built_in">g</span>(m) = infinite<br>• <span class="hljs-built_in">g</span>(m)= <span class="hljs-built_in">g</span>(n) + Cnm<br>• Push node “m” into the queue<br>•If <span class="hljs-built_in">g</span>(m) &gt; <span class="hljs-built_in">g</span>(n) + C nm<br>•<span class="hljs-built_in">g</span>(m)= <span class="hljs-built_in">g</span>(n) + Cnm<br>•end<br>• End Loop<br></code></pre></td></tr></table></figure><h3 id="Weighted-A-Search"><a href="#Weighted-A-Search" class="headerlink" title="Weighted A* Search"></a>Weighted A* Search</h3><p>Sub-Optimal Solution</p><p>通过人为加大启发函数的影响力来获得更快的搜索速度，以牺牲路径最优性为代价。</p><p>f &#x3D; g + εh, ε &gt; 1 &#x3D;bias towards states that are closer to goal.</p><p><img src="/images/path_planning_learning/8.png" alt="Weighted_A*_Search"></p><ul><li><p>Most Greedy（最贪婪）</p></li><li><p>参数：a&#x3D;0,b&#x3D;1</p></li><li><p>只考虑启发式代价，完全不考虑当前路径代价</p></li><li><p>结果：趋向于直接朝目标点移动，但路径不一定最短或最优</p></li></ul><hr><ul><li><p>Tunable Greediness（可调贪婪度）</p></li><li><p>参数：a&#x3D;1,b&#x3D;ε&gt;1</p></li><li><p>综合考虑当前路径和启发式估计，但偏向启发式</p></li><li><p>结果：平衡探索性和效率，路径更合理</p></li></ul><hr><ul><li><p>Optimal（最优路径）</p></li><li><p>参数：a&#x3D;1,b&#x3D;1</p></li><li><p>平等考虑已知路径和启发估计</p></li><li><p>结果：找到最优路径</p></li></ul><hr><ul><li><p>Dijkstra算法</p></li><li><p>参数：a&#x3D;1,b&#x3D;0</p></li><li><p>完全不使用启发式，只靠实际代价 g,效率低</p></li></ul><h3 id="A-的实施流程"><a href="#A-的实施流程" class="headerlink" title="A*的实施流程"></a>A*的实施流程</h3><ol><li><p>建立地图 → 生成网格节点数组</p></li><li><p>设定障碍 → 标记不可达节点</p></li><li><p>编写邻居搜索函数</p></li><li><p>编写A*主循环：</p><ul><li><p>从openList中取出f值最小的节点</p></li><li><p>计算邻居的g&#x2F;h&#x2F;f值，加入openList</p></li><li><p>更新已访问节点（closedList）</p></li></ul></li><li><p>使用<code>priority_queue</code>或<code>multimap</code>优化性能</p></li></ol><h3 id="最好的启发函数"><a href="#最好的启发函数" class="headerlink" title="最好的启发函数"></a><strong>最好的启发函数</strong></h3><p><strong>最好:tight</strong>,正确的最短距离函数</p><blockquote><p>二维最佳启发函数:<br>$$<br>h2D​&#x3D;(dx+dy)+(2<br>​−2)⋅min(dx,dy)<br>$$<br>三维最佳启发函数:</p><p>我们记 dx,dy,dz为三维网格中当前点与目标点在三个轴上的距离（均为非负整数），有：<br>$$<br>h3D&#x3D;dmin⋅3+(dmid−dmin)⋅2+(dmax−dmid)⋅1<br>$$<br>其中：dmin,dmid,dmax是 dx,dy,dzdx,dy,dz 的排序结果，使得</p><p>$$<br>dmin≤dmid≤dmax<br>$$</p></blockquote><h3 id="Tie-Breaker"><a href="#Tie-Breaker" class="headerlink" title="Tie Breaker"></a>Tie Breaker</h3><p>平局处理器,打破 f 值相等时的探索顺序</p><ul><li>问题:</li></ul><p>​A* 会选取 f 值最小的节点扩展（f&#x3D;g+h）</p><p>​但在一些情形下，很多节点的 f 值完全相等,尤其是在网格图中启发函数不够 tight 的时候</p><p>​导致算法要探索很多不必要的节点，降低效率</p><blockquote><ul><li><strong>解决方法:</strong></li></ul><ol><li>人为干扰 h，让 f 值不同:</li></ol><p>  将原来的启发函数 h乘上一个微小因子：<br>$$<br>  h&#x3D;h×(1.0+p)<br>$$<br>  其中：<br>$$<br>  p &lt; \frac{\text{最小步长代价}}{\text{预期路径总长度}}<br>$$<br>  这样能 <strong>轻微打破平局</strong>，减少无效扩展</p><p>  代价是轻微地破坏启发式的“可采纳性”（admissibility），但常常实际无影响或带来更好效率.</p><ol start="2"><li>优先选 h值小的节点</li></ol><p>  如果两个节点 f 一样，选择 h 小的那个（靠近终点）</p><ol start="3"><li>加入伪随机干扰项（Deterministic random）</li></ol><ul><li>给每个节点加一个唯一扰动，保持一致性但不完全对称</li></ul><ol start="4"><li>优先靠近起点-终点连线的路径</li></ol><p>$$<br>cross&#x3D;∣dx1×dy2−dx2×dy1∣<br>$$</p><p><strong>这其实是在衡量点偏离直线的“面积”，越小越靠近理想路径。</strong></p></blockquote><h2 id="Jump-Point-Search"><a href="#Jump-Point-Search" class="headerlink" title="Jump Point Search"></a>Jump Point Search</h2><p>核心思想:<strong>在两点之间没有障碍物时，中间的节点不考虑,只考虑重要节点.</strong></p><ol><li>邻居修剪 Neighbor Pruning</li></ol><ul><li><p>灰色节点：较差的邻居，当去到它们时，没有分值的路径更便宜。丢弃。</p></li><li><p>白色节点：自然邻居。</p></li></ul><p>​只需要考虑<strong>自然邻居</strong>.</p><p><img src="/images/path_planning_learning/9.png" alt="Neighbor Pruning"></p><ol start="2"><li>强迫邻居 Forced Neighbors</li></ol><p>节点X的邻居节点有障碍物，且X的父节点P经过X到达N的距离代价，比不经过X到大N的任一路径的距离代价都小，则称N是X的强迫邻居。</p><ul><li><p>有相邻的障碍</p></li><li><p>红色节点是强制邻居。</p></li><li><p>一条从父母到他们通过障碍的更便宜的路径被阻断。</p></li></ul><p><img src="/images/path_planning_learning/10.png" alt="Forced Neighbors"></p><ol start="3"><li>跳点(Jump Point)：什么样的节点可以作为跳点<br> (1)节点 A 是起点、终点.<br> (2)节点A 至少有一个强迫邻居.<br> (3)父节点在斜方向(斜向搜索)，节点A的水平或者垂直方向上有满足 (1)、(2) 的节点</li></ol><p><img src="/images/path_planning_learning/11.png" alt="Jump Point"></p><p>跳点搜索中，会递归地检查路径上的邻居节点是否是“跳点”。在检查对角线方向前，会优先尝试直线方向。只要某个节点通往某些邻居的最短路径必须经过它，它就会被标记为跳点。同时，对“强制邻居”不能剪枝，必须展开。</p><h1 id="基于采样的路径寻找"><a href="#基于采样的路径寻找" class="headerlink" title="基于采样的路径寻找"></a>基于采样的路径寻找</h1><h2 id="Probabilistic-Road-Map"><a href="#Probabilistic-Road-Map" class="headerlink" title="Probabilistic Road Map"></a>Probabilistic Road Map</h2><p>图结构</p><p>将规划分为两个阶段：<br>·学习阶段<br>·查询阶段</p><p>检查采样配置和连接的样本之间的碰撞可以有效率地完成任务。<br>数量相对较少的里程碑和局部路径足以捕获的连通性。</p><ul><li>限制路径点连接的长度避免图结构过于复杂</li></ul><h3 id="学习阶段"><a href="#学习阶段" class="headerlink" title="学习阶段:"></a>学习阶段:</h3><ul><li>在c空间中采样N个点</li><li>删除碰撞点</li></ul><p><img src="/images/path_planning_learning/12.png" alt="PRM-Learning1"></p><ul><li>连接到最近的点，并获得无碰撞段。</li><li>删除碰撞段</li></ul><p><img src="/images/path_planning_learning/13.png" alt="PRM-Learning2"></p><h3 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段:"></a>查询阶段:</h3><ul><li>在路线图上搜索，找到从起点到终点的路径目标（使用Dijkstra算法或A*算法）。</li><li>路线图现在类似于网格地图</li></ul><p><img src="/images/path_planning_learning/14.png" alt="PRM-Query"></p><p> 优点</p><ul><li>概率完备</li></ul><p>缺点</p><ul><li><p>要求解决两点边值问题</p></li><li><p>在状态空间上构建图，但不特别关注生成路径</p></li><li><p>效率不高</p></li></ul><h3 id="Lazy-collision-checking"><a href="#Lazy-collision-checking" class="headerlink" title="Lazy collision-checking"></a>Lazy collision-checking</h3><p><strong>效率低</strong>: PRM（Probabilistic Roadmap）或 RRT（Rapidly-exploring Random Tree) 需要频繁地检查从一个配置到另一个配置（或状态）之间的路径是否与障碍物发生碰撞。但碰撞检测是一个昂贵的计算操作，尤其在高维空间或复杂环境中，频繁的碰撞检测会成为性能瓶颈。</p><ul><li>不考虑采样点和生成分段碰撞（懒惰）</li></ul><p>先构建图（PRM）或树（RRT）时不立即检查碰撞，等到真正要使用这条路径时（例如在查询最短路径、或者将路径从树&#x2F;图中提取出来时），再执行碰撞检测。</p><h4 id="PRM-Lazy-collision-checking"><a href="#PRM-Lazy-collision-checking" class="headerlink" title="PRM+Lazy collision-checking"></a><strong>PRM+Lazy collision-checking</strong></h4><ol><li><p>构建 roadmap：采样节点、连接边，不做碰撞检测。</p></li><li><p>查询路径：使用 A* 或 Dijkstra 等算法找到一条从起点到终点的路径。</p></li><li><p>在该路径上进行逐段碰撞检测：</p><ul><li><p>如果全部无碰撞，路径有效；</p></li><li><p>如果某段有碰撞，将该边标记为无效（不可达），从图中删除，重新搜索。</p></li></ul></li></ol><p><img src="/images/path_planning_learning/15.png" alt="Lazy collision-checking"></p><h2 id="Rapidly-exploring-Random-Tree"><a href="#Rapidly-exploring-Random-Tree" class="headerlink" title="Rapidly-exploring Random Tree"></a>Rapidly-exploring Random Tree</h2><p><strong>核心思想:</strong></p><blockquote><p>通过生成next构建树状态在树中通过执行随机控制,从起点开始，不断向随机方向扩展一棵树，迅速探索整个状态空间。</p></blockquote><p>伪代码:</p><p><img src="/images/path_planning_learning/16.png" alt="RRT伪代码"></p><ul><li>初始化一棵树 <code>T</code>，将起始点 <code>X_init</code> 作为树的根节点。</li><li>循环:</li><li>在整个状态空间中随机采样一个点 <code>X_rand</code>，用于探索新方向。</li><li>找出树 <code>T</code> 中距离 <code>X_rand</code> 最近的已有节点 <code>X_nearest</code>。</li><li>从 <code>X_nearest</code> 朝 <code>q_rand</code> 方向延伸一个固定步长delta，生成新点 <code>X_new</code>。</li></ul><p>如果新点 <code>X_new</code> 是可行的（比如不与障碍物碰撞），则执行以下操作:</p><ul><li>把这个新点 <code>X_new</code> 加入树中，作为新的节点。</li><li>在树中添加一条从 <code>X_nearest</code> 到 <code>X_new</code> 的路径边。</li><li>返回整个搜索生成的树 <code>T</code>，它包含从起点开始探索出来的路径结构。</li></ul><p>**提前停止的条件：**因为每一段树枝的末端都是Xnew，所以每产生一次Xnew节点，我们都判断一下Xnew与终点之间的距离，看这个距离是否小于步长，如果小于步长且没有经过障碍物，则就直接把Xnew与终点进行相连。</p><blockquote><p>优点:<br>·旨在找到从起点到目标的路径<br>·比PRM更有针对性<br>缺点:<br>·非最优解<br>·效率不高,在 <strong>narrow环境</strong> 中效率低<br>·整个空间取样</p></blockquote><h3 id="KD树"><a href="#KD树" class="headerlink" title="KD树"></a>KD树</h3><p> Kd-Tree，即K-dimensional  tree，是一棵二叉树，树中存储的是一些K维数据。在一个K维数据集合上构建一棵Kd-Tree代表了对该K维数据集合构成的K维空间的一个划分，即树中的每个结点就对应了一个K维的超矩形区域（Hyperrectangle）。</p><p>关键术语:</p><ul><li>维度（K）：表示数据点所在的空间维数。例如，二维空间中的点有x和y坐标，三维空间中的点有x、y、z坐标。</li><li>节点：KD树的每个节点包含一个K维点及其分割超平面的信息。</li><li>超平面：在K维空间中用于将空间划分为两个部分的（K-1）维子空间。例如，二维空间中的超平面是直线，三维空间中的超平面是平面。</li></ul><p>构建步骤:</p><ol><li><p>输入数据：假设有N个K维数据点。</p></li><li><p>选择分割维度：按照循环顺序选择当前维度。例如，第一个维度（x轴）用于根节点，第二个维度（y轴）用于其子节点，依此类推。</p></li><li><p>选择分割值：在当前分割维度上找到<strong>中位数</strong>点，将其作为当前节点。</p></li><li><p>划分数据：</p><ul><li><p>左子集：所有在当前分割维度上小于中位数点的点。</p></li><li><p>右子集：所有在当前分割维度上大于中位数点的点。</p></li></ul></li><li><p>递归构建子树：对左子集和右子集重复上述步骤，直到所有点都被包含在树中。</p></li><li><p>终止条件：当某一子集为空时，递归终止。</p></li></ol><p><img src="/images/path_planning_learning/17.png" alt="一个创建KD树的例子"></p><p>使用KD树提高<strong>路径规划</strong>效率</p><h3 id="Bidirectional-RRT-RRT-Connect-双向快速扩展随机树"><a href="#Bidirectional-RRT-RRT-Connect-双向快速扩展随机树" class="headerlink" title="Bidirectional RRT &#x2F; RRT-Connect 双向快速扩展随机树"></a>Bidirectional RRT &#x2F; RRT-Connect 双向快速扩展随机树</h3><blockquote><ol><li>初始化两棵树：T_start 以 q_start 为根，T_goal 以 q_goal 为根。</li><li>重复以下过程直到路径找到或迭代上限：<br>a. 从状态空间中采样一个随机点 q_rand。<br>b. 使用 Extend 操作从 T_start 向 q_rand 延伸，得到 q_new。<br>c. 如果扩展成功：<br>i. 使用 Connect 操作让 T_goal 向 q_new 不断扩展，直到无法前进。<br>ii. 如果两个树在某个点连接，则路径找到。<br>d. 交换 T_start 和 T_goal。</li></ol></blockquote><table><thead><tr><th align="center">项目</th><th align="center">单向 RRT</th><th align="center">双向 RRT（RRT-Connect）</th></tr></thead><tbody><tr><td align="center">扩展方向</td><td align="center">只从起点扩展</td><td align="center">起点和终点同时扩展</td></tr><tr><td align="center">搜索速度</td><td align="center">较慢</td><td align="center">更快，更高效</td></tr><tr><td align="center">成功率</td><td align="center">容易陷入复杂障碍</td><td align="center">双向推进更容易绕障碍</td></tr><tr><td align="center">路径质量</td><td align="center">一般</td><td align="center">更好</td></tr><tr><td align="center">复杂性</td><td align="center">低</td><td align="center">高</td></tr></tbody></table><h2 id="Optimal-sampling-based-path-planning-methods"><a href="#Optimal-sampling-based-path-planning-methods" class="headerlink" title="Optimal sampling-based path planning methods"></a>Optimal sampling-based path planning methods</h2><p>在传统采样方法（如 RRT、PRM）的基础上，进一步加入了<strong>路径最优性保证</strong>的算法。最经典的代表是 <strong>RRT</strong>*</p><h3 id="RRT"><a href="#RRT" class="headerlink" title="RRT*"></a>RRT*</h3><p><img src="/images/path_planning_learning/18.png" alt="RRT*伪代码"></p><p><strong>Choose Best Parent</strong>：在新节点周围半径内的已有节点中，选择一条“代价最小”的路径作为父节点；</p><p><strong>Rewire</strong>：反过来看新节点是否能以更小的代价更新周围节点的父节点。</p><h3 id="Kinodynamic-RRT"><a href="#Kinodynamic-RRT" class="headerlink" title="Kinodynamic-RRT*"></a>Kinodynamic-RRT*</h3><p>更改Steer（）函数以适应机器人的运动或其他限制导航(曲线)</p><h2 id="Advanced-Sampling-based-Methods"><a href="#Advanced-Sampling-based-Methods" class="headerlink" title="Advanced Sampling-based Methods"></a>Advanced Sampling-based Methods</h2><h3 id="Inform-RRT"><a href="#Inform-RRT" class="headerlink" title="Inform RRT*"></a>Inform RRT*</h3><p>一旦找到一条路径，其代价为 <code>c_best</code>，就只在以下区域采样：</p><blockquote><p><strong>从起点 <code>q_start</code> 到终点 <code>q_goal</code> 的椭球体区域（Ellipsoidal Sampling Space）</strong><br> 半长轴为 <code>c_best/2</code>，焦点为起点与终点，构成一个最短路径所有可能穿过的区域。</p></blockquote><p><img src="/images/path_planning_learning/18.png" alt="Inform RRT*"></p><h3 id="Cross-entropy-motion-planning"><a href="#Cross-entropy-motion-planning" class="headerlink" title="Cross-entropy motion planning"></a>Cross-entropy motion planning</h3><ol><li><p><strong>初始化一个轨迹分布模型</strong></p><ul><li><p>比如用高斯分布建模一条轨迹（多个中间点组成）</p></li><li><p>初始均值：可能是直线路径，初始方差大</p></li></ul></li><li><p><strong>采样多个轨迹</strong></p><p>每条轨迹是从当前分布中采样得到的一个完整路径（可加速度约束等）</p></li><li><p><strong>评估轨迹代价</strong>:碰撞检测、路径长度、平滑性、目标接近度等</p></li><li><p><strong>选取表现最好的轨迹（Top-k）</strong>:选出“精英轨迹”，即代价最小的那一部分</p></li><li><p>**用精英轨迹更新分布参数:**更新高斯均值和协方差，使下次采样更集中于好路径附近</p></li><li><p><strong>迭代</strong>:重复 2-5，直到满足终止条件（如达到最小代价、收敛、超时等）</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OverView&quot;&gt;&lt;a href=&quot;#OverView&quot; class=&quot;headerlink&quot; title=&quot;OverView&quot;&gt;&lt;/a&gt;OverView&lt;/h1&gt;&lt;h2 id=&quot;前端-路径寻找&quot;&gt;&lt;a href=&quot;#前端-路径寻找&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>接入网综合课设</title>
    <link href="http://example.com/2025/03/10/%E6%8E%A5%E5%85%A5%E7%BD%91%E8%AF%BE%E8%AE%BE/"/>
    <id>http://example.com/2025/03/10/%E6%8E%A5%E5%85%A5%E7%BD%91%E8%AF%BE%E8%AE%BE/</id>
    <published>2025-03-10T02:25:26.000Z</published>
    <updated>2025-04-03T06:36:47.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接入网综合课设"><a href="#接入网综合课设" class="headerlink" title="接入网综合课设"></a>接入网综合课设</h1><h2 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h2><ol><li><p>完成虚拟机选型，并配置至少两个网段， 分别测试子网内和子网间连通性； </p></li><li><p>设计PPPOE本地认证拓扑图及IP地址规划 (客户至少两个网段)  ；</p></li><li><p>选型PPPOE服务器软件，并在虚拟环境下 完成PPPoE接入本地认证的搭建、配置、 实验测试。</p></li></ol><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><h4 id="子网规划"><a href="#子网规划" class="headerlink" title="子网规划"></a>子网规划</h4><p>虚拟机选型：ubuntu20.04</p><p>配置网段：</p><ul><li>Vmnet1:192.168.10.0&#x2F;24</li><li>Vmnet2:192.168.20.0&#x2F;24 </li><li>Vmnet3:192.168.30.0&#x2F;24</li></ul><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/1.png" alt="子网规划"></p><h4 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h4><ol><li>在ubuntu编辑-虚拟网络编辑器中选择更改设置，赋予管理员权限后选择添加网络，类型为<strong>仅主机模式</strong>，修改子网IP和子网掩码。</li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/2.png" alt="虚拟网络编辑器"></p><ol start="2"><li>在ubuntu虚拟机设置中添加网卡，三张为子网规划中定义所对应的网卡。</li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/3.png" alt="虚拟机设置"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/4.png" alt="硬件设置"></p><p>对应网络适配器选择自定义-特定虚拟网络-选择对应网卡-确定。</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/5.png" alt="虚拟机设置"></p><ol start="3"><li>在ubuntu中输入</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><p>出现对应网卡信息。</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/6.png" alt="网卡信息"></p><ol start="4"><li>配置静态IP。参考博客：<a href="https://blog.csdn.net/weixin_58305495/article/details/130554393">Ubuntu配置静态IP</a>，注意与网卡名称匹配。</li></ol><p><strong>Ubuntu 16.04 及更早版本</strong>：网络管理工具使用 <code>ifupdown</code>，网络配置文件在 <code>/etc/network/interfaces</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">auto lo<br>iface lo inet loopback<br><br>auto eth0<br>iface eth0 inet dhcp<br><br>auto eth1<br>iface eth1 inet static<br>address 192.168.10.10<br>netmask 255.255.255.0<br>gateway 192.168.10.1<br>dns-nameservers 8.8.8.8 8.8.4.4<br><br>auto eth2<br>iface eth2 inet static<br>address 192.168.20.10<br>netmask 255.255.255.0<br>gateway 192.168.20.1<br><br>auto eth3<br>iface eth3 inet static<br>address 192.168.30.10<br>netmask 255.255.255.0<br>gateway 192.168.30.1<br><br></code></pre></td></tr></table></figure><p><strong>Ubuntu 17.10 及更高版本</strong>：网络管理工具使用 <code>Netplan</code>，配置文件位于 <code>/etc/netplan/00-installer-config.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Let NetworkManager manage all devices on this system</span><br><span class="hljs-attr">network:</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span><br>  <span class="hljs-attr">ethernets:</span><br>    <span class="hljs-attr">ens33:</span>            <br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span>                          <br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.4</span><span class="hljs-number">.4</span>]       <br><br>    <span class="hljs-attr">ens37:</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.10</span><span class="hljs-string">/24</span>]        <br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span> <span class="hljs-string">default</span><br>          <span class="hljs-attr">via:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.1</span>                <br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">false</span>                          <br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.4</span><span class="hljs-number">.4</span>]      <br><br>    <span class="hljs-attr">ens38:</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.10</span><span class="hljs-string">/24</span>]         <br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span> <span class="hljs-string">default</span><br>          <span class="hljs-attr">via:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.1</span>                <br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">false</span>                          <br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.4</span><span class="hljs-number">.4</span>]   <br><br>    <span class="hljs-attr">ens39:</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.30</span><span class="hljs-number">.10</span><span class="hljs-string">/24</span>]        <br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span> <span class="hljs-string">default</span><br>          <span class="hljs-attr">via:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.30</span><span class="hljs-number">.1</span>              <br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">false</span>                     <br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.4</span><span class="hljs-number">.4</span>]   <br></code></pre></td></tr></table></figure><p>配置完成后执行命令使配置生效。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo netplan apply<br></code></pre></td></tr></table></figure><p>执行<code>ifconfig</code>命令查看当前IP地址。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><strong>子网间连通性</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/7.png" alt="Linux子网间连通性"></p><p>Client1(192.168.10.20)</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/8.png" alt="Client1子网间连通性"></p><p>Client2(192.168.20.20)</p><img src="/images/接入网综合课设/9.png" alt="image-20250308132954522" style="zoom: 80%;" /><p><strong>子网内连通性</strong></p><p>Client1(192.168.10.20)</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/10.png" alt="Client1子网内连通性"></p><p>Client2(192.168.20.20)</p><img src="/images/接入网综合课设/11.png" alt="image-20250308133215681" style="zoom:80%;" /><h3 id="任务三"><a href="#任务三" class="headerlink" title="任务三"></a>任务三</h3><h4 id="PPPoE服务器端"><a href="#PPPoE服务器端" class="headerlink" title="PPPoE服务器端"></a>PPPoE服务器端</h4><p><a href="https://zhuanlan.zhihu.com/p/41499761">参考博客:基于Linux环境的PPPOE服务器搭建</a></p><ol><li>安装PPPoE服务器程序</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get install pppoe<br></code></pre></td></tr></table></figure><p>使用<code>pppoe-server -h</code>查看pppoe安装情况及版本,该PPPoE-Server版本为3.12。</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/12.png" alt="PPPoE服务器版本"></p><ol start="2"><li>编辑&#x2F;etc&#x2F;ppp&#x2F;options文件</li></ol><ul><li>PAP：明文密码认证协议。</li><li>CHAP：挑战握手认证协议，<strong>三次握手</strong>机制，使用哈希加密。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">14+ ms-dns 8.8.8.8<br>57  local<br>144 #+pap  // 关闭pap<br>147 -pap<br>151 +chap  // 开启chap<br>154 #-chap<br>208 proxyarp<br></code></pre></td></tr></table></figure><ol start="3"><li>编辑 pppoe-server-options文件</li></ol><p>创建&#x2F;etc&#x2F;ppp&#x2F;pppoe-server-options文件，使用chap验证协议require-chap，如果使用pap验证协议则配置为 require-pap。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">auth<br>require-chap<br>lcp-echo-interval 60<br>lcp-echo-failure 5     <br>logfile /var/log/pppd.log<br></code></pre></td></tr></table></figure><ol start="3"><li>编辑&#x2F;etc&#x2F;ppp&#x2F;chap-secrets 文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Secrets <span class="hljs-keyword">for</span> authentication using CHAP</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">clientserversecretIP addresses</span><br>test * test *<br></code></pre></td></tr></table></figure><p>用户名为test，密码为test，服务器名和IP地址为任意。</p><ol start="4"><li>开启IP转发功能</li></ol><p>​编辑&#x2F;etc&#x2F;sysctl.conf文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">28 net.ipv4.ip_forward=1<br></code></pre></td></tr></table></figure><p>​运行<code>sudo sysctl -p</code>生效配置。</p><ol start="5"><li>启动PPPoE服务器</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo pppoe-server -I ens37 -L 192.168.10.10 -R 192.168.10.11 -N 20   <br>sudo pppoe-server -I ens38 -L 192.168.20.10 -R 192.168.20.11 -N 20   <br></code></pre></td></tr></table></figure><p><strong>指令含义：</strong></p><table><thead><tr><th>pppoe-server</th><th>启动 PPPoE 服务器进程</th></tr></thead><tbody><tr><td>-I xxx</td><td>监听物理网卡xxx，接受客户端的 PPPoE 拨号请求</td></tr><tr><td>-L IP地址</td><td>PPP 服务器的 IP 地址</td></tr><tr><td>-R IP地址</td><td>客户端分配 IP 的起始地址</td></tr><tr><td>-N n</td><td>最多允许 n 个 PPPoE 客户端同时连接</td></tr></tbody></table><ol start="6"><li>查看PPPoE服务器的启用情况</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ps -ef|grep pppoe<br></code></pre></td></tr></table></figure><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/13.png" alt="pppoe服务器的启用情况"></p><ul><li>如果需要关闭PPPoE服务器，指令为：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo killall pppoe-server<br></code></pre></td></tr></table></figure><ul><li><p>每次电脑重启均需要重新运行PPPoE启动命令，设置开机自启动脚本：</p><ol><li><p>创建systemd服务文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /etc/systemd/system/pppoe-server.service<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs SHELL">[Unit]<br>Description=PPPoE Server Service<br>After=network.target # 等到网络启动后再启动<br><br>[Service]<br>ExecStart=/usr/local/bin/start-pppoe.sh<br>Restart=always<br>RestartSec=5<br>User=root<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">无限制重启</span><br>StartLimitIntervalSec=0<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/bin/start-pppoe.sh<br></code></pre></td></tr></table></figure></li><li><p>创建脚本文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/bin/start-pppoe.sh<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>pppoe-server -I ens37 -L 192.168.10.10 -R 192.168.10.11 -N 20<br>pppoe-server -I ens38 -L 192.168.20.10 -R 192.168.20.11 -N 20<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">保持进程运行</span><br>tail -f /dev/null<br></code></pre></td></tr></table></figure><p>赋予执行权限：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo chmod +x /usr/local/bin/start-pppoe.sh<br></code></pre></td></tr></table></figure></li><li><p>重新加载配置，重启服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo systemctl daemon-reload<br>sudo systemctl reset-failed<br>sudo systemctl enable pppoe-server<br>sudo systemctl start pppoe-server<br></code></pre></td></tr></table></figure></li><li><p>重启后检查服务状态：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ps -ef|grep pppoe<br>sudo systemctl status pppoe-server<br></code></pre></td></tr></table></figure><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/24.png" alt="重启后的服务状态"></p></li></ol><ul><li><p>注：如果systemd服务文件中没有添加<code>StartLimitIntervalSec=0</code>,脚本文件中没有<code>tail -f /dev/null</code>,则有可能报错：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo systemctl status pppoe-server<br>● pppoe-server.service - PPPoE Server Service<br>     Loaded: loaded (/etc/systemd/system/pppoe-server.service; enabled; vendor&gt;<br>     Active: failed (Result: start-limit-hit) since Mon 2025-03-10 00:16:20 CS&gt;<br>    Process: 2386 ExecStart=/usr/local/bin/start-pppoe.sh (code=exited, status&gt;<br>   Main PID: 2386 (code=exited, status=0/SUCCESS)<br><br>3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Scheduled&gt;<br>3月 10 00:16:20 xu-virtual-machine systemd[1]: Stopped PPPoE Server Service.<br>3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Start req&gt;<br>3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Failed wi&gt;<br>3月 10 00:16:20 xu-virtual-machine systemd[1]: Failed to start PPPoE Server Se&gt;<br></code></pre></td></tr></table></figure><p>失败的原因： <code>start-limit-hit</code>，短时间内该服务多次失败，触发了 systemd 的启动限制机制。原脚本<code>start-pppoe.sh</code> 脚本执行完后立即退出，systemd 误以为它崩溃并尝试重启，导致触发 <code>start-limit-hit</code>。</p></li></ul></li></ul><h4 id="PPPoE客户端"><a href="#PPPoE客户端" class="headerlink" title="PPPoE客户端"></a>PPPoE客户端</h4><p>Windows端拨号步骤：</p><ol><li>选择网络和Internet设置</li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/14.png" alt="选择网络和Internet设置"></p><ol start="2"><li>选择拨号-设置新连接-连接到Internet-下一页-宽带</li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/15.png" alt="拨号选择"></p><ol start="3"><li><p>输入用户名和密码</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/16.png" alt="用户名和密码"></p></li><li><p>连接成功</p></li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/17.png" alt="拨号成功"></p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p> 客户端连接成功后，在服务器端输入<code>ifconfig</code>会看到PPP接口信息</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/18.png" alt="PPP接口"></p><p>在客户端输入<code>ipconfig /all</code>  会看到PPP服务器分配的IP地址</p><p><strong>Client1(192.168.10.20)</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/19.png" alt="Client1"></p><p><strong>测试ping通：</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/20.png" alt="Client1"></p><p><strong>Client2(192.168.20.20)</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/21.png" alt="Client2"></p><p>测试ping通：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/22.png" alt="Client2"></p><p><strong>抓包分析</strong></p><p><strong>注意</strong>：执行 <code>sudo wireshark</code> </p><p>Filter 选择pppoe|ppoes。</p><p><strong>PPPoE报文类型</strong></p><table><thead><tr><th>阶段</th><th>以太网协议号</th><th>报文类型</th></tr></thead><tbody><tr><td><strong>发现阶段</strong>（Discovery）</td><td><code>0x8863</code></td><td>PADI, PADO, PADR, PADS, PADT</td></tr><tr><td><strong>会话阶段</strong>（Session）</td><td><code>0x8864</code></td><td>PPP 数据包（LCP、PAP&#x2F;CHAP、IP 数据等）</td></tr></tbody></table><p><strong>PPPoE交互过程</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/32.png" alt="PPPoE交互过程"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/25.png" alt="抓包pppoed"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/26.png" alt="抓包pppoes-1"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/27.png" alt="抓包pppoes-2"></p><p><strong>PPPoE 发现阶段</strong></p><p>PPPoE 发现阶段用于 建立 PPPoE 连接有5种报文：</p><ol><li>PADI（PPPoE Active Discovery Initiation）</li></ol><ul><li><strong>客户端 → 广播</strong> 发送 <strong>PADI</strong>（发现请求）。</li><li>用于查找可用的 PPPoE 服务器（AC, Access Concentrator）。</li><li><strong>目标 MAC 地址：<code>FF:FF:FF:FF:FF:FF</code></strong>（广播）。</li><li>只有Service-Name为空的服务器会响应。</li></ul><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/28.png" alt="抓包pppoed-PADI"></p><ol start="2"><li>PADO（PPPoE Active Discovery Offer）</li></ol><ul><li><strong>服务器（AC）→ 客户端</strong> 回复 <strong>PADO</strong>（提供服务）。</li><li>服务器响应客户端，表明自己可用。</li><li>包含 <strong>服务器名称</strong> 和 <strong>支持的服务</strong>。</li></ul><p><img src="/./images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/29.png" alt="抓包pppoed-PADO"></p><ol start="3"><li>PADR（PPPoE Active Discovery Request）</li></ol><ul><li><p><strong>客户端 → 服务器（AC）</strong> 发送 <strong>PADR</strong>（连接请求）。</p></li><li><p>用户主机可能会收到多个 PADO，但仅查看它收到的 PADO 数据包并选择一个，并请求建立会话。</p></li><li><p>包含 <strong>服务名</strong> 和 <strong>唯一的标识符</strong>。</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/30.png" alt="抓包pppoed-PADR"></p></li></ul><ol start="4"><li>PADS（PPPoE Active Discovery Session-confirmation）</li></ol><ul><li><strong>服务器（AC）→ 客户端</strong> 发送 <strong>PADS</strong>（会话确认）。</li><li><strong>分配一个 PPPoE 会话 ID</strong>，表示连接已建立。</li></ul><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/31.png" alt="抓包pppoed-PADS"></p><ol start="5"><li>PADT（PPPoE Active Discovery Terminate）</li></ol><ul><li>客户端或服务器 发送 <strong>PADT</strong>（终止连接）。</li><li>关闭 PPPoE 连接。</li></ul><p><strong>PPPoE 会话阶段</strong></p><p>PPPoE 发现阶段完成后，客户端和服务器通过 <strong>PPPoE 会话 ID</strong> 进行通信。<br> 此时 PPPoE 封装标准 PPP 报文，包括4种报文：</p><ol><li><strong>LCP（Link Control Protocol）</strong>：链路协商。</li><li><strong>PAP&#x2F;CHAP（Password Authentication Protocol &#x2F; Challenge Handshake Authentication Protocol）</strong>:  用户身份认证。</li><li><strong>NCP（Network Control Protocol)</strong> : 分配 IP 地址。</li><li><strong>IP 数据报文</strong>: 网络通信数据（TCP&#x2F;IP、UDP）。</li></ol><h2 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h2><ol><li>设计PPPoE+RADIUS远程接入控制拓扑图及IP地址规划（客户机至少两个网段）。</li><li>选型RADIUS服务器软件，并在虚拟平台下完成PPPOE+RADIUS远程接入认证的搭建、配置、实验测试。</li></ol><h3 id="任务一-1"><a href="#任务一-1" class="headerlink" title="任务一"></a>任务一</h3><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/42.png" alt="42"></p><h3 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h3><ul><li>RADIUS服务器：FreeRADIUS 3.0.27 （最新stable版本）</li><li>RADIUS客户端：FreeRADIUS -client-1.1.7</li></ul><h4 id="配置Radius服务器及客户端静态IP"><a href="#配置Radius服务器及客户端静态IP" class="headerlink" title="配置Radius服务器及客户端静态IP"></a>配置Radius服务器及客户端静态IP</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /etc/netplan/01-network-manager-all.yaml<br></code></pre></td></tr></table></figure><ul><li><strong>服务器</strong></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Let NetworkManager manage all devices on this system</span><br>network:<br>  version: 2<br>  renderer: NetworkManager<br>  ethernets:<br>    ens33:            <br>      dhcp4: true                           # 启用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br>        <br>    ens37:<br>      addresses: [192.168.30.2/24]        <br>      routes:<br>        - to: default<br>          via: 192.168.30.1                <br>      dhcp4: false                          <br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4] <br></code></pre></td></tr></table></figure><p>配置完成后执行命令使配置生效。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo netplan apply<br></code></pre></td></tr></table></figure><p>执行<code>ifconfig</code>命令查看当前IP地址</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/40.png" alt="40"></p><ul><li><strong>客户端（PPPoE服务器）</strong></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Let NetworkManager manage all devices on this system</span><br>network:<br>  version: 2<br>  renderer: NetworkManager<br>  ethernets:<br>    ens33:            <br>      dhcp4: true                           # 启用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br>        <br>    ens37:<br>      addresses: [192.168.10.1/24]           # 静态 IP 地址<br>      routes:<br>        - to: default<br>          via: 192.168.10.1  # 默认网关<br>      dhcp4: false                           # 禁用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br>        <br>    ens38:<br>      addresses: [192.168.20.1/24]           # 静态 IP 地址<br>      routes:<br>        - to: default<br>          via: 192.168.20.1  # 默认网关<br>      dhcp4: false                           # 禁用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br>        <br>    ens39:<br>      addresses: [192.168.30.1/24]           # 静态 IP 地址<br>      routes:<br>        - to: default<br>          via: 192.168.30.1  # 默认网关<br>      dhcp4: false                           # 禁用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br><br>      link: ens37<br>      addresses:<br>        - 192.168.10.129/25<br></code></pre></td></tr></table></figure><p>配置完成后执行命令使配置生效。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo netplan apply<br></code></pre></td></tr></table></figure><p>执行<code>ifconfig</code>命令查看当前IP地址</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/41.png" alt="41"></p><h4 id="安装Radius服务器"><a href="#安装Radius服务器" class="headerlink" title="安装Radius服务器"></a>安装Radius服务器</h4><ol><li><p>下载Radius：</p><p>freeradius官方网站：<a href="http://freeradius.org/download.html">http://freeradius.org/download.html</a></p><p>freeradius官方文档：</p></li><li><p>解压：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">tar -zxvf freeradius-server-3.0.27.tar.gz <br></code></pre></td></tr></table></figure></li><li><p>安装依赖项</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install build-essential -y<br>sudo apt install libtalloc-dev -y<br>sudo apt install libssl-dev -y<br>sudo apt install libhiredis-dev -y<br>sudo apt install freeradius-mysql<br></code></pre></td></tr></table></figure></li><li><p>编译及安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd  freeradius-server-3.0.26<br>./configure <br>make<br>sudo make install # 默认安装在 /usr/local/etc/raddb下<br></code></pre></td></tr></table></figure></li><li><p>启动Radius</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">debug模式启动</span><br>sudo radiusd -X<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">后台进程方式启动</span><br>systemctl start radiusd<br>systemctl enable radiusd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">日志</span><br>/var/log/radius/radius.log <br></code></pre></td></tr></table></figure></li><li><p>添加用户</p><p>在 &#x2F;usr&#x2F;local&#x2F;etc&#x2F;raddb&#x2F;users 的末尾添加：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">test</span> 的用户设置明文密码为 <span class="hljs-string">&quot;test&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">user Cleartext-Password := <span class="hljs-string">&quot;password&quot;</span></span><br>test Cleartext-Password := &quot;test&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">radtest &lt;用户名&gt; &lt;密码&gt; &lt;服务器地址&gt; &lt;端口&gt; &lt;共享密钥&gt;</span><br>radtest testing password123 127.0.0.1 0 testing123  <br></code></pre></td></tr></table></figure><p>本地测试成功</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/34.png" alt="34"></p></li></ol><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>1.安装mariadb</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install mariadb-server mariadb-client<br>sudo systemctl start mariadb<br>sudo systemctl enable mariadb<br></code></pre></td></tr></table></figure><p>若此时直接运行安全设置<code>mysql_secure_installation</code>，则报错：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">xu@xu-virtual-machine:~/Desktop$ mysql_secure_installation<br><br>NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB<br>      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!<br><br>In order to log into MariaDB to secure it, we&#x27;ll need the current<br>password for the root user.  If you&#x27;ve just installed MariaDB, and<br>you haven&#x27;t set the root password yet, the password will be blank,<br>so you should just press enter here.<br><br>Enter current password for root (enter for none): <br>ERROR 1698 (28000): Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27;<br>Enter current password for root (enter for none): <br>Aborting!<br><br>Cleaning up...<br></code></pre></td></tr></table></figure><p>这是因为 MariaDB 默认使用 <strong><code>auth_socket</code> 插件</strong> 进行身份验证，它不接受通过普通密码登录，只通过 Unix 套接字进行验证。</p><p>解决方案：</p><ul><li><p>通过root用户登录:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo mysql -u root<br></code></pre></td></tr></table></figure></li><li><p>禁用 <code>auth_socket</code> 插件并设置密码:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo mysql<br>USE mysql;<br>SET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;1&#x27;);<br><span class="hljs-meta prompt_"># </span><span class="language-bash">刷新权限并退出</span><br>FLUSH PRIVILEGES;<br>EXIT;<br></code></pre></td></tr></table></figure></li></ul><p>​运行<code>mysql_secure_installation</code>进行安全设置：</p><img src="/images/接入网综合课设/35.png" alt="35" style="zoom: 80%;" /><ol start="2"><li>进入数据库</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p<br></code></pre></td></tr></table></figure><ol start="3"><li>创建数据库并授权</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">MariaDB [(<span class="hljs-keyword">none</span>)]<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> database radius；<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>MariaDB [(<span class="hljs-keyword">none</span>)]<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> radius.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> radius@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;radius&#x27;</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>MariaDB [(<span class="hljs-keyword">none</span>)]<span class="hljs-operator">&gt;</span> flush privileges;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h4 id="配置Radius服务器端和数据库"><a href="#配置Radius服务器端和数据库" class="headerlink" title="配置Radius服务器端和数据库"></a>配置Radius服务器端和数据库</h4><ol><li>导入数据库</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /usr/local/etc/raddb/mods-config/sql/main/mysql<br>mysql -u radius -p radius&lt; schema.sql<br></code></pre></td></tr></table></figure><p>如果报错：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">root@xu-virtual-machine:/usr/local/etc/raddb/mods-config/sql/main/mysql# mysql -u radius -p radius&lt; schema.sql<br>Enter password: <br>ERROR 1045 (28000): Access denied for user &#x27;radius&#x27;@&#x27;localhost&#x27; (using password: YES)<br></code></pre></td></tr></table></figure><p>这是因为 MySQL 用户 <code>radius</code> 在 <code>localhost</code> 上的访问被拒绝，重新设置密码</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;radius&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;your_password&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> radius.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;radius&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>配置Radius</p><ul><li><p>配置default文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo -i<br>gedit /usr/local/etc/raddb/sites-enabled/default<br></code></pre></td></tr></table></figure><p>使用数据库储存用户信息&#x2F;计费：</p><p>在538行authenticate {}部分，注释files，解注释sql</p><p>在673行accounting{}部分，解注释 sql</p></li><li><p>配置sql文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo -i<br>gedit /usr/local/etc/raddb/mods-available/sql<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置文件</span><br>tls_required = no<br>driver = &quot;rlm_sql_mysql&quot;  # 指定 FreeRADIUS 使用 MySQL 数据库作为后端数据库来进行认证和计费<br>dialect = &quot;mysql&quot;         # mysql 表示使用 MySQL 数据库的 SQL 方言<br>server = &quot;localhost&quot;      # 数据库运行在本地计算机上<br>port = 3306 <br>login = &quot;radius&quot;<br>password = &quot;radius&quot;<br>radius_db = &quot;radius&quot;<br>read_clients = yes         # 允许 FreeRADIUS 从数据库中读取客户端信息                                      、<br></code></pre></td></tr></table></figure></li></ul></li><li><p>客户端认证设置</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/raddb/clients.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">定义 PPPoE 客户端连接到服务器时需要使用的 IP 地址和密码（共享密钥）</span><br>client pppoe-server &#123;<br>    ipaddr = 192.168.30.1<br>    secret = testing123<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>配置组与用户信息</li></ol><ul><li>进入radius库</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo mysql -u root -p radius<br></code></pre></td></tr></table></figure><ul><li>新建组</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">insert into radgroupcheck (groupname,attribute,op,value) values  (&#x27;usr&#x27;,&#x27;Auth- Type&#x27;,&#x27;:=&#x27;,&#x27;Local&#x27;);<br>insert into radgroupcheck (groupname,attribute,op,value) values (&#x27;usr&#x27;,&#x27;Service-Type&#x27;,&#x27;:=&#x27;,&#x27;Framed-User&#x27;);<br>insert into radgroupcheck (groupname,attribute,op,value) values (&#x27;usr&#x27;,&#x27;Framed-IP-Address&#x27;,&#x27;:=&#x27;,&#x27;255.255.255.255&#x27;);<br>insert into radgroupcheck (groupname,attribute,op,value) values (&#x27;usr&#x27;,&#x27;Framed-IP-Netmask&#x27;,&#x27;:=&#x27;,&#x27;255.255.255.0&#x27;);<br></code></pre></td></tr></table></figure><p>查看新建组 <code>select * from radgroupcheck; </code></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/36.png" alt="36"></p><p>可以看到，<code>usr</code> 组的认证方式为 <strong>本地认证（Local）</strong>， <code>Service-Type</code> 为 Framed-User，即拨号用户，用于 <strong>PPP&#x2F;PPPoE 认证</strong>。分配给用户的 IP 地址为255.255.255.255，表示 不指定具体 IP 地址，由PPPoE 服务器动态分配。若分配了 IP 地址，默认子网掩码为 <code>255.255.255.0</code>。</p><ul><li><p>配置 RADIUS 认证用户</p><p>定义 RADIUS 用户，用于身份验证。</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/raddb/users<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对于 client-1</span><br>user1 Cleartext-Password := &quot;test-1&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">对于 client-2</span><br>user2 Cleartext-Password := &quot;test-2&quot;<br></code></pre></td></tr></table></figure><ul><li>插入用户</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> radcheck (username, attribute, op, <span class="hljs-keyword">value</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;user1&#x27;</span>, <span class="hljs-string">&#x27;Cleartext-Password&#x27;</span>, <span class="hljs-string">&#x27;:=&#x27;</span>, <span class="hljs-string">&#x27;test-1&#x27;</span>); <br><span class="hljs-keyword">INSERT INTO</span> radcheck (username, attribute, op, <span class="hljs-keyword">value</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;user2&#x27;</span>, <span class="hljs-string">&#x27;Cleartext-Password&#x27;</span>, <span class="hljs-string">&#x27;:=&#x27;</span>, <span class="hljs-string">&#x27;test-2&#x27;</span>); <br></code></pre></td></tr></table></figure><p>查看用户信息 <code>SELECT * FROM radcheck; </code></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/37.png" alt="37"></p><ul><li>关联用户和组</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> radusergroup (username, groupname) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;user1&#x27;</span>, <span class="hljs-string">&#x27;usr&#x27;</span>);<br><span class="hljs-keyword">INSERT INTO</span> radusergroup (username, groupname) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;user2&#x27;</span>, <span class="hljs-string">&#x27;usr&#x27;</span>);<br></code></pre></td></tr></table></figure><p>查看用户和组的关联信息 <code>SELECT * FROM radusergroup; </code></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/38.png" alt="38"></p><ul><li>建立软链接</li></ul><p>在 FreeRADIUS 服务器的配置目录中启用 SQL 模块</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo -i<br>cd /usr/local/etc/raddb/mods-enabled<br>ln -s /usr/local/etc/raddb/mods-available/sql ./<br></code></pre></td></tr></table></figure><p>查看软链接信息 <code>ls -l /usr/local/etc/raddb/mods-enabled/sql </code><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/39.png" alt="39"></p><ul><li>本地测试用户链接：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">radtest user1 test-1 127.0.0.1 0 testing123<br>radtest user2 test-2 127.0.0.1 0 testing123<br></code></pre></td></tr></table></figure><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/44.png" alt="44"></p><h4 id="配置Radius客户端"><a href="#配置Radius客户端" class="headerlink" title="配置Radius客户端"></a>配置Radius客户端</h4><ol><li>下载并安装RADIUS -clients</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wget ftp://ftp.freeradius.org/pub/freeradius/freeradius-client-1.1.7.tar.gz<br>tar -xzvf freeradius-client-1.1.7.tar.gz <br><br>cd freeradius-client-1.1.7/<br>./configure <br>sudo make<br>sudo make install<br></code></pre></td></tr></table></figure><ol start="2"><li>在 PPPoE 服务器中启用 RADIUS 认证</li></ol><p>​在&#x2F;etc&#x2F;ppp&#x2F;pppoe-server-options中增加</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加载 radius.so 插件</span><br>plugin /usr/lib/pppd/2.4.7/radius.so<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定 RADIUS 客户端配置文件</span><br>radius-config-file /usr/local/etc/radiusclient/radiusclient.conf<br></code></pre></td></tr></table></figure><ol start="3"><li>配置radiusclient.conf文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/radiusclient/radiusclient.conf<br></code></pre></td></tr></table></figure><p>在文件末尾添加：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">认证顺序：先本地认证，再 RADIUS 远程认证</span><br>auth_order      local,radius<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS 认证服务器</span><br>authserver      192.168.30.2:1812<br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS 计费服务器</span><br>acctserver      192.168.30.2:1813<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS 共享密钥存放</span><br>servers        /usr/local/etc/radiusclient/servers<br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS 共享密钥文件</span><br>seqfile        /var/run/radius.seq<br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS映射文件</span><br>mapfile        /usr/local/etc/radiusclient/port-id-map<br>dictionary     /usr/local/etc/radiusclient/dictionary<br>login_radius   /usr/local/sbin/login.radius<br></code></pre></td></tr></table></figure><ol start="4"><li>配置 server 文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/radiusclient/servers<br></code></pre></td></tr></table></figure><p>在文件末尾添加：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">[RADIUS服务器IP]  [共享密钥]  [可选参数]</span><br>192.168.30.2 testing123<br></code></pre></td></tr></table></figure><ol start="5"><li>配置dictionary文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/radiusclient/dictionary<br></code></pre></td></tr></table></figure><p>在文件末尾添加：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">INCLUDE /usr/local/etc/radiusclient/dictionary.sip<br>INCLUDE /usr/local/etc/radiusclient/dictionary.ascend<br>INCLUDE /usr/local/etc/radiusclient/dictionary.merit<br>INCLUDE /usr/local/etc/radiusclient/dictionary.compat<br>INCLUDE /usr/local/etc/radiusclient/dictionary.microsoft<br></code></pre></td></tr></table></figure><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><ul><li><p>PPPoE服务器启动情况</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/43.png" alt="43"></p></li><li><p>Radius服务器启动情况</p></li></ul><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/45.png" alt="45"></p><ul><li><strong>Client1</strong></li></ul><p>输入正确用户及密码（user1，test-1），拨号成功</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/46.png" alt="46"></p><p>PPPoE服务器已分配地址：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/47.png" alt="47"></p><p>上网测试：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/49.png" alt="49"></p><p>在Radius服务器端本次会话记录:</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/50.png" alt="50"></p><p>输入错误用户及密码（user1，test-2），拨号失败</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/51.png" alt="51"></p><p>在Radius服务器端本次会话记录:</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/53.png" alt="53"></p><ul><li><strong>Client2</strong></li></ul><p>输入正确用户密码（user2，test-2），拨号成功</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/46.png" alt="46"></p><p>PPPoE服务器已分配地址：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/48.png" alt="48"></p><p>上网测试：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/49.png" alt="49"></p><p>在Radius服务器端本次会话记录:</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/52.png" alt="52"></p><p>输入错误用户及密码（user2，test-1），拨号失败</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/51.png" alt="51"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/54.png" alt="54"></p><h4 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h4><p>RADIUS报文格式</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/55.png" alt="55"></p><p>RADIUS 报文类型分为 认证报文 和 计费报文：</p><p><strong>1. 认证报文（Authentication Messages）</strong></p><p>认证报文用于 <strong>用户身份验证</strong>，确保用户合法，并为其分配相应权限。常见类型如下：</p><table><thead><tr><th>报文类型</th><th>代码</th><th>作用</th></tr></thead><tbody><tr><td><strong>Access-Request</strong></td><td><code>1</code></td><td>认证请求，客户端（NAS）向 RADIUS 服务器发送，包含用户名、密码等信息</td></tr><tr><td><strong>Access-Accept</strong></td><td><code>2</code></td><td>认证通过，RADIUS 服务器返回，NAS 允许用户访问</td></tr><tr><td><strong>Access-Reject</strong></td><td><code>3</code></td><td>认证失败，RADIUS 服务器拒绝用户访问</td></tr><tr><td><strong>Access-Challenge</strong></td><td><code>11</code></td><td>质询认证，要求客户端提供额外凭证（如 EAP 认证）</td></tr></tbody></table><p>** 2. 计费报文（Accounting Messages）**</p><p>计费报文用于 <strong>记录用户上网时长、流量等信息</strong>，用于后续计费。常见类型如下：</p><table><thead><tr><th>报文类型</th><th>代码</th><th>作用</th></tr></thead><tbody><tr><td><strong>Accounting-Request</strong></td><td><code>4</code></td><td>计费请求，NAS 发送给 RADIUS 服务器，包含用户会话信息</td></tr><tr><td><strong>Accounting-Response</strong></td><td><code>5</code></td><td>计费响应，RADIUS 服务器收到计费信息后确认</td></tr></tbody></table><p><code>Accounting-Request</code> 又分为：</p><ul><li><strong>Start</strong>（用户上线）：用户开始上网时发送，记录 <code>acctstarttime</code>。</li><li><strong>Interim-Update</strong>（状态更新）：定期发送，更新流量、时长等数据。</li><li><strong>Stop</strong>（用户下线）：用户断开时发送，记录 <code>acctstoptime</code>、<code>acctsessiontime</code>、流量。</li></ul><p>RADIUS客户端与服务器交互过程：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/56.png" alt="56"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/57.png" alt="57"></p><p><strong>Access-Request</strong>：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/58.png" alt="58"></p><p><strong>Access-Accept</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/59.png" alt="59"></p><p><strong>Access-Reject</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/60.png" alt="60"></p><p><strong>Accounting-Request</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/61.png" alt="61"></p><p><strong>Accounting-Response</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/62.png" alt="62"></p><h4 id="遇到的问题及调试方法"><a href="#遇到的问题及调试方法" class="headerlink" title="遇到的问题及调试方法"></a>遇到的问题及调试方法</h4><p>在Radius全面配置好后，windows客户端无法直接拨号，否则显示691错误码，在radius端无信息反馈。推测PPPoE与客户端间传输存在问题。接回PPPoE本地测试可通。</p><p>使用<code>sudo tail -f /var/log/syslog | grep ppp</code>监听PPPoE服务器信息</p><p>当客户端拨号时，报错：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Apr  3 11:19:13 xu-virtual-machine pppd[2901]: rc_read_dictionary: invalid type on line 92 of dictionary /usr/local/etc/radiusclient/dictionary<br>Apr  3 11:19:13 xu-virtual-machine pppd[2901]: RADIUS: Can&#x27;t read dictionary file /usr/local/etc/radiusclient/dictionary<br>Apr  3 11:19:13 xu-virtual-machine pppd[2901]: Peer user2 failed CHAP authentication<br></code></pre></td></tr></table></figure><ul><li><p>把<code>/usr/local/etc/radiusclient/dictionary</code>文件中所有<code>ipv6addr</code>和<code>ipv6prdeix</code>改成<code>string</code></p></li><li><p>下载dictionary.microsoft，只有使用该文件才支持Windows拨号</p></li><li><p>在<code>/usr/local/etc/radiusclient/dictionary</code>末尾加上</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">INCLUDE /usr/local/etc/radiusclient/dictionary.sip<br>INCLUDE /usr/local/etc/radiusclient/dictionary.ascend<br>INCLUDE /usr/local/etc/radiusclient/dictionary.merit<br>INCLUDE /usr/local/etc/radiusclient/dictionary.compat<br>INCLUDE /usr/local/etc/radiusclient/dictionary.microsoft<br></code></pre></td></tr></table></figure><p>之后再拨号，Radius服务器端显示报错信息，根据具体报错信息修改即可。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;接入网综合课设&quot;&gt;&lt;a href=&quot;#接入网综合课设&quot; class=&quot;headerlink&quot; title=&quot;接入网综合课设&quot;&gt;&lt;/a&gt;接入网综合课设&lt;/h1&gt;&lt;h2 id=&quot;阶段一&quot;&gt;&lt;a href=&quot;#阶段一&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="课设" scheme="http://example.com/tags/%E8%AF%BE%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>网络算法基础</title>
    <link href="http://example.com/2025/02/27/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2025/02/27/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2025-02-27T06:35:01.000Z</published>
    <updated>2025-10-16T06:28:58.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法与分治"><a href="#算法与分治" class="headerlink" title="算法与分治"></a>算法与分治</h1><p>Divide and Conquer（DC）</p><p>Divide：将源问题分解为规模较小的子问题，<strong>拆分问题性质相同</strong>，将子问题的解组合成原问题的解。</p><p>Conquer：如果子问题仍然困难，就继续对子问题进行分解，直到子问题可以被trivial。</p><p>Recursion：用递归的方式实现。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>问题定义：</p><ul><li><p>输入：n个数构成的数组;</p></li><li><p>输出：排列该n个数的有序数组。</p></li></ul><p>Merg Sort：</p><ul><li>分解：将原数组等分为两个子数组;</li><li>求解：递归地对两个子数组分别排序;</li><li>合并：将两个已排序的子数组合并。</li></ul><h3 id="Merge-Step"><a href="#Merge-Step" class="headerlink" title="Merge Step"></a>Merge Step</h3><p> <strong>CLAIM</strong>：对于n ≥ 1的数组，MergeSort需要的运行时间T(n) ≤ $ 6n \log_2 n + 6n $</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/1.PNG" alt="图片" title="证明"></p><h3 id="函数增长的渐进符号"><a href="#函数增长的渐进符号" class="headerlink" title="函数增长的渐进符号"></a>函数增长的渐进符号</h3><p><strong>Big O</strong>: 如果存在正数c和N，对于所有的n&gt;&#x3D;N，有f(n)&lt;&#x3D;c*g(n)，则f(n)&#x3D;O(g(n))。</p><p><strong>Big Omega</strong>：如果存在正数c和N，对于所有的n&gt;&#x3D;N，有f(n)&gt;&#x3D;c*g(n)，则f(n)&#x3D;Omega(g(n))。</p><p><strong>Big Theta</strong>：f(n)&#x3D;Theta(g(n))，当且仅当f(n)&#x3D;O(g(n))且f(n)&#x3D;Omega(g(n))。</p><h3 id="基于比较的排序"><a href="#基于比较的排序" class="headerlink" title="基于比较的排序"></a>基于比较的排序</h3><p><strong>CLAIM</strong>：任何基于比较的排序算法，RT不可能低于O(nlogn)。</p><p>任何基于两两比较的排序算法都可以表达为一棵决策树（完全二叉树）。</p><p>完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/2.PNG" alt="图片" title="决策树的性质"></p><h3 id="主办法（Master-Method）"><a href="#主办法（Master-Method）" class="headerlink" title="主办法（Master Method）"></a>主办法（Master Method）</h3><p><strong>主定理</strong></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/3.PNG" alt="图片" title="主定理的定义"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/4.PNG" alt="图片" title="主定理的证明"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/5.PNG" alt="图片" title="参数"></p><h1 id="图简介"><a href="#图简介" class="headerlink" title="图简介"></a>图简介</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><strong>树</strong>：不包含任何圈的连通图。</p><p><strong>生成树(Spanning Tree)</strong>：如果图G的一个子图包含了G的全部顶点，且为树，则称之为G的生成树。</p><h2 id="图搜索"><a href="#图搜索" class="headerlink" title="图搜索"></a>图搜索</h2><h3 id="循环不变式"><a href="#循环不变式" class="headerlink" title="循环不变式"></a>循环不变式</h3><ul><li>概念：每次循环开始时都要保持的性质 &#x2F; 状态。</li><li><strong>INVARIANT</strong>：已探索集合和未探索集合应该处于正确的状态。边界点集合应准备好了。<ul><li>循环开始时，从边界点集合中选择一个顶点进行探索。</li><li>循环结束前，将新扩展的边界点纳入集合。</li></ul></li><li>维护边界点集合：<ul><li><strong>BFS：队列(FIFO)</strong></li><li><strong>DFS：堆栈(LIFO)</strong></li></ul></li></ul><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>BFS的伪代码：</p><pre><code>BFS(Graph, start):B.EnQueue(s)WHILE B is not empty:    d=B.DeQueue();    标记d为“已探索”    FOR each neighbor t of d:        IF t is not in visited:            B.EnQueue(t)        ENDIF    ENDFORENDWHILE</code></pre><p><strong>聚合分析复杂度</strong>：O(n+m)</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>DFS的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">DFS(Graph, start):<br>B.Push(s)<br>WHILE B is not empty:<br> d = B.Pop()<br> 标记 d 为“已探索”<br> FOR each neighbor t of d:<br>  IF t is not in visited:<br>   B.Push(t)<br>  ENDIF<br> ENDFOR<br>ENDWHILE<br></code></pre></td></tr></table></figure><p><strong>聚合分析复杂度</strong>：O(n+m)</p><h2 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h2><h3 id="无向图的连通分量"><a href="#无向图的连通分量" class="headerlink" title="无向图的连通分量"></a><u>无向图</u>的连通分量</h3><p>下述等价关系的等价类：当且仅当图中具有u-v路径时，称u~v。</p><h4 id="BFS求无向连通分量"><a href="#BFS求无向连通分量" class="headerlink" title="BFS求无向连通分量"></a>BFS求无向连通分量</h4><p>BFS求无向连通分量的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Loop-BFS(G):<br>FOR i=1 to n<br>IF t is not in visited:<br>BFS(G,i);<br>ENDFOR<br></code></pre></td></tr></table></figure><p><strong>聚合分析复杂度</strong>：O(n+m)</p><h3 id="有向图的强连通分量（Strongly-Connected-Component-SCC）"><a href="#有向图的强连通分量（Strongly-Connected-Component-SCC）" class="headerlink" title="有向图的强连通分量（Strongly Connected Component,SCC）"></a><u>有向图</u>的强连通分量（Strongly Connected Component,SCC）</h3><p>下述等价关系的等价类：当且仅当有向图G中具有u -&gt; v路径且具有v -&gt; u路径时，称称u~v。</p><h4 id="TWO-PASS算法-Kosaraju算法"><a href="#TWO-PASS算法-Kosaraju算法" class="headerlink" title="TWO-PASS算法(Kosaraju算法)"></a>TWO-PASS算法(Kosaraju算法)</h4><ol><li>构建逆图。</li><li><strong>在逆图中进行 Loop-DFS</strong>，记录每个节点的<strong>完成时间</strong> f(v)。</li><li><strong>在原图中运行 Loop-DFS</strong>，按照逆图 DFS 完成的节点顺序进行，确定每个节点的 Leader。</li></ol><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/6.PNG" alt="图片" title="Kosaraju算法-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/7.PNG" alt="图片" title="Kosaraju算法-2"></p><p><strong>聚合分析复杂度</strong>：O(n+m)</p><h4 id="关键引理"><a href="#关键引理" class="headerlink" title="关键引理"></a><strong>关键引理</strong></h4><p>Key Lemma：考虑有向图G中的两个临接SCC，f(v)表示顶点v在反向图G’中Loop-DFS的完成时间，则有：<br>$$<br>\max_{v \in C_1} f(v) &lt; \max_{v \in C_2} f(v)<br>$$<br>推论：最大的f值必然在”sink“SCC中。</p><h1 id="贪心MST"><a href="#贪心MST" class="headerlink" title="贪心MST"></a>贪心MST</h1><h2 id="贪心vs分治"><a href="#贪心vs分治" class="headerlink" title="贪心vs分治"></a>贪心vs分治</h2><ul><li><strong>决策过程</strong>：<ul><li><strong>分治</strong>：每个子问题的解都会考虑整个子问题的情况，逐步拆解，最终合并。</li><li><strong>贪心</strong>：每一步决策只关注当前的局部最优解，不回头。</li></ul></li><li><strong>全局与局部</strong>：<ul><li><strong>分治</strong>：每个子问题的解可能涉及整个问题的全局结构。</li><li><strong>贪心</strong>：每一步只考虑局部最优解，期望通过局部最优解得到全局最优解。</li></ul></li><li><strong>解决问题的方式</strong>：<ul><li><strong>分治</strong>：递归地分解问题，直到子问题足够简单直接求解。</li><li><strong>贪心</strong>：通过逐步选择当前最优的解来构建最终解。</li></ul></li><li><strong>是否需要回溯</strong>：<ul><li><strong>分治</strong>：通常会回溯并合并结果。</li><li><strong>贪心</strong>：不会回溯，一旦做出选择就不再修改。</li></ul></li></ul><h2 id="MST（前提：无向图）"><a href="#MST（前提：无向图）" class="headerlink" title="MST（前提：无向图）"></a>MST（前提：无向图）</h2><p><strong>定义</strong>：最小权重生成树T。</p><ul><li>必须是无向图;</li><li>生成树的权重定义为树上边权重之和;</li><li>生成树定义为E的子集：<ol><li>必须覆盖V;</li><li>无环;</li><li>连通。</li></ol></li></ul><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/8.PNG" alt="图片" title="MST"></p><h3 id="割"><a href="#割" class="headerlink" title="割"></a>割</h3><p>割的概念：图G(V，E)的一个割(Cut)是V的一个划分，该划分将集合V分为两个非空的集合。</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/9.PNG" alt="图片" title="割"></p><ul><li>n个顶点的图最多有 $ 2^n-2 $ 个不同的割。</li></ul><p><strong>Empty-Cut引理</strong>：图G不连通，当且仅当Cut(A，B)没有割边。</p><p><strong>Double-Crossing Lemma</strong>：如果某个圈C⊆E中有边跨越了Cut(A，B)，则C中<strong>至少还有一条边</strong>跨越Cut(A，B)。</p><p><strong>Lonely-Cut Corollary</strong>：如果边e是跨越了Cut(A，B)的唯一一条边，则e不可能在<strong>任一</strong>圈中。</p><p><strong>The Cut Property</strong>：考虑图G中的一条边e，如果存在Cut(A，B)，使得e是所有跨越该割的所有边中权最小者，则e一定在G的MST中。</p><p>割的证明：</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/10.PNG" alt="图片" title="割的证明-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/11.PNG" alt="图片" title="割的证明-2"></p><h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><p>一个容器，其中元素具有key。</p><p>常规操作及对应的RT：</p><ul><li>Heapify：建堆 O(n)</li><li>Insert：加入一个新的对象 O(logn)</li><li>Extract-Min：从堆中取出具有最小key的元素 O(logn)</li><li>Delete：删除指定元素 O(logn)</li></ul><h4 id="Heap-Property"><a href="#Heap-Property" class="headerlink" title="Heap Property"></a><strong>Heap Property</strong></h4><ul><li>堆是一颗有根，二叉，尽可能完全的树。</li><li>任何节点的key都不大于其所有子代的key。 ——&gt; <strong>根元素具有最小key</strong></li></ul><h4 id="用数组实现堆"><a href="#用数组实现堆" class="headerlink" title="用数组实现堆"></a><strong>用数组实现堆</strong></h4><ul><li>Parent (i) &#x3D; i &#x2F; 2  （下标i为奇数时向下取整）</li><li>LeftC (i) &#x3D; 2i</li><li>RightC (i) &#x3D; 2i + 1</li></ul><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/12.PNG" alt="图片" title="堆的操作-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/13.PNG" alt="图片" title="堆的操作-2"></p><h3 id="Prime算法"><a href="#Prime算法" class="headerlink" title="Prime算法"></a><strong>Prime算法</strong></h3><p>基本思想：</p><ul><li>从一个节点开始（任意选择一个节点作为起点），将它加入生成树。</li><li>找到当前生成树中所有节点与其他节点之间的边，选择权重最小的边。</li><li>将与该边相连的节点加入生成树，更新最小边的权重，重复选择最小边的过程。</li><li>直到所有节点都被加入到生成树中。</li></ul><p>Pim的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Prim(Graph, start):<br>    初始化最小生成树的边集合 MST = &#123;&#125;<br>    初始化一个优先队列 Q，用于存储每个节点及其最小边的权重<br>    对于每个节点 v ∈ Graph:<br>        设置 v 的最小权重为无穷大（∞）<br>    设置 start 节点的最小权重为 0，并将其加入 Q<br><br>    WHILE Q is not empty:<br>        选择 Q 中最小的权重的节点 u<br>        标记 u 为“已加入到最小生成树”<br><br>        对于 u 的每个邻居 v:<br>            IF v is not in MST AND weight(u, v) &lt; v 的当前权重:<br>                更新 v 的最小权重为 weight(u, v)<br>                将 v 更新到 Q 中，以反映其新的最小权重<br><br>        ENDFOR<br>    ENDWHILE<br></code></pre></td></tr></table></figure><p>Prim算法的证明：</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/14.PNG" alt="图片" title="Prim的证明-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/15.PNG" alt="图片" title="Prim的证明-2"></p><p>用堆实现Prim：</p><pre><code>Prim(Graph, start):    初始化最小生成树 MST = &#123;&#125;    初始化最小堆 MinHeap    初始化一个集合 Visited，用于记录已加入 MST 的节点    将 (0, start) 插入 MinHeap  // (边的权重, 节点)    初始化 total_weight = 0  // 记录最小生成树的总权重WHILE MinHeap is not empty:    (weight, node) = MinHeap.Pop()  // 取出当前权重最小的边    IF node 已在 Visited:        CONTINUE  // 如果该节点已经在 MST 中，跳过    标记 node 为已访问    total_weight += weight  // 累加权重    MST.Add(node)    FOR each (neighbor, edge_weight) in Graph[node]:  // 遍历邻居        IF neighbor 不在 Visited:            MinHeap.Push((edge_weight, neighbor))  // 只加入未访问的节点RETURN MST, total_weight</code></pre><p><strong>复杂度分析</strong>：</p><ul><li>n次Extract-Min：O(nlogn)</li><li>m次Delete和m次Insert：O(mlogn)</li></ul><p>总RT &#x3D; O(nlogn)+O(mlogn) &#x3D; <strong>O(mlogn)</strong></p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>基本思想：</p><ul><li>按权重升序对边排序。</li><li>按序逐条检查边。</li><li>只要不成环，就将边加入T。</li></ul><p>Kruskal的伪代码：</p><pre><code>Kruskal(Graph):    初始化最小生成树 MST = &#123;&#125;    初始化并查集（Union-Find）来管理连通性    按照权重从小到大排序 Graph 的所有边 EdgeListFOR (u, v, weight) in EdgeList:  // 遍历排序后的边    IF u 和 v 不在同一个连通分量 (Find(u) ≠ Find(v)):        MST.Add((u, v, weight))  // 加入最小生成树        Union(u, v)  // 合并连通分量    IF MST 的边数 == V - 1:        BREAK  // 最小生成树构建完成RETURN MST</code></pre><p>Kruskal算法的证明：</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/16.PNG" alt="图片" title="Kruskal的证明-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/17.PNG" alt="图片" title="Kruskal的证明-2"></p><h4 id="UNION-FIND算法"><a href="#UNION-FIND算法" class="headerlink" title="UNION-FIND算法"></a>UNION-FIND算法</h4><p>Union-Find（并查集）是一种高效的数据结构，主要用于<strong>处理动态连通性问题</strong>。它支持两种核心操作：</p><ol><li><strong>Find(x)</strong>：查找元素 <code>x</code> 所属的集合（返回它的代表元素）。</li><li><strong>Union(x, y)</strong>：合并 <code>x</code> 和 <code>y</code> 所在的两个集合。</li></ol><p>核心思想：</p><ul><li><strong>每个集合用一棵树表示</strong>，树的根节点作为该集合的<strong>代表元</strong>（代表元素）。</li><li><strong>Find(x)</strong> 操作用于查找 <code>x</code> 所在集合的代表元（根节点）。</li><li><strong>Union(x, y)</strong> 操作用于合并两个集合，<strong>将其中一个集合的根节点指向另一个集合的根</strong>。</li></ul><h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><p>Dijkstra的前提：<strong>无负权图（源点到第一层点的权重可为负值），避免负圈。</strong></p><p>Dijkstra的基本思路：</p><ol><li>初始化：</li></ol><ul><li>设 <code>dist[s] = 0</code>（起点到自身的距离为 0），其他所有点 <code>dist[v] = ∞</code>（起始时认为未知）。</li><li>用一个**优先队列（最小堆）**维护当前已发现的最短距离点。</li></ul><ol start="2"><li>贪心扩展：</li></ol><ul><li>每次从<strong>未访问的节点中选取当前 <code>dist[v]</code> 最小的点 <code>u</code></strong>。</li><li>遍历 u的所有邻居 v，尝试松弛：<ul><li><strong>如果 <code>dist[u] + w(u, v) &lt; dist[v]</code>，更新 <code>dist[v]</code></strong>，并将 <code>v</code> 加入优先队列。</li></ul></li></ul><ol start="3"><li>终止：所有节点均已访问，或优先队列为空（所有可达点已确定最短路径）。</li></ol><p>Dijkstra的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Dijkstra(Graph, start):<br>    初始化 dist[]，所有点设为 ∞，dist[start] = 0<br>    初始化优先队列 PQ，插入 (0, start)  // (当前最短距离, 顶点)<br>    初始化 visited[] 记录已确定最短路径的点<br><br>    WHILE PQ 不为空:<br>        (d, u) = PQ.Pop()  // 取出当前最短距离的点<br>        IF u 已访问:<br>            CONTINUE<br>        标记 u 为已访问<br><br>        FOR each 邻居 (v, weight) of u:<br>            IF dist[u] + weight &lt; dist[v]:  // 进行松弛操作<br>                dist[v] = dist[u] + weight<br>                PQ.Push((dist[v], v))  // 将 v 加入优先队列<br>    <br>    RETURN dist[]<br></code></pre></td></tr></table></figure><h2 id="循环桶"><a href="#循环桶" class="headerlink" title="循环桶"></a>循环桶</h2><p><strong>桶（Bucket）</strong> 是一种数据存储和分类的方法，可以根据某种规则（如哈希值、时间、范围等）<strong>将数据映射到不同的桶中</strong>，以加快查询、存储或计算的效率。</p><p>循环桶将数据按照一定规则分配到有限个桶（Bucket）中，并循环使用这些桶。</p><h3 id="循环桶的核心特点"><a href="#循环桶的核心特点" class="headerlink" title="循环桶的核心特点"></a>循环桶的核心特点</h3><ol><li>固定数量的桶（N 个）：<ul><li>设定 <code>N</code> 个桶，编号从 <code>0</code> 到 <code>N-1</code>，它们按照顺序<strong>排列成一个循环结构</strong>。</li><li>访问时<strong>基于取模（modulo）运算</strong>，保证访问永远落在 <code>0 ~ N-1</code> 之间。</li></ul></li><li>循环访问（Modulo 取模）：<ul><li>计算索引 <code>index = (当前时间 t) % N</code>，从而使得时间到了 <code>N</code> 之后会回到 <code>0</code>，形成循环管理。</li></ul></li></ol><h3 id="用循环桶实现Dijkstra算法："><a href="#用循环桶实现Dijkstra算法：" class="headerlink" title="用循环桶实现Dijkstra算法："></a>用循环桶实现Dijkstra算法：</h3><p><strong>CLAIM</strong>：Dijkstra算法中最多只需要C+1个桶。</p><ul><li>永久标记的顶点和非边界顶点不在桶中。</li><li>边界点的距离标记不会超过A[i]+C（i为当前标记点）</li><li>顶点x的桶的编号：A[x]mod(C+1)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Dijkstra_CircularBucket(Graph, start):<br>    初始化 dist[]，所有点设为 ∞，dist[start] = 0<br>    初始化桶 Bucket[]，桶的数量为 C+1，存储每个距离区间的节点<br>    初始化 visited[]，记录顶点是否已被永久标记<br>    <br>    将起点 start 放入 Bucket[0] 中（dist[start] = 0）<br>    <br>    WHILE 有节点未被永久标记:<br>        从桶中找出具有最小距离的非永久标记的边界点 u<br>        标记 u 为永久标记，并从桶中移除 u<br>        <br>        FOR 每个邻居 v of u:<br>            IF v 没有被永久标记:<br>                IF dist[u] + w(u, v) &lt; dist[v]:<br>                    dist[v] = dist[u] + w(u, v)  // 松弛操作<br>                    将 v 放入 Bucket[dist[v] mod (C + 1)] 中  // 根据 dist[v] 放入桶<br>                    更新 v 的距离标记<br><br>    RETURN dist[]<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：O(m+nC)</p><h2 id="Dijsktra算法扩展"><a href="#Dijsktra算法扩展" class="headerlink" title="Dijsktra算法扩展"></a>Dijsktra算法扩展</h2><h3 id="单源单宿最短路问题"><a href="#单源单宿最短路问题" class="headerlink" title="单源单宿最短路问题"></a>单源单宿最短路问题</h3><p>问题描述：给定图G，给定顶点s和d，求从s到d的最小权重路径。</p><p>解决方式：增加一个判断分支，d被永久标记时终止循环。</p><p>1111111111111111</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法与分治&quot;&gt;&lt;a href=&quot;#算法与分治&quot; class=&quot;headerlink&quot; title=&quot;算法与分治&quot;&gt;&lt;/a&gt;算法与分治&lt;/h1&gt;&lt;p&gt;Divide and Conquer（DC）&lt;/p&gt;
&lt;p&gt;Divide：将源问题分解为规模较小的子问题，&lt;stro</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
