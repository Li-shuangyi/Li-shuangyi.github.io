<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ether Blog</title>
  
  <subtitle>Welcome to Ether Blog !!!</subtitle>
  <link href="http://example.com/rss.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-10-16T06:28:32.507Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Li-shuangyi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>난장판插件食用说明</title>
    <link href="http://example.com/2025/10/09/%EB%82%9C%EC%9E%A5%ED%8C%90%E6%8F%92%E4%BB%B6%E9%A3%9F%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://example.com/2025/10/09/%EB%82%9C%EC%9E%A5%ED%8C%90%E6%8F%92%E4%BB%B6%E9%A3%9F%E7%94%A8%E8%AF%B4%E6%98%8E/</id>
    <published>2025-10-09T01:36:09.000Z</published>
    <updated>2025-10-16T06:28:32.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BASH文件"><a href="#BASH文件" class="headerlink" title="BASH文件"></a>BASH文件</h1><h2 id="切换环境"><a href="#切换环境" class="headerlink" title="切换环境"></a>切换环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&gt;&gt; switch environment &gt;&gt;&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">!! Contents within this block are managed by <span class="hljs-string">&#x27;conda init&#x27;</span> !!</span><br>function use_conda() &#123;<br>    __conda_setup=&quot;$(&#x27;/home/xx/anaconda3/bin/conda&#x27; &#x27;shell.bash&#x27; &#x27;hook&#x27; 2&gt; /dev/null)&quot;<br>    if [ $? -eq 0 ]; then<br>        eval &quot;$__conda_setup&quot;<br>    else<br>        if [ -f &quot;/home/xx/anaconda3/etc/profile.d/conda.sh&quot; ]; then<br>            . &quot;/home/xx/anaconda3/etc/profile.d/conda.sh&quot;<br>        else<br>            export PATH=&quot;/home/xx/anaconda3/bin:$PATH&quot;<br>        fi<br>    fi<br>    unset __conda_setup<br>    conda activate LCCNet2<br>    echo &quot;Conda 环境已激活&quot;<br>&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;&lt;&lt; <span class="hljs-string">conda initialize &lt;&lt;&lt;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&gt;&gt;&gt; fishros initialize &gt;&gt;&gt;</span></span><br>function use_ros() &#123;<br>    source /opt/ros/noetic/setup.bash<br>    echo &quot;ROS 环境已激活&quot;<br>&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;&lt;&lt; fishros initialize &lt;&lt;&lt;</span></span><br></code></pre></td></tr></table></figure><p>新的终端默认不source任何环境。在终端中输入<code>use_conda</code> 启动conda环境，输入<code> use_ros</code> 启动ros环境。</p><h1 id="COKKI数据集准备"><a href="#COKKI数据集准备" class="headerlink" title="COKKI数据集准备"></a>COKKI数据集准备</h1><h2 id="小主机"><a href="#小主机" class="headerlink" title="小主机"></a>小主机</h2><p>运行livox_ws下的脚本”record.sh”</p><h2 id="本地处理"><a href="#本地处理" class="headerlink" title="本地处理"></a>本地处理</h2><ul><li><p>把bag放在<code>[COKKIBag](../../../home/qi/ros_ws/src/COKKIDataset/COKKIBag)</code>路径下，命名为“xx_indoor”或“xx_outdoor”。</p></li><li><p>在PrepareCOKKI功能包中，修改<code>/config/bag_exporter_config.yaml</code>中<code>bag_path</code>&#x2F;<code>image_save_path</code>&#x2F;<code>bin_save_path</code>参数。</p></li><li><p>运行launch文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch cokkidataset cokkidataset.launch<br></code></pre></td></tr></table></figure></li><li><p>在<code>/home/qi/home/qi/ros_ws/src/COKKIDataset/sequences/xx</code>中筛选图片，确保点云和图片一一对应。将同一序列的indoor和outdoor数据放在一起，使用rename.py修改当前数据集ID。</p></li></ul><h1 id="VSCODE插件"><a href="#VSCODE插件" class="headerlink" title="VSCODE插件"></a>VSCODE插件</h1><h2 id="Bookmarks"><a href="#Bookmarks" class="headerlink" title="Bookmarks"></a>Bookmarks</h2><p>用于代码标记及标记之间的跳转。</p><p>在当前工作区中按<code>ctrl+shift+p</code>，输入<code>bookmarks</code>自定义快捷键：</p><ul><li><code>ctrl+alt+shift+k</code>：标记&#x2F;取消标记（蓝色标记图标）</li><li><code>shift+j</code>：跳转到上一个标记</li><li><code>shift+l</code>：跳转到下一个标记</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BASH文件&quot;&gt;&lt;a href=&quot;#BASH文件&quot; class=&quot;headerlink&quot; title=&quot;BASH文件&quot;&gt;&lt;/a&gt;BASH文件&lt;/h1&gt;&lt;h2 id=&quot;切换环境&quot;&gt;&lt;a href=&quot;#切换环境&quot; class=&quot;headerlink&quot; title=&quot;切</summary>
      
    
    
    
    
    <category term="食用说明" scheme="http://example.com/tags/%E9%A3%9F%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>더칠</title>
    <link href="http://example.com/2025/07/29/%EB%8D%94%EC%B9%A0/"/>
    <id>http://example.com/2025/07/29/%EB%8D%94%EC%B9%A0/</id>
    <published>2025-07-29T01:49:59.000Z</published>
    <updated>2025-10-13T08:28:21.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Current-To-Do"><a href="#Current-To-Do" class="headerlink" title="Current To Do"></a>Current To Do</h1><p>文献调研：</p><ul><li><p><input checked="" disabled="" type="checkbox"> Focus on 运动的云台相机+LiDAR的状态估计问题：</p><p>（1）有没有直接相关的可以用的工作？</p><p>（2）有没有类似的可以参考的工作？采用什么样的解决范式?</p></li></ul><p>硬件验证：</p><ul><li><input checked="" disabled="" type="checkbox"> （1）设计手持平台。</li><li><input checked="" disabled="" type="checkbox"> （2）调试云台。</li></ul><p>雷达相机配准:</p><ul><li><p><input disabled="" type="checkbox"> (1)  重构LCCNet库,在KITTI数据集上验证</p></li><li><p><input disabled="" type="checkbox"> (2)  在手持设备上录数据集</p></li><li><p><input disabled="" type="checkbox"> (3)  训练,在云台相机上验证</p></li></ul><h1 id="任务规划"><a href="#任务规划" class="headerlink" title="任务规划"></a>任务规划</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>硬件：</p><ol><li>云台：自稳，利于拍摄，变换视角<br>对比<strong>多个固定视角相机</strong>，引入额外成本&#x2F;重量，无人机测绘成像质量无法保证。<br>对比<strong>鱼眼相机</strong>，角分辨率低，点云着色精细程度低，模糊。</li><li>云台单目相机（兼顾成本重量成像质量，通过云台控制获得360°视野）+ mid360</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1.精确估计正在运动相机与雷达坐标系外参</p><p>（LIV SLAM综述 变动云台相机与雷达外参估计 有则复现测试效果，如果效果好，改变重点方向至自主探索）</p><h2 id="Setting"><a href="#Setting" class="headerlink" title="Setting"></a>Setting</h2><p>云台本身粗略位姿（时延+噪声） 动捕-真值LIO+VIO 因子图优化 LVI-SAM (LIO+VINS)</p><h1 id="文献调研"><a href="#文献调研" class="headerlink" title="文献调研"></a>文献调研</h1><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>综述</p><ol><li>基于深度学习的融合方案</li><li><strong>&lt;&lt;Automatic targetless LiDAR–camera calibration: a survey&gt;&gt;</strong></li></ol><p>​Automatic targetless LiDAR–camera calibration</p><table><thead><tr><th>类别</th><th>是否用标定板</th><th>是否需要人工操作</th><th>典型应用</th></tr></thead><tbody><tr><td>Manual Target-based</td><td>✅ 有标定板</td><td>✅ 人工干预</td><td>多视角棋盘格标定、人工点选角点</td></tr><tr><td>Automatic Target-based</td><td>✅ 有标定板</td><td>❌ 自动识别</td><td>自动识别 ArUco 标签、球形靶等</td></tr><tr><td>Manual Targetless</td><td>❌ 无标定板</td><td>✅ 人工点选匹配</td><td>人工选择特征点对、手动 PnP 配准</td></tr><tr><td>Automatic Targetless</td><td>❌ 无标定板</td><td>❌ 全自动</td><td>利用场景几何、图像相似性或学习方法自动完成</td></tr></tbody></table><p>Automatic Targetless分类</p><table><thead><tr><th>方法类别</th><th>适用环境</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>信息论</td><td>特征稀少</td><td>不依赖显式特征，适用性强</td><td>优化复杂，可能陷入局部最优</td></tr><tr><td>特征</td><td>特征丰富</td><td>精度高，易解释</td><td>对特征提取依赖大</td></tr><tr><td>自运动</td><td>动态平台</td><td>可利用运动信息标定</td><td>不适用于静态平台</td></tr><tr><td>学习</td><td>数据多、资源足</td><td>泛化强、自动化程度高</td><td>数据和计算资源需求大</td></tr></tbody></table><p><strong>基于自运动</strong></p><ol><li><p>基于手眼的方法</p></li><li><p>基于三维结构估计的方法</p></li><li><p>motion-guided method   computes the 2D parameters (x, y, yaw) from sensors’ incremental motions,</p></li></ol><p><strong>基于学习</strong> : DXQ-Net &#x2F; RGKCNet模型 &#x2F; 混合学习</p><ol start="3"><li><p>&lt;&lt;Camera, LiDAR, and IMU Based Multi-Sensor Fusion SLAM: A Survey&gt;&gt; </p><p>LVI-SAM &#x2F; R3LIVE</p></li><li><p>&lt;&lt;LiDAR, IMU, and camera fusion for simultaneous localization and mapping: a systematic review&gt;&gt;</p><p><strong>LIV</strong></p><p>Online Calibration</p><p>IMU作为中介：（如 Zuo et al. 2019, 2020）利用 IMU 作为桥梁，同时进行 IMU 与 LiDAR、IMU 与相机的标定。方法是在测量模型中引入外参，并将 IMU 测量传播到校正后的时间点。</p><p>两阶段标定： Wang and Ma (2022) 提出先对相机-IMU（CI）子模块进行标定，再通过插值将 CI 的位姿估计用于 LiDAR-IMU（LI）标定。</p><p>R3LIVE 系统：只进行 IMU 与相机的在线标定，并在相机的测量模型中引入时间偏差参数。</p><p>新同步方法：Tong et al. (2024) 提出了一种关键帧导向的数据同步方法，用于对齐 LiDAR 和相机的数据。</p></li><li><p>&lt;&lt;SLAM Overview: From Single Sensor to Heterogeneous Fusion&gt;&gt;</p></li></ol><ul><li><p>基于不确定性 : KF &#x2F; 图优化 &#x2F; 松耦合 &#x2F; 紧耦合</p></li><li><p>基于传统特征 : 基于ORB-SLAM框架 </p></li><li><p>基于深度学习 : CNN &#x2F; DNN &#x2F; 拟合图像深度估计方法LIMO: Lidar-Monocular Visual Odometry &#x2F; 三层BP神经网络 Improved SLAM Merged 2D and 3D Sensors for Mobile Robots &#x2F; 基于深度学习的回环检测算法 Role of Deep Learning in Loop Closure Detection for Visual and Lidar SLAM: A Survey.</p><p>LCCNet是 目前标定效果最好的神经网络,今年刚刚提出的ATOP 网络增加了注意力机制,其标定效果也值得关注。在未 来的发展中,注意力机制和优化算法是一个可以借鉴的 模块。与其他网络的迭代复杂度相比,目前制作的网络 更擅长实现轻量化,其最快响应时间平均可达0.073 s。</p></li></ul><p>多传感器融合</p><p>&lt;&lt;Multi-sensor Fusion Simultaneous Localization and  Mapping: A Systematic Review&gt;&gt;</p><ol><li><p>LC-SLAM</p><p>Online Calibration 实时估计 LiDAR 与相机之间的外参（</p><ol><li>特征匹配法（Feature-based）：<ul><li>Zhu 等人（2021）：提取 LiDAR 的深度、反射率和轮廓，与图像轮廓进行 ICP 对齐。</li><li>限制：要求 LiDAR 和相机视场（FOV）有重叠，受环境限制大。</li></ul></li><li>轨迹残差优化法（Trajectory Residual Optimization）：<ul><li>Chou 和 Chou（2022）：通过运动轨迹中的误差残差来优化外参，不依赖 FOV 重叠。</li></ul></li></ol></li></ol><p>Data Association : 将来自 LiDAR 的 3D 点与相机的 2D 图像信息有效匹配，用于姿态估计与地图构建。</p><ol><li><p>图像平面或中间帧投影：</p><ul><li>Graeter 等人（2018）LIMO：将 LiDAR 投影到图像平面，进行前景分割和局部平面拟合以获取深度。</li><li>Zhang 等人（2017）DEMO：将 2D 图像特征投影到单位球面，与 LiDAR 深度匹配。</li><li>中间帧：通常指以相机为中心的单位球面（适用于多视角处理）。</li></ul></li><li><p>基于学习的深度完成（Learning-based Depth Completion）：</p><ul><li>Aydemir 等人（2022）：提出自监督混合融合框架，降低纯旋转引起的误差。</li><li>An 等人（2022）：将点云转换为深度图，与 RGB 图像共同输入到姿态估计网络。</li><li>Liu 等人（2024）：设计双向融合网络，用于处理视觉与 LiDAR 的模态差异。</li></ul></li><li><p>LIC-SLAM</p><p>VIL-SLAM：使用 CI-SLAM 初始化 LiDAR 映射，闭环增强中不涉及模态协同。</p><p>SuperOdometry：引入 IMU 中心的三因子图结构（LI-SLAM、CI-SLAM、LIC-SLAM）进行统一优化。</p><p>R3LIVE &#x2F; FAST-LIVO：通过光度误差融合。</p><p>LVI-SAM ：基于因子图设计融合框架。</p><p>mVIL-Fusion：基于双滑动窗口设计融合框架。</p></li></ol><p>基于滤波（Filter-based）</p><ul><li>MSCKF、IESKF 框架。</li><li>多数系统起源于 IMU 传播，然后用 LiDAR 和相机观测更新状态。</li><li>R2LIVE、R3LIVE、FAST-LIVO。</li></ul><p>基于优化（Optimization-based）</p><ul><li>以因子图形式融合各模态信息，进行批量图优化。</li><li>LVI-SAM（融合 VINS-Mono 与 LIO-SAM）、mVIL-Fusion、CLIC（引入连续时间平滑）等。</li></ul><p>退化检测（Degeneracy）</p><ul><li>使用 Hessian 特征值判断状态不可观（如 CompSLAM）。</li><li>使用深度差、特征数等指标拒绝不可信观测（如 GR-Fusion、Switch-SLAM）。</li></ul><p>数据关联（Data Association）</p><ul><li>核心是将 LiDAR 深度与图像像素对齐。</li><li>方法包括：<ul><li>LiDAR 点投影到图像平面</li><li>使用 C-frame 或体素图（Voxel map）辅助关联</li><li>使用视觉子图与当前帧重投影误差估计深度（如 CoCoLIC）</li><li>处理遮挡与 LiDAR 重叠（如 FAST-LIVO）</li></ul></li></ul><p>特征融合（Feature Fusion）</p><ul><li>利用 LiDAR 和相机之间的共视特征进行联合跟踪和表示。</li><li>VILENS 引入统一的 3D 特征表示，R3LIVE 用光度残差优化 RGB 点云。</li></ul><p>在线标定（Online Calibration）</p><ul><li>多数 LIC-SLAM 系统实现 LiDAR-IMU 与 Camera-IMU 的在线标定。</li><li>标定方式包括：<ul><li>时间偏移建模（如 R3LIVE）</li><li>分阶段标定法（如 Yang &amp; Ma）</li><li>IMU 传播并嵌入外参模型（如 Zuo 等）</li></ul></li></ul><p>跨领域方法引入</p><ul><li>引入强化学习（Livo 使用 Actor-Critic 调节传感器权重）。</li><li>深度学习用于建模感知质量、辅助估计。</li><li>模糊逻辑系统处理不确定性与故障（ Nam 和 Gon-Woo 的 Type-2 模糊模型）。</li></ul><p>云台 </p><p><strong>拓展 : 多相机标定 DCC问题</strong></p><ol><li><p><strong>&lt;&lt;Autonomous Active Calibration of a Dynamic Camera Cluster using  Next-Best-View&gt;&gt;</strong></p><p>纯相机,自标定</p><p>手眼标定</p><blockquote><p>V. Pradeep, K. Konolige, and E. Berger, “Calibrating a multi-arm multi-sensor robot: A bundle adjustment approach,” in International Symposium on Experimental Robotics (ISER), 12&#x2F;2010 2010.</p></blockquote><p>Active Vision 系统 &#x2F; handdeye和Kinematic校准方法 &#x2F; 主动DCC校准 &#x2F; Next-Best-View</p></li></ol><p>​Setting : 不需要对配置空间进行离散化，而是在配置空间上进行连续优化，以选择次优视图。</p><ul><li><p>限制 :</p><ul><li><p>依赖准确的关节角度测量</p><p>现有基于next-best-view的DCC标定方法通常假设机械臂或云台的关节角度是已知且准确的，用于计算相机的位姿和规划下一视角。但在实际中，关节角度传感器（编码器）可能不存在或数据不准确，导致标定受限。</p></li><li><p>视角采样受限</p><p>next-best-view算法通过选择“局部最优”的下一视角来减少参数不确定性，但如果机械结构的运动范围有限或者存在物理阻碍，可能无法覆盖所有理想视角，影响标定质量。</p></li><li><p>计算复杂度高和实时性低</p></li><li><p>需要良好的初始估计</p></li></ul></li></ul><ol start="2"><li><p><strong>&lt;&lt;Encoderless Gimbal Calibration of Dynamic Multi-Camera Clusters&gt;&gt;</strong></p><p>以前的工作 : 依赖于编码器反馈来提取万向节电机的位置,需要关节角度来确定静态相机和驱动相机之间的运动学链。多旋翼无人机 (UAV) 上的许多现成万向节要么不提供关节角度信息,要么提供不精确的关节 角度测量,无法用于获得准确的 DCC 校准。</p><p>本文工作 : <strong>encoderless DCC</strong></p><ol><li>同时估计DCC的标定参数和每个观测配置下执行机构的关节角度。不再需要关节角度信息，该标定方法可以应用于任何类型的执行机构，从而使</li><li>在<code>Keyframe-based visual–inertial odometry using nonlinear optimization</code>中提出的基础上进行了扩展，将标定得到的DCC参数引入系统中，从而在估计VIO位姿状态的同时，估计云台的关节角度。</li></ol></li></ol><p>实验结果：采用DCC的整体位姿估计精度与SCC相当，且在性能上无显著差异。</p><p>云台相机的主动视角选择策略 :  Playle </p><blockquote><p>[26] N. Playle, “Improving the performance of monocular visual simultaneous  localisation and mapping through the use of a gimballed camera,”  Master’s thesis, University of Toronto (Canada), 2015.</p></blockquote><p>局限 : </p><ul><li>动态相机禁用了3D-2D RANSAC步骤</li></ul><p>​原本OKVIS算法中的3D-2D RANSAC用于剔除异常匹配，提高估计鲁棒性，依赖于固定的相机外参。但动态相机的外参是随时间变化的，RANSAC会剔除掉正是估计关节角度所需的关键观测，导致无法准确估计动态外参。</p><ul><li>缺乏更优的两阶段优化策略</li></ul><p>​当前方法未采用先不剔除异常值、估计动态外参，再用更新的外参重新优化的两阶段策略，限制了精度提升。</p><ul><li>关节角度估计存在明显的时间滞后</li></ul><p>​滞后尚未被充分解决。</p><ul><li>未使用运动模型或IMU输入</li></ul><p>​估计仅基于视觉数据，没有利用云台IMU信息或运动模型，限制了估计的时效性和准确度。</p><ol start="3"><li><strong>&lt;&lt;External Extrinsic Calibration of Multi-Modal Imaging Sensors: A Review&gt;&gt;</strong></li></ol><p>时间同步</p><p>(K. Römer, P. Blum, and L. Meier, ‘‘Time synchronization and calibration in wireless sensor networks,’’ in Handbook of Sensor Networks: Algorithms and Architectures. Hoboken, NJ, USA: Wiley, 2005, pp. 199–237.)提出了针对缺乏硬件同步功能的设备的方法。该方法涉及使用时间 插值来实现时间同步。记录每个设备的采样时间和频率信息,使用插值算法推断每个设备的时间戳,最终将它们拟合到时间曲线中。这种方法需要考虑设备之间的采样频率差异和延迟,以获得更准确的时间同步结果。</p><p>帧速率不稳定,被动同步。(E. Olson, ‘‘A passive solution to the sensor synchronization problem,’’ in Proc. IEEE&#x2F;RSJ Int. Conf. Intell. Robots Syst., Oct. 2010, pp. 1059–1064.)</p><p>基于运动的方法 </p><p>ICP和里程表方法的使用仍然较多,特 征匹配主要用于细化参数。</p><p>现有方法主要涉及传感器结构之间的匹配对应关系。包括里程计技术,例如Ishikawa等[109]和Park等[110]提出的视觉里程计、LiDAR里程计、GNSS里程计和惯性测量单元(IMU)等。根据传感器之间自运动信息的使用和现有文 献,基于自运动的方法主要可分为手眼标定和基于三维结构标定。</p><p><strong>手眼标定</strong></p><p>最常用 : quaternion representation proposed by Liao and Liu </p><p>Q. Liao and M. Liu, ‘‘Extrinsic calibration of 3D range finder and camera without auxiliary object or human intervention,’’ in Proc. IEEE Int. Conf. Real-Time Comput. Robot. (RCAR), Aug. 2019, pp. 42–47.</p><p><strong>基于结构的 3D 标定</strong></p><p>SFM(J. Iglhaut, C. Cabo, S. Puliti, L. Piermattei, J. O’Connor, and J. Rosette, ‘‘Structure from motion photogrammetry in forestry: A review,’’ Current Forestry Rep., vol. 5, no. 3, pp. 155–168, Sep. 2019.)从一系列 2D 图像中估计场景的 3D 结构。使用迭代最近点 (ICP) 算法将 SFM 点云与 LiDAR 点 云对齐,从而获得外部参数的初始估计。</p><p>SFM限制 : 将图像转换为3D点云可能会导 致点云稀疏,导致匹配率降低,如果再次使用ICP算法 ,误差会增加。可能的解决方案:将图像转换为点云时进行上采样</p><p>(J. Li, B. Yang, C. Chen, R. Huang, Z. Dong, and W. Xiao, ‘‘Automatic registration of panoramic image sequence and mobile laser scanning data using semantic features,’’ ISPRS J. Photogramm. Remote Sens., vol. 136, pp. 41–57, Feb. 2018.)提出了一种点云和图像 中语义特征的自动匹配方法,他们通过最大化两者之间 的重叠面积来细化参数,这样即使点云数量很少,也可 以通过重叠区域来迭代参数。此外,Nagy等(B. Nagy, L. Kovács, and C. Benedek, ‘‘SFM and semantic information based online targetless camera-LiDAR self-calibration,’’ in Proc. IEEE Int. Conf. Image Process. (ICIP), Sep. 2019, pp. 1317–1321.)在点 云配准阶段也利用了语义信息</p><ol start="4"><li><p>&lt;&lt;Real-Time Temporal and Rotational Calibration of  Heterogeneous Sensors Using Motion  Correlation Analysis&gt;&gt;</p><ul><li>提出了一种统一的、实时的时间错位校准方法，用于使用鲁棒的三维运动相关分析来进行异构多传感器组合。</li><li>基于相同三维相关分析机制中的时间校准结果，推导出外在旋转校准的闭式解。</li></ul><p>实时标定 :</p><p>[27] T. Qin and S. Shen, “Online temporal calibration for monocular visualinertial systems,” in Proc. IEEE&#x2F;RSJ Int. Conf. Intell. Robots Syst., 2018, pp. 3662–3669.</p></li></ol><p>背景 : </p><ul><li>传感器延迟（latency）普遍存在，不同传感器的延迟不一致，导致时间偏移（temporal offset）。</li><li>时间偏移会严重影响传感器融合的质量。</li><li>现有方法大多集中于<strong>估计时间偏移</strong>，而不是直接建模和处理传感器内部延迟。</li></ul><p>IMU-相机标定方法 ：</p><ul><li>[29]：使用B样条拟合轨迹，联合优化时间、空间外参（计算量大）。M. Fleps, E. Mair, O. Ruepp, M. Suppa, and D. Burschka, “Optimization based IMU camera calibration,” in Proc. IEEE&#x2F;RSJ Int. Conf. Intell. Robots Syst., 2011, pp. 3297–3304.</li><li>Kalibr [28]：最知名工具箱，批处理最大似然法，联合估计时间偏移+相机轨迹+外参，并估计不确定性。后来拓展到LiDAR、IMU等多种组合。P. Furgale, J. Rehder, and R. Siegwart, “Unified temporal and spatial calibration for multi-sensor systems,” in Proc. IEEE&#x2F;RSJ Int. Conf. Intell. Robots Syst., 2013, pp. 1280–1286.</li><li>[8]：先用1D旋转速率做时间初始化，再用闭式手眼法做外参估计，但精度有限，仅用于初始化。E. Mair, M. Fleps, M. Suppa, and D. Burschka, “Spatio-temporal initialization for IMU to camera registration,” in Proc. IEEE Int. Conf. Robot. Biomimetics, 2011, pp. 557–564.</li><li>[42]：使用粒子群优化做目标无关的标定（不依赖环境平面，支持非凸优化）；Z. Taylor and J. Nieto, “Automatic calibration of Lidar and camera images using normalized mutual information,” in Proc. IEEE Int. Conf. Robot. Autom., 2013.</li></ul><p>现有方法存在的问题 : </p><ul><li>闭式解难用于时间偏移估计，大多数只能用于空间外参。</li><li>迭代优化方法精度高，但计算量大，依赖良好初始值。</li><li>大部分方法默认数据已同步，无法同时处理时间+空间不一致的问题。</li></ul><p>本文方法：基于3D运动相关分析（motion correlation），进行更鲁棒、更精确的时间-空间标定，精度接近优化方法，但计算效率更高。</p><ul><li>不依赖目标板（targetless）</li><li>实时、高效</li><li>精度可媲美优化方法</li></ul><p>避免了常见的1D互相关或常速度假设的局限性</p><ol start="5"><li><p>&lt;&lt;Robust Online Calibration of LiDAR and Camera  Based on Cross-Modal Graph Neural Network&gt;&gt;</p><p>非正则标定框架,将标定问题视为稀疏图匹配问题。提出了一种包括跨模型图网络和多级图形约束在内的综合图结构,以准确估计标定参数。</p></li><li><p>&lt;&lt;Whole‐body motion planning and tracking of a mobile robot  with a gimbal RGB‐D camera for outdoor 3D exploration&gt;&gt;</p></li></ol><p>3D重建自主探索 云台相机 主动slam</p><p>基于地形感知MPC的视点跟踪控制器,以保证移动云台相 机的视点跟踪精度,提高在崎岖地形上的定位和探索鲁棒性</p><p>第一阶段总结方向 : </p><ol><li><strong>无目标的实时校准方法 targetless real-time calibration methods - 基于自运动</strong></li><li>DCC问题</li><li><strong>无目标的实时校准方法 targetless real-time calibration methods - 基于学习</strong></li><li>在线标定 (感觉只是用于修正微小偏移,恐怕不能用于实时改变外参)</li></ol><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><h3 id="基于自运动"><a href="#基于自运动" class="headerlink" title="基于自运动"></a>基于自运动</h3><p> targetless real-time calibration methods - 基于自运动</p><p><strong>&lt;&lt;Automatic targetless LiDAR–camera calibration: a survey&gt;&gt;</strong></p><p>一些方法试图找到激光雷达生成的轨迹与相机生成的轨迹之间的对应关系,使用激光雷达和视觉里程计技术,或IMU和GNSS测量 (Taylor 和 Nieto 2015;Ishikawa et al. 2018;Park et al. 2020).</p><ul><li>Taylor Z, Nieto J (2015) Motion-based calibration of multimodal sensor arrays. In: 2015 IEEE international conference on robotics and automation (ICRA). IEEE. <a href="https://doi.org/10.1109/icra.2015.7139872">https://doi.org/10.1109/icra.2015.7139872</a></li><li>Ishikawa R, Oishi T, Ikeuchi K (2018) LiDAR and camera calibration using motions estimated by sensor fusion odometry. In: 2018 IEEE&#x2F;RSJ international conference on intelligent robots and systems (IROS). IEEE. <a href="https://doi.org/10.1109/iros.2018.8593360">https://doi.org/10.1109/iros.2018.8593360</a></li><li>&#x2F;&#x2F; Park C, Moghadam P, Kim S, Sridharan S, Fookes C (2020) Spatiotemporal camera-LiDAR calibration: a targetless and structureless approach. IEEE Robot Autom Lett 5(2):1556–1563. <a href="https://doi.org/10">https://doi.org/10</a>. 1109&#x2F;lra.2020.2969164</li></ul><p>还有一些方法利用运动结构(SfM)方法从图像序列 中估计3D结构,从而将3D-2D LiDAR-相机数据配准转换为3D-3D案例(Swart et al. 2 011;Nagy et al. 2019a)</p><ul><li>Swart A, Broere J, Veltkamp R, Tan R (2011) Refined non-rigid registration of a panoramic image sequence to a LiDAR point cloud. In: Photogrammetric image analysis. Springer, Berlin, pp 73–84. <a href="https://doi/">https://doi</a>. org&#x2F;10.1007&#x2F;978-3-642-24393-6_7</li><li>Nagy B, Kovacs L, Benedek C (2019a) Online targetless end-to-end camera-LIDAR self-calibration. In: 2019 16th international conference on machine vision applications (MVA). IEEE. <a href="https://doi.org/10.23919/mva.2019.8757887">https://doi.org/10.23919/mva.2019.8757887</a></li></ul><p>手眼标定方法</p><p>三个阶段 : </p><p>Estimation of each sensor’s motion传感器位姿估计</p><ul><li><p>LiDAR : ICP&amp;雷达里程计 LOAM ORB-SLAM</p></li><li><p>相机 : SfM and visual odometry</p><ul><li><p>SFM : 存在尺度不确定性（scale ambiguity）在给定多张2D图像的情况下，SfM可以同时估计相机的位姿（位置和朝向）和稀疏的三维点云重建。</p><ul><li>Taylor Z, Nieto J (2015) Motion-based calibration of multimodal sensor arrays. In: 2015 IEEE international conference on robotics and automation (ICRA). IEEE. <a href="https://doi.org/10.1109/icra.2015.7139872">https://doi.org/10.1109/icra.2015.7139872</a></li><li>Park C, Moghadam P, Kim S, Sridharan S, Fookes C (2020) Spatiotemporal camera-LiDAR calibration: a targetless and structureless approach. IEEE Robot Autom Lett 5(2):1556–1563. <a href="https://doi.org/10.1109/lra.2020.2969164">https://doi.org/10.1109/lra.2020.2969164</a></li></ul></li><li><p>视觉里程计（Visual Odometry, VO） 的方法估计相机运动，利用连续图像帧（视频序列）。</p></li></ul><p>  ORB-SLAM</p><ul><li><p>Shi C, Huang K, Yu Q, Xiao J, Lu H, Xie C (2019a) Extrinsic calibration and odometry for camera-LiDAR systems. IEEE Access 7:120106–120116. <a href="https://doi.org/10.1109/access.2019.2937909">https://doi.org/10.1109/access.2019.2937909</a></p></li><li><p>Shi S, Wang X, Li H (2019b) PointRCNN: 3d object proposal generation and detection from point cloud. In: 2019 IEEE&#x2F;CVF conference on computer vision and pattern recognition (CVPR). IEEE. <a href="https://doi.org/10.1109/cvpr.2019.00086">https://doi.org/10.1109/cvpr.2019.00086</a></p></li><li><p><strong>Liao Q, Liu M (2019) Extrinsic calibration of 3d range finder and camera without auxiliary object or human intervention. In: 2019 IEEE international conference on real-time computing and robotics (RCAR). IEEE. <a href="https://doi.org/10.1109/rcar47638.2019.9044146">https://doi.org/10.1109/rcar47638.2019.9044146</a></strong></p></li><li><p>纯粹基于视觉的运动估计会面临尺度不确定性问题，需要依赖其他方法来解决尺度恢复问题 : </p><ul><li>Taylor Z, Nieto J (2016) Motion-based calibration of multimodal sensor extrinsics and timing offset estimation. IEEE Trans Rob 32(5):1215–1229. <a href="https://doi.org/10.1109/tro.2016.2596771">https://doi.org/10.1109/tro.2016.2596771</a></li><li>Ishikawa R, Oishi T, Ikeuchi K (2018) LiDAR and camera calibration using motions estimated by sensor fusion odometry. In: 2018 IEEE&#x2F;RSJ international conference on intelligent robots and systems (IROS). IEEE. <a href="https://doi.org/10.1109/iros.2018.8593360">https://doi.org/10.1109/iros.2018.8593360</a></li></ul></li></ul></li></ul><p>Estimation of the extrinsic parameter外参初值计算</p><ul><li>Taylor Z, Nieto J (2015) Motion-based calibration of multimodal sensor arrays. In: 2015 IEEE international conference on robotics and automation (ICRA). IEEE. <a href="https://doi.org/10.1109/icra.2015.7139872">https://doi.org/10.1109/icra.2015.7139872</a></li></ul><p>Refinement of extrinsic parameter外参优化</p><p>运动估计的偏差会影响校准结果并导致不准确</p><p>需要利用周围环境中的外观信息，如几何边缘对齐减少此类误差。</p><ul><li>利用图像和点云中的线特征，通过特征匹配来细化校准参数 :</li></ul><p>Liao Q, Liu M (2019) Extrinsic calibration of 3d range finder and camera without auxiliary object or human intervention. In: 2019 IEEE international conference on real-time computing and robotics (RCAR). IEEE. <a href="https://doi.org/10.1109/rcar47638.2019.9044146">https://doi.org/10.1109/rcar47638.2019.9044146</a></p><ul><li><p>对齐边缘 : </p><p>Levinson J, Thrun S (2013) Automatic online calibration of cameras and lasers. In: Robotics: science and systems IX. Robotics: Science and Systems Foundation. <a href="https://doi.org/10.15607/rss.2013.ix.029">https://doi.org/10.15607/rss.2013.ix.029</a></p></li><li><p>关联两种模态的数据强度 : </p><p>Pandey G, McBride JR, Savarese S, Eustice RM (2012) Automatic targetless extrinsic calibration of a 3d lidar and camera by maximizing mutual information. In: Twenty-sixth AAAI conference on artificial intelligence. <a href="https://doi.org/10.1609/aaai.v26i1.8379">https://doi.org/10.1609/aaai.v26i1.8379</a></p></li><li><p>传感器融合里程计 : </p><p>Ishikawa R, Oishi T, Ikeuchi K (2018) LiDAR and camera calibration using motions estimated by sensor fusion odometry. In: 2018 IEEE&#x2F;RSJ international conference on intelligent robots and systems (IROS). IEEE. <a href="https://doi.org/10.110">https://doi.org/10.110</a> 9&#x2F;iros.2018.8593360</p></li><li><p>Intensity matching : 通过互信息度量将 LiDAR 反射率与相机图像强度对齐</p><ul><li>Shi C, Huang K, Yu Q, Xiao J, Lu H, Xie C (2019a) Extrinsic calibration and odometry for camera-LiDAR systems. IEEE Access 7:120106–120116. <a href="https://doi.org/10.1109/access.2019.2937909">https://doi.org/10.1109/access.2019.2937909</a></li><li>Shi S, Wang X, Li H (2019b) PointRCNN: 3d object proposal generation and detection from point cloud. In: 2019 IEEE&#x2F;CVF conference on computer vision and pattern recognition (CVPR). IEEE. <a href="https://doi.org/10.1109/cvpr.2019.00086">https://doi.org/10.1109/cvpr.2019.00086</a></li></ul></li><li><p>Depth matching : 激光雷达深度图 中的任意点应与相机深度图中相同像素坐标的像素绑定</p><p>Xu H, Lan G, Wu S, Hao Q (2019) Online intelligent calibration of cameras and LiDARs for autonomous driving systems. In: 2019 IEEE intelligent transportation systems conference (ITSC). IEEE. <a href="https://doi.org/10.1109/itsc.2019.8916872">https://doi.org/10.1109/itsc.2019.8916872</a></p></li><li><p>Color matching : 最小化当前帧和前一帧中点颜色之间的平均差异。</p><p>Taylor Z, Nieto J (2016) Motion-based calibration of multimodal sensor extrinsics and timing offset estimation. IEEE Trans Rob 32(5):1215–1229. <a href="https://doi.org/10.1109/tro.2016.2596771">https://doi.org/10.1109/tro.2016.2596771</a></p></li><li><p>3D–2D point matching : 使用激光雷达相机外部参数进行3D-2D预测后,使用非线性优化改进结果。</p><p>Park C, Moghadam P, Kim S, Sridharan S, Fookes C (2020) Spatiotemporal camera-LiDAR calibration: a targetless and structureless approach. IEEE Robot Autom Lett 5(2):1556–1563. <a href="https://doi.org/10.1109/lra.2020.2969164">https://doi.org/10.1109/lra.2020.2969164</a></p></li></ul><p><img src="/../images/%EB%8D%94%EC%B9%A0/1.png" alt="图1-基于手眼的激光雷达-相机校准方法"></p><p style="text-align:center;">图1-基于手眼的激光雷达-相机校准方法</p><p>基于三维结构估计的方法</p><p>一种基于从全景图像和点云中提取的语义特征的自动配准方法 :即使点云数量很少,也可 以通过重叠区域来迭代参数</p><p><strong>Li J, Yang B, Chen C, Huang R, Dong Z, Xiao W (2018) Automatic registration of panoramic image sequence and mobile laser scanning data using semantic features. ISPRS J Photogramm Remote Sens 136:41–57. <a href="https://doi.org/10.1016/j.isprsjprs.2017.12.005">https://doi.org/10.1016/j.isprsjprs.2017.12.005</a></strong></p><p>一种具有对象级注册的外在校准方法,根据目标检测结 果在生成的点云和 LiDAR 点云之间引入目标级对齐 </p><ul><li><strong>Nagy B, Kovacs L, Benedek C (2019a) Online targetless end-to-end camera-LIDAR self-calibration. In: 2019 16th international conference on machine vision applications (MVA). IEEE. <a href="https://doi.org/10.23919/mva.2019.8757887">https://doi.org/10.23919/mva.2019.8757887</a></strong> </li><li><strong>Nagy B, Kovacs L, Benedek C (2019b) SFM and semantic information based online targetless camera-LIDAR self-calibration. In: 2019 IEEE international conference on image processing (ICIP). IEEE. <a href="https://doi.org/10.1109/icip.2019.8804299">https://doi.org/10.1109/icip.2019.8804299</a></strong></li></ul><p>在注册阶段的优化方面对他们之前的工作 进行了扩展。在对象级配准步骤之后,使用点级 ICP 方法设法减少配准误差, 然后在非均匀有理基样条近似的基础上引入基于曲线的非刚性点云配准细化步骤</p><p>Nagy B, Benedek C (2020) On-the-fly camera and lidar calibration. Remote Sens 12(7):1137. <a href="https://doi.org/10.3390/rs12071137">https://doi.org/10.3390/rs12071137</a></p><p>利用SFM方法通过点云对齐 和SIFT来找到感兴趣点的精确结果 : A. Swart, J. Broere, R. Veltkamp, and R. Tan, ‘‘Refined non-rigid registration of a panoramic image sequence to a LiDAR point cloud,’’ in Proc. ISPRS Conf. Photogramm. Image Anal. Berlin, Germany: Springer, Oct. 2011, pp. 73–84.</p><p>使用光束块精确的外部参数后使用3D-3D对准, 以便匹配 : W. Moussa, M. Abdel-Wahab, and D. Fritsch, ‘‘Automatic fusion of digital images and laser scanner data for heritage preservation,’’ in Proc. 4th Int. Conf. Prog. Cultural Heritage Preservation. Limassol, Cyprus: Springer, Oct.&#x2F;Nov. 2012, pp. 76–85.</p><p>连续场景信息和 SFM（Structure from Motion）+ ICP（Iterative Closest Point）来进行初始外参估计: </p><p>L. Wang, Z. Xiao, D. Zhao, T. Wu, and B. Dai, ‘‘Automatic extrinsic calibration of monocular camera and LiDAR in natural scenes,’’ in Proc. IEEE Int. Conf. Inf. Autom. (ICIA), Aug. 2018, pp. 997–1002.</p><p>其他方法</p><p>将高斯-Helmert模型应用于多传感器外在校准:</p><p>Huang K, Stachniss C (2017) Extrinsic multi-sensor calibration for mobile robots using the gauss-helmert model. In: 2017 IEEE&#x2F;RSJ international conference on intelligent robots and systems (IROS). IEEE. <a href="https://doi.org/10.1109/iros.2017.8205952">https://doi.org/10.1109/iros.2017.8205952</a></p><p>运动引导方法,用于自动校准两个多模态传感器:</p><p>Castorena J, Puskorius GV, Pandey G (2020) Motion guided LiDAR-camera self-calibration and accelerated depth upsampling for autonomous vehicles. J Intell Robot Syst 100(3–4):1129–1138. <a href="https://doi.org/10.1007/s10846-020-01233-w">https://doi.org/10.1007/s10846-020-01233-w</a></p><p>结合快速局部和全局优化方法来估计结果 : </p><p>Horn M, Wodtko T, Buchholz M, Dietmayer K (2021) Online extrinsic calibration based on per-sensor egomotion using dual quaternions. IEEE Robot Autom Lett 6(2):982–989. <a href="https://doi.org/10.1109/lra.2021.3056352">https://doi.org/10.1109/lra.2021.3056352</a></p><h3 id="基于学习"><a href="#基于学习" class="headerlink" title="基于学习"></a>基于学习</h3><table><thead><tr><th>模型简称</th><th>是否开源</th><th>发表时间</th><th>发表期刊</th></tr></thead><tbody><tr><td>RegNet</td><td><a href="%5Bhttps://github.com/aaronlws95/regnet%5D(https://link.zhihu.com/?target=https://github.com/aaronlws95/regnet)">非官方</a></td><td>2017</td><td>IV</td></tr><tr><td>CalibNet</td><td><a href="%5Bhttps://epiception.github.io/CalibNet%5D(https://link.zhihu.com/?target=https://epiception.github.io/CalibNet)">官方</a></td><td>2018</td><td>IROS</td></tr><tr><td>CMRNet</td><td>&#x2F;</td><td>2019</td><td>ITS</td></tr><tr><td>RGGNet</td><td><a href="%5Bhttps://github.com/KleinYuan/RGGNet%5D(https://link.zhihu.com/?target=https://github.com/KleinYuan/RGGNet)">官方</a></td><td>2020</td><td>RA-L</td></tr><tr><td>CalibRCNN</td><td><a href="%5Bhttps://github.com/zjut-jianhuazhang/CalibRCNN%5D(https://link.zhihu.com/?target=https://github.com/zjut-jianhuazhang/CalibRCNN)">官方部分代码</a></td><td>2020</td><td>IROS</td></tr><tr><td>CalibDNN</td><td>&#x2F;</td><td>2021</td><td>SPIE</td></tr><tr><td>LCCNet</td><td><a href="%5Bhttps://github.com/LvXudong-HIT/LCCNet%5D(https://link.zhihu.com/?target=https://github.com/LvXudong-HIT/LCCNet)">官方</a></td><td>2021</td><td>CVPR</td></tr><tr><td>CFNet</td><td>&#x2F;</td><td>2021</td><td>Sensors</td></tr><tr><td>DXQ-Net</td><td>&#x2F;</td><td>2022</td><td>arXiv preprint</td></tr></tbody></table><p>LCCNet性能是开源的方法中最好的一个, miscalibration的范围在±1.5m和±20°时达到了0.297cm和0.017°的标定精度（绝对平均误差），在单个GPU（GP100）上的运行时间为24ms。故初步想法为采用该方式进行雷达相机配准。</p><h1 id="A8mini云台相机"><a href="#A8mini云台相机" class="headerlink" title="A8mini云台相机"></a>A8mini云台相机</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>通信方式 : UDP</p><p>获取图像 : 拉取RTSP流,存在1s左右延迟,是否会有影响存疑</p><h2 id="相机库"><a href="#相机库" class="headerlink" title="相机库"></a>相机库</h2><p>网址 : <a href="https://github.com/Li-shuangyi/SIYIA8mini_SDK">https://github.com/Li-shuangyi/SIYIA8mini_SDK</a></p><p>函数介绍 : </p><p>查看接口只需看public</p><ul><li>类的初始化</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 构造函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">A8_Grabber</span>();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 析构函数</span><br><span class="hljs-comment"> */</span><br>~<span class="hljs-built_in">A8_Grabber</span>()&#123;&#125;;<br></code></pre></td></tr></table></figure><ul><li>设置相机</li></ul><p>修改分辨率&#x2F;码率&#x2F;运动模式</p><p>分辨率只支持特定格式:1080p(1920×1080),720p(1280×720)</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 初始化A8_mini相机</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 关闭A8_mini相机</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 展示A8_mini相机参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayCameraParam</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 设置A8_mini相机参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCameraParam</span><span class="hljs-params">(<span class="hljs-type">int</span> height = <span class="hljs-number">720</span>, <span class="hljs-type">int</span> width = <span class="hljs-number">1280</span>, <span class="hljs-type">int</span> bitrate = <span class="hljs-number">1570</span>, <span class="hljs-type">uint8_t</span> motionMode = <span class="hljs-number">4</span>)</span></span>;    <br></code></pre></td></tr></table></figure><ul><li>初始化图像</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 用默认参数初始化并开启RTSP流</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param timeout_ms 超时时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initGrabber</span><span class="hljs-params">(<span class="hljs-type">size_t</span> timeout_ms = <span class="hljs-number">1000</span>)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>获取图像</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 获取图像</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return cv::Mat 获取到的图像</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">cv::Mat <span class="hljs-title">getImg</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><ul><li>设置云台姿态</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 设置云台姿态角度 (CMD_ID: 0x0E)</span><br><span class="hljs-comment"> * @param yaw 目标偏航角度 (度，精度1位小数，范围：A8 mini为-135.0~135.0度)</span><br><span class="hljs-comment"> * @param pitch 目标俯仰角度 (度，精度1位小数，范围：A8 mini为-90.0~25.0度)</span><br><span class="hljs-comment"> * @return bool 设置是否成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">setGimbalAttitude</span><span class="hljs-params">(<span class="hljs-type">float</span> yaw, <span class="hljs-type">float</span> pitch)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>​    获取云台姿态</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 获取云台姿态数据 (CMD_ID: 0x0D)</span><br><span class="hljs-comment"> * @return GimbalAttitudeData 返回当前云台姿态数据，获取失败时所有值为0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">GimbalAttitudeData <span class="hljs-title">getGimbalAttitude</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h1 id="雷达相机配准"><a href="#雷达相机配准" class="headerlink" title="雷达相机配准"></a>雷达相机配准</h1><h2 id="复现LCCNet"><a href="#复现LCCNet" class="headerlink" title="复现LCCNet"></a>复现LCCNet</h2><h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><h3 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h3><p>官方github仓库 : <a href="https://github.com/IIPCVLAB/LCCNet">https://github.com/IIPCVLAB/LCCNet</a></p><blockquote><p>Requirements 要求</p><ul><li>python 3.6 (recommend to use <a href="https://www.anaconda.com/">Anaconda</a>)</li><li>PyTorch&#x3D;&#x3D;1.0.1.post2</li><li>Torchvision&#x3D;&#x3D;0.2.2</li><li>Install requirements and dependencies</li></ul></blockquote><p>该Requirements版本过于古早,许多旧版本已停止维护，新版 CUDA、驱动和系统库不再兼容，需要重构。</p><p>新版LCCNet代码 : <a href="https://github.com/Li-shuangyi/LCCNet.git">https://github.com/Li-shuangyi/LCCNet.git</a></p><h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><p>数据集准备 :</p><p>10000张 20个sequences,对应20个不同外参</p><p>1个sequence中含有500个data , 一个sequence的rosbag录13分钟左右</p><ul><li><p>室内 : 室外&#x3D;2 : 1</p></li><li><p>数据 : 验证 : 测试 &#x3D; 20 : 1 :2</p></li></ul><p>USB相机调试</p><p>用 v4l2 工具查询相机驱动支持的参数范围</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">v4l2-ctl -d /dev/video2 --all<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Driver Info:<br>Driver name      : uvcvideo<br>Card type        : USB 2.0 Camera: HD USB Camera<br>Bus info         : usb-0000:00:14.0-1.3<br>Driver version   : 5.15.85<br>Capabilities     : 0x84a00001<br>Video Capture<br>Metadata Capture<br>Streaming<br>Extended Pix Format<br>Device Capabilities<br>Device Caps      : 0x04200001<br>Video Capture<br>Streaming<br>Extended Pix Format<br>Priority: 2<br>Video input : 0 (Camera 1: ok)<br>Format Video Capture:<br>Width/Height      : 640/480<br>Pixel Format      : &#x27;YUYV&#x27; (YUYV 4:2:2)<br>Field             : None<br>Bytes per Line    : 1280<br>Size Image        : 614400<br>Colorspace        : sRGB<br>Transfer Function : Rec. 709<br>YCbCr/HSV Encoding: ITU-R 601<br>Quantization      : Default (maps to Limited Range)<br>Flags             : <br>Crop Capability Video Capture:<br>Bounds      : Left 0, Top 0, Width 640, Height 480<br>Default     : Left 0, Top 0, Width 640, Height 480<br>Pixel Aspect: 1/1<br>Selection Video Capture: crop_default, Left 0, Top 0, Width 640, Height 480, Flags: <br>Selection Video Capture: crop_bounds, Left 0, Top 0, Width 640, Height 480, Flags: <br>Streaming Parameters Video Capture:<br>Capabilities     : timeperframe<br>Frames per second: 30.000 (30/1)<br>Read buffers     : 0<br>                     brightness 0x00980900 (int)    : min=-64 max=64 step=1 default=0 value=50<br>                       contrast 0x00980901 (int)    : min=0 max=64 step=1 default=32 value=20<br>                     saturation 0x00980902 (int)    : min=0 max=128 step=1 default=60 value=60<br>                            hue 0x00980903 (int)    : min=-40 max=40 step=1 default=0 value=0<br> white_balance_temperature_auto 0x0098090c (bool)   : default=1 value=1<br>                          gamma 0x00980910 (int)    : min=72 max=500 step=1 default=100 value=72<br>                           gain 0x00980913 (int)    : min=0 max=100 step=1 default=0 value=0<br>           power_line_frequency 0x00980918 (menu)   : min=0 max=2 default=1 value=1<br>0: Disabled<br>1: 50 Hz<br>2: 60 Hz<br>      white_balance_temperature 0x0098091a (int)    : min=2800 max=6500 step=1 default=4600 value=4600 flags=inactive<br>                      sharpness 0x0098091b (int)    : min=0 max=6 step=1 default=2 value=2<br>         backlight_compensation 0x0098091c (int)    : min=0 max=2 step=1 default=1 value=1<br>                  exposure_auto 0x009a0901 (menu)   : min=0 max=3 default=3 value=3<br>1: Manual Mode<br>3: Aperture Priority Mode<br>              exposure_absolute 0x009a0902 (int)    : min=1 max=5000 step=1 default=157 value=5000 flags=inactive<br>         exposure_auto_priority 0x009a0903 (bool)   : default=0 value=1<br><br></code></pre></td></tr></table></figure><p>其中曝光相关部分：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">exposure_auto 0x009a0901 (menu)   : min=0 max=3 default=3 value=3<br>    1: Manual Mode<br>    3: Aperture Priority Mode<br><br>exposure_absolute 0x009a0902 (int)    : min=1 max=5000 step=1 default=157 value=5000 flags=inactive<br></code></pre></td></tr></table></figure><p>exposure_auto</p><ul><li>当前值 <code>3</code> 表示自动曝光。</li><li>如果要自己控制曝光，需要先把它改成 <code>1</code>（手动模式）。</li></ul><p>exposure_absolute</p><ul><li>范围：min&#x3D;1，max&#x3D;5000，步长&#x3D;1。</li><li><code>flags=inactive</code> 表示现在是自动模式，所以这个值无法直接修改。</li></ul><h2 id="坞-USB相机内参"><a href="#坞-USB相机内参" class="headerlink" title="坞-USB相机内参"></a>坞-USB相机内参</h2><p>camera_matrix: </p><p>780.4698491058430626.437330638860<br>0775.368847217801365.941771807725<br>001</p><p>dist_coeffs &#x3D; [0.0393591422301209-0.0496894143888718 0 0 0 ]</p><h2 id="FAST-Calib"><a href="#FAST-Calib" class="headerlink" title="FAST-Calib"></a>FAST-Calib</h2><p><strong>激光雷达到相机</strong>的外参转换关系</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>00-05序列训练出模型checkpoint_r1.00_t0.10_e263_0.006.tar,在06序列测试效果:</p><p>![951812eb9a4c4946214b9d673cffcdd](..&#x2F;..&#x2F;..&#x2F;.deepinwine&#x2F;Spark-weixin&#x2F;dosdevices&#x2F;c:&#x2F;users&#x2F;qi&#x2F;Documents&#x2F;WeChat Files&#x2F;wxid_ytt3frlwah0322&#x2F;FileStorage&#x2F;Temp&#x2F;951812eb9a4c4946214b9d673cffcdd.png)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Current-To-Do&quot;&gt;&lt;a href=&quot;#Current-To-Do&quot; class=&quot;headerlink&quot; title=&quot;Current To Do&quot;&gt;&lt;/a&gt;Current To Do&lt;/h1&gt;&lt;p&gt;文献调研：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;inp</summary>
      
    
    
    
    
    <category term="project" scheme="http://example.com/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>复现FAST-LIVO2</title>
    <link href="http://example.com/2025/07/04/%E5%A4%8D%E7%8E%B0FAST-LIVO2/"/>
    <id>http://example.com/2025/07/04/%E5%A4%8D%E7%8E%B0FAST-LIVO2/</id>
    <published>2025-07-04T06:26:07.000Z</published>
    <updated>2025-10-16T06:13:56.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目名称-FAST-LIVO2复现"><a href="#项目名称-FAST-LIVO2复现" class="headerlink" title="项目名称 : FAST-LIVO2复现"></a>项目名称 : FAST-LIVO2复现</h1><h2 id="任务规划"><a href="#任务规划" class="headerlink" title="任务规划"></a>任务规划</h2><ul><li><p>设备:</p><ol><li>Livox AVIA</li><li>Livox Converter 2.0</li><li>海康相机MV-CS020-10UC</li></ol></li><li><p>硬件:</p><ol><li><p>手持设备支架设计(Solidworks)</p></li><li><p>STM32硬同步流程</p></li><li><p>相机-Lidar标定</p></li></ol></li><li><p>软件:</p><ol><li>环境,build</li><li>录包,跑包</li></ol></li></ul><h2 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h2><h3 id="FAST-LIVO"><a href="#FAST-LIVO" class="headerlink" title="FAST-LIVO"></a>FAST-LIVO</h3><ul><li><p>LIO 子系统: 反向传播补偿 LiDAR 扫描的运动畸变,计算帧到地图点到平面的残差。</p></li><li><p>VIO 子系统: 提取当前 FoV 中的视觉子映射,剔除异常值。</p></li><li><p>视觉对齐: 稀疏直接图像对齐,比较光流误差。</p></li><li><p>紧密耦合: 点到平面残差和图像光度误差与误差状态iKF中的IMU传播紧密耦合。</p></li><li><p>ikdTree添加新点至全局映射。</p><img src="../images/复现FAST-LIVO2/1.png" alt="图1-FAST-LIVO系统概述图" style="zoom: 50%;" /><p style="text-align:center;">图1-FAST-LIVO系统概述图</p></li></ul><h3 id="FAST-LIVO2"><a href="#FAST-LIVO2" class="headerlink" title="FAST-LIVO2"></a>FAST-LIVO2</h3><h4 id="新贡献"><a href="#新贡献" class="headerlink" title="新贡献"></a>新贡献</h4><ol><li><p>问题 : 激光雷达和视觉测量之间维度不匹配 (测量维度 &#x2F; 数据类型 &#x2F; 分布特性) , 而 FAST-LIVO中使用异步更新。</p><p>解决方案 : ESIKF框架,惯顺序更新(sequential update)。</p></li><li><p>问题 : FAST-LIVO中假设图像块中所有像素共享相同深度,该假设降低了对齐中仿射变换的准确性。</p><p>解决方案 : 使用并进一步优化来自激光雷达点的平面先验。</p></li><li><p>问题: FAST-LIVO 基于与当前视图的接近度选择参考块,导致参考块低质量,降低了准确性。</p><p>解决方案 : 提出了一种参考块 Reference Patch 更新策略 ,通过选择具有大视差和足够纹理细节的高质量内点参考块提高图像对齐的准确性。</p></li><li><p>问题 : 环境光照变化会降低图像对齐中的收敛性,FAST-LIVO中未解决该问题。</p><p>解决方案 : 在线曝光时间估计。</p></li><li><p>问题 : 激光雷达近距离盲区造成激光雷达点测量缺失,FAST-LIVO中未考虑该问题。</p><p>解决方案 : 提出按需进行体素射线投射的方法，以增强系统在因激光雷达近距离盲区造成的激光雷达点测量缺失情况下的鲁棒性。 </p><img src="../images/复现FAST-LIVO2/34.png" alt="图2-FAST-LIVO2系统概述图" style="zoom:67%;" /></li></ol><p style="text-align:center;">图2-FAST-LIVO2系统概述图</p><h4 id="Section-4-顺序更新的ESIKF"><a href="#Section-4-顺序更新的ESIKF" class="headerlink" title="Section 4 顺序更新的ESIKF"></a>Section 4 顺序更新的ESIKF</h4><ol><li><p>扫描重组 Scan Recombination</p><ol><li><p>将$t_k-1$时刻到$t_k$时刻的所有激光点都合并到$t_k$时刻。</p><p>将高频、连续采样的LiDAR原始点云数据，按照相机采样时刻进行分割，从而得到与相机采样时刻对应的独立LiDAR扫描帧。    </p></li><li><p>通过硬同步使雷达和相机采样一致</p><p>激光雷达和相机在$t_k-1$ 时刻同时触发采集，但相机在瞬间完成采集，激光雷达则在$t_k$时刻才完成一帧数据。虽然触发时间相同，系统实际处理的是$t_k$时刻图像与延迟 $t$ (约100ms) 的激光雷达帧。</p></li></ol></li><li><p>传播 Propagation</p></li></ol><img src="../images/复现FAST-LIVO2/35.png" alt="图3-前向传播与反向传播示意图" style="zoom: 33%;" /><p style="text-align:center;">图3-前向传播与反向传播示意图</p><p>​1. 前向传播：KF在预测阶段将噪声$W_i$ 设为0，预测$t_k-1$ 到$t_k$ 这段时间每个IMU输入时的状态。由KF预测可得此时状态量为$\hat{x}$，状态量对应的协方差$\hat{P}$作为更新阶段的先验。</p><p>​2. 反向传播 : 补偿激光雷达运动畸变，确保所有的点都是在tk时刻观测到的。</p><p>​运动畸变 : 由于激光雷达在移动过程中分时采点，若忽略每个点的具体采集时间,统一视为同一时刻采样，会导致点云在空间上的扭曲或错位。</p><img src="../images/复现FAST-LIVO2/36.png" alt="图4-反向传播示意图" style="zoom:67%;" /><p style="text-align:center;">图4-反向传播示意图</p><p>​3. 顺序更新 : 利用激光雷达测量细化的状态将被更新地图的几何结构，该状态将在视觉更新被进一步收敛，其中视觉更新将在每个金字塔层面上进行，每层都要收敛。最终得到的状态被用于传播新到来的IMU测量，并更新地图的视觉结构（纹理）。</p><h4 id="Section-5-局部建图"><a href="#Section-5-局部建图" class="headerlink" title="Section 5 局部建图"></a>Section 5 局部建图</h4><ol><li><p>地图结构 Map Structure</p><img src="../images/复现FAST-LIVO2/37.png" alt="图5-Voxel Map示意图" style="zoom: 33%;" /><p style="text-align:center;">图5-Voxel Map示意图</p></li></ol><p>​<strong>自适应体素结构</strong>,按照哈希表和每个哈希条目的八叉树组织。</p><p>​哈希表管理根体素,每一个根体素为0.5x0.5x0.5m的固定维度,每个根体素包含一个八叉树结构。叶体素代表一个局部平面,存储一个平面特征(即平面中心、法向量和不确定性),以及一组位于该平面上的激光雷达原始点。<strong>叶体素的不同大小使其能够表示不同尺度的局部平面,从而适应具有不同结构的环境</strong>。部分点与三级图像块(8×8图块大小)相连(即视觉地图点),收敛的视觉地图点仅与参考块关联，未收敛的点与参考块和其他可见块都关联。</p><p>​为了防止地图大小无限增长,设置初始地图范围后, 在该范围进行进行探测和建图，当雷达探测范围触碰到范围边界，局部地图范围会在该边界方向上移动d距离。存储的A处点云数据将被重置为C处的数据,保持内存大小固定。每次ESIKF更新后检查一次地图是否移动。</p><img src="../images/复现FAST-LIVO2/38.png" alt="图6-局部地图滑动示意图" style="zoom: 50%;" /><p style="text-align:center;">图6-局部地图滑动示意图</p><p><em>在(a)中,灰色矩形是初 始地图区域,长度为 L。红色圆圈是以 p0 为中心的初始 检测区域。在(b)中,检测区域移动到新位置 p1,在此位 置触碰到地图边界。地图区域移动到新位置(蓝色矩形) ,移动距离为 d。在(c)中,内存空间B保持不变。存储绿色区域的内存空间A被重置为(b)中的蓝色区域C。</em></p><ol start="2"><li><p>几何构造及更新 : <strong>基于ESIKF对激光雷达点测量构建和更新实现</strong><a name="Section5-2"></a></p><p>在ESIKF中的激光雷达更新后,将激光雷达扫描的所有点注册到全局坐标系中。对于每个注册的激光雷达点,确定其在哈希图中的根体素位置。</p><ul><li><p>如果不存在,用新点初始化该体素并将其索引到哈希图中。</p></li><li><p>如果确定的体素已经存在于地图中, 将该点附加到现有体素中。</p></li></ul><p>在所有扫描中的点分配完成后,进行几何构建和更新。</p><ol><li><p>对于新创建的体素</p><p>通过奇异值分解来确定其所有包含的点是否位于一个平面上。</p><ul><li>如果是,计算中心点 $ q &#x3D; p ̄$ 、平面法线 $n$ 和平面的协方差矩阵$ Σ_{n,q} $。$ Σ_{n,q} $ 用于表征平面不确定性 (平面不确定性源于姿态估计的不确定性和点测量噪声)。</li><li>如果不是,体素将不断细分为八个更小的八分体,直到子体素中的点被确定为形成一个平面或达到最大层数。达到最大层数后,叶体素中的点将被丢弃。</li><li><strong>地图仅包含被识别为平面的体素(根体素或子体素)。</strong></li></ul></li><li><p>对于已存在的体素</p><p>评估新的点和已有的点能否构建为一个平面</p><ul><li>如果否：和前面一样，对体素进行划分。</li><li>如果是：更新平面参数和协方差。</li><li><strong>一旦平面参数是收敛的，该平面将被视为成熟面，平面参数将被视为固定，平面上的新点将被丢弃。</strong></li></ul></li><li><p>平面上的激光雷达点生成视觉地图点</p><ul><li><p>对于成熟的平面,最近的50个雷达点是生成视觉地图点的候选者。</p></li><li><p>对于未成熟的平面,所有雷达点都是候选者。</p></li><li><p>视觉地图点生成过程将识别其中一些候选点作为视觉地图点,并将它们与图像块附加以进行图像对齐。</p></li></ul></li></ol></li><li><p>视觉地图点生成和更新</p><p>选择地图中的候选激光雷达点用于生成和更新。(<a href="#Section7-1">详见第Section 7-1</a>)</p><p>候选点条件:</p><ol><li>在当前帧视角可见</li><li>在当前图像中表现出显著灰度梯度</li></ol><p>在视觉更新后,将候选点投影到当前图像上,并<strong>在每个体素中保留最小深度的候选点作为局部平面。将当前图像划分为每个30 × 30像素的均匀网格单元。</strong></p><ul><li><p>若一个栅格元没有包含任何投影到这的视觉地图点,则使用<strong>带有最高灰度梯度的候选点新建一个新的视觉地图点</strong>。将该点与当前图像块、估计的当前状态（位姿&#x2F;曝光时间）以及平面法向量相关联。与视觉地图点相关联的块有三个相同大小的层（每层11x11像素）,构成块金字塔。</p></li><li><p>若一个栅格元包含了投影的视觉地图点，并满足以下条件之一就添加新的块到当前视觉地图点上:</p><ol><li>超过20帧没有添加新的块到视觉地图点。</li><li>视觉地图点在当前帧中的像素位置比其在上一个块的位置相差至少40像素（晃得太厉害，点在屏幕里移动了一大段距离，重新拍一张）。</li></ol></li></ul><p><strong>地图点将拥有视角分布均匀的有效块Patch。</strong></p></li><li><p>Reference Patch 参考块更新 : 一个视觉地图点会拥有不止一个块。需要选择一个作为参考块用于视觉更新中的图像对齐，基于光度相似性和视角给每个块 f 评分。在所有附加到视觉地图点的Patch中,得分最高的Patch被更新为参考块。</p></li></ol><p>   上述评分机制倾向于选择:</p><pre><code>1. 外观与大多数其他补丁相似(以NCC为标准)的参考补丁, 以避免动态目标上的补丁;2. 视角方向与平面正交,从而在高分辨率下保持纹理细节。</code></pre><p>   FAST-LIVO 中的参考块更新策略直接选择与当前帧视角方向差异最小的补丁,导致所选参考补丁与当前帧非常接近,从而对当前姿态更新施加了弱约束。</p><ol start="5"><li><p>法向量细化</p><p>每个视觉地图点都被假设位于一个小的局部平面上。（以前的研究假设像素块上的所有像素拥有同样深度）</p><p>使用源于雷达点的平面参数取得更好的精度<a href="#Section5-2">(详见第Section 5-2)</a>。 </p><p>平面法向量对于视觉更新过程中的图像仿射变换对齐至关重要,平面法向量细化能够增强仿射变换的精度。 </p><p>具体：<strong>通过最小化参考块与视觉地图点关联的其他块之间的光度误差，来优化参考块中的平面法向量。</strong></p></li></ol><h4 id="Section-6-激光雷达测量模型"><a href="#Section-6-激光雷达测量模型" class="headerlink" title="Section 6 激光雷达测量模型"></a>Section 6 激光雷达测量模型</h4><p>用于ESIKF LiDAR更新的LiDAR测量模型$y_l &#x3D; h_l(x, v_l)$。</p><ol><li><p>点到平面的雷达测量模型</p><ul><li><p>投影无畸变点到世界系;</p></li><li><p>确定该世界点所在哈希图的根&#x2F;子体素，并构建观测公式</p><p>如果没有体素被发现或该体素不包含平面则丢弃该点。 否则，构建该体素中平面与这个点的观测公式。 假设一个激光真值点，准确的到世界系变换阵，这个点与平面中心点应该是在一个平面上的。</p></li><li><p>带入激光点测量和噪声，平面法向量估计和中心点估计及协方差,</p><p>得到测量噪声的形式:$v_l&#x3D;(δ^L\mathbf{p}_j,δ\mathbf{n}_j,δ\mathbf{q}_j)$</p></li></ul></li><li><p>带有光束发散效应的Lidar测量噪声</p><p>测量噪声主要由两个元素构成，飞行时间导致的测距不确定性和编码导致的轴承方向不确定性，除此外，还有激光的发散角度。随着方位方向与法向量之间的角度 $φ$的增加，激光雷达点的测距不确定性显著增加，而方位方向的不确定性不受影响。当从地面和墙面选的点更多时，位姿估计的精度更高。 <strong>$φ$越小越好</strong>。</p></li></ol><h4 id="Section-7-视觉测量模型"><a href="#Section-7-视觉测量模型" class="headerlink" title="Section 7 视觉测量模型"></a>Section 7 视觉测量模型</h4><p>用于ESIKF视觉更新的视觉测量模型$y_c &#x3D; h_c(x, v_c)$。</p><p>1.视觉地图点选择<a name="Section7-1"></a></p><p>为了视觉更新中的稀疏对齐，首先选择合适的视觉地图点。 </p><ul><li><p>使用体素和投射查询来提取当前相机FoV中的可见的地图点集合（视觉的子地图）。 </p></li><li><p>来自这个子地图中视觉地图点将被挑选并剔除离群点。 </p></li><li><p>这个过程能够为<strong>视觉测量模型中构建视觉光度误差提供一个精细的视觉地图点集合</strong>。</p><ol><li><p>可见体素的查询 : </p><p>问题: 地图中体素数量庞大,从地图中的大量体素中确定当前帧FoV中的地图体素困难。</p><p>解决：利用当前LiDAR扫描直接命中的体素作为候选，大幅减少需处理的体素数量。 </p><p>实现：1、使用测量的点位置来查询体素哈希表</p><p>​       2、筛选上一图像帧中通过相同体素查询和光线投射确认为可见的地图点所命中的体素。 </p><p>最后,通过检查这两种体素中包含的地图点并进行视场检查,得到当前的视觉子图。</p></li><li><p>按需投射 :</p><img src="../images/复现FAST-LIVO2/39.png" alt="图7-按需体素光线投射的示意图" style="zoom: 67%;" /><p style="text-align:center;">图7-按需体素光线投射的示意图</p><p>当雷达距离目标太近而没有点返回时&#x2F;摄像机FOV可能不会被激光雷达FOV完全覆盖。流程如下 :</p><ol><li><p>图像划分<br>将图像划分为30x30的均匀栅格元，投影体素查询获得的视觉地图点到栅格元上。</p></li><li><p>对未被占据栅格元的射线投射<br>对于每个未被视觉地图点占据的栅格元，光线沿着中心像素向后投射，其中采样点沿着光线在深度方向上从dmin到dmax均匀分布</p></li><li><p>降低计算量<br>相机机体系下每个光线上的采样点的位置都被预先算好了。</p></li><li><p>处理每个采样点<br>对每个采样点，评估其对应的体素状态：<br>若该体素包含投影后位于此网格单元内的地图点，则将这些地图点纳入视觉子地图，并终止当前射线的处理。<br>否则：继续射线上的下一个采样点，直到达到最大深度DMAX。</p></li><li><p>所有未被占据栅格元处理完成<br>获得了一组在整个图像上分布的视觉地图点集合。</p></li></ol></li><li><p>视觉地图点中离群点剔除</p><img src="../images/复现FAST-LIVO2/40.png" alt="图8-剔除离群点示意图" style="zoom: 67%;" /><p style="text-align:center;">图8-剔除离群点示意图</p><p>存在的问题: 将会严重降低图像对齐精度</p><p>​    (1) 在当前帧中被遮挡</p><p>​    (2) 存在深度不连续性</p><p>​    (3) 拥有这些点的参考块采集视角过大</p><p>​    (4) 在当前帧中观测视角过大</p><ol><li><p>投影所有点–解决问题1</p><p>在雷达更新后，将子图中的所有视觉地图点用位姿投影至当前帧，并在每个栅格元中保留深度最小的点。</p></li><li><p>深度图–解决问题2</p><p>将当前雷达帧的点投影至当前帧生成深度图，用9x9的邻域在深度图中比较视觉地图点的深度，并判断遮挡和深度变化。被占据的&#x2F;深度不连续的点将被剔除。</p></li><li><p>点移除–解决问题3&amp;4</p><p>移除参考块与当前块的视角太大（法向量与从视觉地图点到块光学中心的方向之间的角度超过80°）的点。</p></li></ol></li></ol></li></ul><ol start="2"><li>稀疏直接的视觉测量模型</li></ol><p>上面提取的视觉地图点 {$G_{pi}$} 用于构建视觉测量模型。 其基本原理是,利用真值状态将地图点投影至当前图像，参考块与当前块之间的光度误差应当为0. </p><p>要根据测量方程估算反向曝光时间 $τ_k$，将初始反向曝光时间固定为 $τ_0$ &#x3D; 1 ，以消除方程在所有反向曝光时间都为零时的退化现象。后续帧的估计反向曝光时间是相对于第一帧的曝光时间。测量方程被用于三个层次的视觉更新步骤,估计的状态随后用于生成可视化地图点和更新参考块。</p><h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><p>雷达点云格式</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// roslaunch livox_ros_driver livox_lidar.launch / livox_ros_driver2所有launch</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LivoxPoint</span> &#123;<br>    <span class="hljs-type">float</span> x;<br>    <span class="hljs-type">float</span> y;<br>    <span class="hljs-type">float</span> z;<br>    <span class="hljs-type">uint8_t</span> reflectivity;   <span class="hljs-comment">// 反射率</span><br>    <span class="hljs-type">uint8_t</span> tag;            <span class="hljs-comment">// 标志位</span><br>    <span class="hljs-type">uint8_t</span> line;           <span class="hljs-comment">// 扫描线编号</span><br>&#125;;<br><br><span class="hljs-comment">// roslaunch livox_ros_driver livox_lidar_msg.launch</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CustomMsg</span> &#123;<br>    <span class="hljs-type">uint64_t</span> timebase;      <span class="hljs-comment">// 当前包的基准时间</span><br>    <span class="hljs-type">uint32_t</span> point_num;     <span class="hljs-comment">// 点数</span><br>    <span class="hljs-type">uint8_t</span>  lidar_id;      <span class="hljs-comment">// 雷达ID</span><br>    <span class="hljs-type">uint8_t</span>  rsvd[<span class="hljs-number">3</span>];       <span class="hljs-comment">// 保留</span><br>    std::vector&lt;LivoxPoint&gt; points;<br>&#125;;<br></code></pre></td></tr></table></figure><p>结构体：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StatesGroup</span><br>&#123;<br>    M3D rot_end;     <span class="hljs-comment">// 姿态（旋转矩阵），表示当前时刻的坐标系方向</span><br>    V3D pos_end;     <span class="hljs-comment">// 位置（世界系坐标）</span><br>    V3D vel_end;     <span class="hljs-comment">// 速度（世界系坐标）</span><br>    <span class="hljs-type">double</span> inv_expo_time; <span class="hljs-comment">// 逆曝光时间 (通常和相机或雷达扫描速度相关)</span><br>    V3D bias_g;      <span class="hljs-comment">// 陀螺仪零偏</span><br>    V3D bias_a;      <span class="hljs-comment">// 加速度计零偏</span><br>    V3D gravity;     <span class="hljs-comment">// 重力向量（世界坐标系下的估计）</span><br>    Matrix&lt;<span class="hljs-type">double</span>, DIM_STATE, DIM_STATE&gt; cov; <span class="hljs-comment">// 状态协方差</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="LIVMapper-h-LIVMapper-cpp"><a href="#LIVMapper-h-LIVMapper-cpp" class="headerlink" title="LIVMapper.h &#x2F; LIVMapper.cpp"></a>LIVMapper.h &#x2F; LIVMapper.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">LIVMapper类：<br><span class="hljs-comment">//------------初始化----------------------</span><br><span class="hljs-comment">// 初始化Subscribers和Publishers</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LIVMapper::initializeSubscribersAndPublishers</span><span class="hljs-params">(ros::NodeHandle &amp;nh, image_transport::ImageTransport &amp;it)</span></span>;<br><span class="hljs-comment">// 初始化参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LIVMapper::initializeComponents</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 文件初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initializeFiles</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 对齐重力</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LIVMapper::gravityAlignment</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 处理第一帧</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleFirstFrame</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 选择当前模式（LIO/VIO/LIVO）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stateEstimationAndMapping</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 处理VIO帧外部接口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleVIO</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 处理LIO帧外部接口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleLIO</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 处理IMU数据外部接口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processImu</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    sync_packages → 时间切割LiDAR → 数据准备 → handleLIO → SLAM处理</span><br><span class="hljs-comment">                                          ↓</span><br><span class="hljs-comment">                                      handleVIO → 视觉处理</span><br><span class="hljs-comment">**/</span><br><span class="hljs-comment">// 多传感器数据同步</span><br><span class="hljs-comment">// LIO处理：IMU切分</span><br><span class="hljs-comment">// VIO处理：图像时间同步至LIO</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sync_packages</span><span class="hljs-params">(LidarMeasureGroup &amp;meas)</span></span>;<br><span class="hljs-comment">// 前向传播</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prop_imu_once</span><span class="hljs-params">(StatesGroup &amp;imu_prop_state, <span class="hljs-type">const</span> <span class="hljs-type">double</span> dt, V3D acc_avr, V3D angvel_avr)</span></span>;<br><span class="hljs-comment">// imu状态传播回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">imu_prop_callback</span><span class="hljs-params">(<span class="hljs-type">const</span> ros::TimerEvent &amp;e)</span></span>;<br><br><span class="hljs-comment">// 将LiDAR点云从机体坐标系变换到世界坐标系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transformLidar</span><span class="hljs-params">(<span class="hljs-type">const</span> Eigen::Matrix3d rot, <span class="hljs-type">const</span> Eigen::Vector3d t, <span class="hljs-type">const</span> PointCloudXYZI::Ptr &amp;input_cloud, PointCloudXYZI::Ptr &amp;trans_cloud)</span></span>;<br><span class="hljs-comment">// 将单个点云从机体坐标系变换到世界坐标系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pointBodyToWorld</span><span class="hljs-params">(<span class="hljs-type">const</span> PointType &amp;pi, PointType &amp;po)</span></span>;<br><span class="hljs-comment">// 将单个RGB点云从机体坐标系变换到世界坐标系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RGBpointBodyToWorld</span><span class="hljs-params">(PointType <span class="hljs-type">const</span> *<span class="hljs-type">const</span> pi, PointType *<span class="hljs-type">const</span> po)</span></span>;<br><br><span class="hljs-comment">// 点云回调函数</span><br><span class="hljs-comment">// LivoxPoint格式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">standard_pcl_cbk</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::PointCloud2::ConstPtr &amp;msg)</span></span>;<br><span class="hljs-comment">// CustomMsg格式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">livox_pcl_cbk</span><span class="hljs-params">(<span class="hljs-type">const</span> livox_ros_driver::CustomMsg::ConstPtr &amp;msg_in)</span></span>;<br><br><span class="hljs-comment">// imu回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">imu_cbk</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::Imu::ConstPtr &amp;msg_in)</span></span>;<br><span class="hljs-comment">// 图像回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">img_cbk</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::ImageConstPtr &amp;msg_in)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="IMU-Processing-h-IMU-Processing-cpp"><a href="#IMU-Processing-h-IMU-Processing-cpp" class="headerlink" title="IMU_Processing.h &#x2F; IMU_Processing.cpp"></a>IMU_Processing.h &#x2F; IMU_Processing.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 结构体 class ImuProcess</span><br><br><span class="hljs-comment">//  IMU数据处理主函数（外部接口）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ImuProcess::Process2</span><span class="hljs-params">(LidarMeasureGroup &amp;lidar_meas, StatesGroup &amp;stat, PointCloudXYZI::Ptr cur_pcl_un_)</span></span>;<br><span class="hljs-comment">// 点云去畸变（前向传播+反向传播）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ImuProcess::UndistortPcl</span><span class="hljs-params">(LidarMeasureGroup &amp;lidar_meas, StatesGroup &amp;state_inout, PointCloudXYZI &amp;pcl_out)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="vio-h-vio-cpp"><a href="#vio-h-vio-cpp" class="headerlink" title="vio.h &#x2F; vio.cpp"></a>vio.h &#x2F; vio.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 结构体 VIOManager</span><br><br><span class="hljs-comment">// 更新当前帧，将系统的IMU状态转换为相机帧的变换矩阵</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VIOManager::updateFrameState</span><span class="hljs-params">(StatesGroup state)</span></span>;<br><br><span class="hljs-comment">// 网格</span><br><span class="hljs-comment">// 特征检测：新帧图像 → 网格划分 → 每个网格内检测特征 → 控制特征密度</span><br><span class="hljs-comment">// 特征匹配：当前帧特征 → 定位网格 → 在对应网格内搜索匹配 → 提高匹配效率</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VIOManager::processFrame</span><span class="hljs-params">(cv::Mat &amp;img, vector&lt;pointWithVar&gt; &amp;pg, <span class="hljs-type">const</span> unordered_map&lt;VOXEL_LOCATION, VoxelOctoTree *&gt; &amp;feat_map, <span class="hljs-type">double</span> img_time)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="订阅器"><a href="#订阅器" class="headerlink" title="订阅器"></a>订阅器</h3><p><strong>sub_pcl</strong><br>livox_pcl_cbk() - Livox LiDAR回调函数</p><ul><li>功能：处理Livox品牌激光雷达的自定义点云消息</li><li>消息类型：livox_ros_driver::CustomMsg</li></ul><p>standard_pcl_cbk()- 标准点云回调函数</p><ul><li>功能：处理标准ROS点云消息（如Velodyne、Ouster等）</li><li>消息类型：<code>sensor_msgs::PointCloud2</code></li></ul><p><strong>sub_imu</strong></p><p>imu_cbk() - IMU回调函数</p><ul><li>功能：处理惯性测量单元数据</li><li>消息类型：sensor_msgs::Imu</li></ul><p><strong>sub_img</strong></p><p>img_cbk() - 图像回调函数</p><ul><li>功能：处理相机图像数据</li><li>消息类型：sensor_msgs::Image</li></ul><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LIVMapper <span class="hljs-title">mapper</span><span class="hljs-params">(nh)</span></span>; <br>mapper.<span class="hljs-built_in">initializeSubscribersAndPublishers</span>(nh, it);<br>mapper.<span class="hljs-built_in">run</span>();<br></code></pre></td></tr></table></figure><p><strong>雷达-相机外参用于VIO（第5&#x2F;7部分）</strong></p><p>函数setLidarToCameraExtrinsic</p><h2 id="本机环境-和Fast-Livo2无关"><a href="#本机环境-和Fast-Livo2无关" class="headerlink" title="本机环境 (和Fast-Livo2无关)"></a>本机环境 (和Fast-Livo2无关)</h2><p>只是电脑又坏了。</p><ol><li><p>NVIDIA驱动 : </p><ul><li><p><strong>关闭bios security boot</strong></p></li><li><p>在命令行模式下删除之前安装的nvidia驱动</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Ctrl + Alt + F3<br>sudo systemctl stop gdm<br>sudo apt-get purge &#x27;^nvidia-.*&#x27;<br>sudo apt-get autoremove<br>sudo rm -rf /etc/X11/xorg.conf<br>sudo rm -rf /lib/modules/$(uname -r)/kernel/drivers/video/nvidia*<br>sudo rm -rf /usr/src/nvidia*<br>sudo rm -rf /usr/share/doc/NVIDIA_GLX-1.0*<br>sudo rm -rf /usr/share/man/man1/nvidia*<br>sudo rm -rf /usr/bin/nvidia*<br>sudo rm -rf /etc/modprobe.d/blacklist-nvidia.conf<br></code></pre></td></tr></table></figure></li><li><p>重新安装,选择recommend的版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo ubuntu-drivers devices # 查看可以使用的驱动版本<br></code></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reboot<br></code></pre></td></tr></table></figure></li><li><p>检查</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nvidia-smi<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="NUC环境搭建"><a href="#NUC环境搭建" class="headerlink" title="NUC环境搭建"></a>NUC环境搭建</h2><h3 id="1-修网卡"><a href="#1-修网卡" class="headerlink" title="1. 修网卡"></a>1. 修网卡</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">fast@fast:~/WIFI/backport-iwlwifi$ lspci | grep -i wireless<br>fast@fast:~/WIFI/backport-iwlwifi$ lsmod | grep iwl<br></code></pre></td></tr></table></figure><p>系统没有识别出无线网卡设备,疑似硬件问题.最后使用网线上网.</p><h3 id="2-依赖项"><a href="#2-依赖项" class="headerlink" title="2. 依赖项"></a>2. 依赖项</h3><ul><li><p>PCL&gt;&#x3D;1.8, Follow <a href="https://pointclouds.org/">PCL Installation</a>.</p></li><li><p>Eigen&gt;&#x3D;3.3.4, Follow <a href="https://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen Installation</a>.</p></li><li><p>OpenCV&gt;&#x3D;4.2, Follow <a href="http://opencv.org/">Opencv Installation</a>.</p></li><li><p>Livox_SDK2 :</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/Livox-SDK/Livox-SDK2.git<br>cd ./Livox-SDK2/<br>mkdir build<br>cd build<br>cmake .. &amp;&amp; make -j<br>sudo make install<br></code></pre></td></tr></table></figure></li><li><p>Sophus : Sophus Installation for the non-templated&#x2F;double-only version.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/strasdat/Sophus.git<br>cd Sophus<br>git checkout a621ff<br>mkdir build &amp;&amp; cd build &amp;&amp; cmake ..<br>make<br>sudo make install<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-工作空间配置"><a href="#3-工作空间配置" class="headerlink" title="3. 工作空间配置"></a>3. 工作空间配置</h3><p>Avia只支持livox_ros_driver</p><p>livox_ros_driver可以不着急先编译,等最后一起build</p><ul><li><p>FAST_LIVO2 : <a href="https://github.com/hku-mars/FAST-LIVO2.git">https://github.com/hku-mars/FAST-LIVO2.git</a></p></li><li><p>livox_ros_ driver :  <a href="https://github.com/xuankuzcr/LIV_handhold.git">https://github.com/xuankuzcr/LIV_handhold.git</a></p><p> <a href="#change">&lt;说明&gt;</a>硬同步需要使用这个github库中的livox_ros_driver,<strong>对比官方,这里做了硬同步的改动，增加了对共享内存写入时间戳的功能</strong> </p></li><li><p>mvs_ros_pkg : <a href="https://github.com/xuankuzcr/LIV_handhold.git">https://github.com/xuankuzcr/LIV_handhold.git</a> <a name="mvs_ros_pkg"></a></p><p> &lt;说明&gt;硬同步需要使用这个github库中的相机ros驱动</p></li><li><p>rpg_vikit : <a href="https://github.com/xuankuzcr/rpg_vikit.git">https://github.com/xuankuzcr/rpg_vikit.git</a> (使用这个url,否则编译时出错)</p></li></ul><h3 id="4-Build"><a href="#4-Build" class="headerlink" title="4. Build"></a>4. Build</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd ~/fast_livo2_ws/<br>catkin_make<br>source ~/fast_livo2_ws/devel/setup.bash<br></code></pre></td></tr></table></figure><p>​<a name="change"></a></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li><p>关于<a href="https://github.com/xuankuzcr/LIV_handhold">LIV_handhold</a>中<strong>livox_ros_driver</strong>的改动</p><p>使用meld对比两份文件夹 ,  新的livox_ros_driver增加了共享内存以及对共享内存写入时间戳的功能.</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">+ livox_ros_driver.cpp<br> <span class="hljs-comment">// 将文件映射为一个共享内存区域，大小为sizeof(time_stamp)，通过指针pointt可以直接读写它。</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *user_name = <span class="hljs-built_in">getlogin</span>();<br>      std::string path_for_time_stamp = <span class="hljs-string">&quot;/home/&quot;</span> + std::<span class="hljs-built_in">string</span>(user_name) + <span class="hljs-string">&quot;/timeshare&quot;</span>;<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *shared_file_name = path_for_time_stamp.<span class="hljs-built_in">c_str</span>();<br>      <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(shared_file_name, O_CREAT | O_RDWR | O_TRUNC, <span class="hljs-number">0666</span>);<br>      <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">ERR_EXIT</span>(<span class="hljs-string">&quot;open&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open code: %d\n&quot;</span>, fd);<br>      &#125;<br>      <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-built_in">sizeof</span>(time_stamp) * <span class="hljs-number">1</span>, SEEK_SET);<br>      <span class="hljs-built_in">write</span>(fd, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">1</span>);<br>      pointt = (time_stamp *)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">sizeof</span>(time_stamp) * <span class="hljs-number">1</span>,<br>                                  PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li><p>关于<a href="https://github.com/xuankuzcr/LIV_handhold">LIV_handhold</a>中<strong>livox_ros_driver2</strong>的改动</p><p>新的livox_ros_driver2增加了共享内存以及对共享内存写入时间戳的功能.</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">+lddc.cpp<br>    <span class="hljs-comment">// 实现了用一个普通文件作为共享内存的载体，进程间可以通过映射该文件进行数据共享。</span><br>    <span class="hljs-comment">// 结构体time_stamp用于在多个进程（或设备驱动与应用程序）间共享硬件时间戳。</span><br>    <span class="hljs-comment">//******************************************************************** add code</span><br>    <span class="hljs-keyword">if</span> (isOpended == <span class="hljs-literal">false</span>)<br>    &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *user_name = <span class="hljs-built_in">getlogin</span>();<br>      std::string path_for_time_stamp = <span class="hljs-string">&quot;/home/&quot;</span> + std::<span class="hljs-built_in">string</span>(user_name) + <span class="hljs-string">&quot;/timeshare&quot;</span>;<br><br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *shared_file_name = path_for_time_stamp.<span class="hljs-built_in">c_str</span>();<br>      <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(shared_file_name, O_CREAT | O_RDWR | O_TRUNC, <span class="hljs-number">0666</span>);<br>      <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)<br>      &#123;<br>        <span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;open failed\n&quot;</span>);<br>        isOpended = <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;open code: %d\n&quot;</span>, fd);<br>        isOpended = <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-built_in">sizeof</span>(time_stamp) * <span class="hljs-number">1</span>, SEEK_SET);<br>      <span class="hljs-built_in">write</span>(fd, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">1</span>);<br>      pointt = (time_stamp *)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">sizeof</span>(time_stamp) * <span class="hljs-number">1</span>,<br>                                  PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//********************************************************************</span><br></code></pre></td></tr></table></figure><h2 id="STM32硬同步"><a href="#STM32硬同步" class="headerlink" title="STM32硬同步"></a>STM32硬同步</h2><h3 id="1-材料"><a href="#1-材料" class="headerlink" title="1. 材料"></a>1. 材料</h3><ul><li>工程文件 : <a href="https://github.com/xuankuzcr/LIV_handhold/tree/main/stm32_timersync-open">stm32_timersync-open</a></li><li>烧录器 : ST-LINK V2</li><li>STM32F103C8T6</li><li>TTL to USB</li><li>TTL to RS485</li></ul><h3 id="2-原理图"><a href="#2-原理图" class="headerlink" title="2. 原理图"></a>2. 原理图</h3><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/15.png" alt="图9-硬件同步方案"></p><p style="text-align:center;">图9-硬件同步方案</p><p>Livox_avia不支持直接读取GPRMC格式的指令,mid360支持直接读取.如果使用mid360连线原理图将会改变.本篇只考虑Livox_avia.</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/16.png" alt="图10-硬件同步原理图"></p><p style="text-align:center;">图10-硬件同步原理图</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/19.png" alt="图11-时间对齐原理图"></p><p style="text-align:center;">图11-时间对齐原理图</p><h3 id="3-硬件连线图"><a href="#3-硬件连线图" class="headerlink" title="3. 硬件连线图"></a>3. 硬件连线图</h3><p>**硬件连线参考图 : ** </p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/31.png" alt="图12-硬件连线参考图"></p><p style="text-align:center;">图12-硬件连线参考图</p><p>相机线说明 :</p><p>相机的电源及 I&#x2F;O 接口为 6-pin P7 接口。</p><img src="../images/复现FAST-LIVO2/32.png" alt="图13-相机同步线线序图" style="zoom:67%;" /><p style="text-align:center;">图13-相机同步线线序图</p><p>Livox Converter 2.0 同步线说明 :</p><img src="../images/复现FAST-LIVO2/33.png" alt="图14-雷达同步线线序图" style="zoom:67%;" /><p style="text-align:center;">图14-雷达同步线线序图</p><h3 id="4-串口绑定"><a href="#4-串口绑定" class="headerlink" title="4. 串口绑定"></a>4. 串口绑定</h3><p>为了赋予特定串口权限,且防止串口在ubuntu下名称跳变，本片介绍ubuntu系统下如何绑定串口。</p><h4 id="1-建立udev规则"><a href="#1-建立udev规则" class="headerlink" title="1. 建立udev规则"></a>1. 建立udev规则</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /etc/udev/rules.d/my_rule.rules<br></code></pre></td></tr></table></figure><h4 id="2-获取串口设备详情"><a href="#2-获取串口设备详情" class="headerlink" title="2. 获取串口设备详情"></a>2. 获取串口设备详情</h4><p>列出当前串口设备。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls /dev/ttyUSB*<br></code></pre></td></tr></table></figure><p>以ttyUSB0为例。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">udevadm info --attribute-walk --name=/dev/ttyUSB0<br></code></pre></td></tr></table></figure><p>获得详细信息，我习惯以第四行&#x3D;&#x3D;looking …&#x3D;&#x3D;以下的信息作为信息绑定的依靠。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">looking at device &#x27;/devices/pci0000:00/0000:00:14.0/usb3/3-3/3-3:1.0/ttyUSB0/tty/ttyUSB0&#x27;:<br>    KERNEL==&quot;ttyUSB0&quot;<br>    SUBSYSTEM==&quot;tty&quot;<br>    DRIVER==&quot;&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0/usb3/3-3/3-3:1.0/ttyUSB0&#x27;:<br>    KERNELS==&quot;ttyUSB0&quot;<br>    SUBSYSTEMS==&quot;usb-serial&quot;<br>    DRIVERS==&quot;cp210x&quot;<br>    ATTRS&#123;port_number&#125;==&quot;0&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0/usb3/3-3/3-3:1.0&#x27;:<br>    KERNELS==&quot;3-3:1.0&quot;<br>    SUBSYSTEMS==&quot;usb&quot;<br>    DRIVERS==&quot;cp210x&quot;<br>    ATTRS&#123;interface&#125;==&quot;CP2102 USB to UART Bridge Controller&quot;<br>    ATTRS&#123;authorized&#125;==&quot;1&quot;<br>    ATTRS&#123;bAlternateSetting&#125;==&quot; 0&quot;<br>    ATTRS&#123;bInterfaceProtocol&#125;==&quot;00&quot;<br>    ATTRS&#123;bNumEndpoints&#125;==&quot;02&quot;<br>    ATTRS&#123;supports_autosuspend&#125;==&quot;1&quot;<br>    ATTRS&#123;bInterfaceSubClass&#125;==&quot;00&quot;<br>    ATTRS&#123;bInterfaceClass&#125;==&quot;ff&quot;<br>    ATTRS&#123;bInterfaceNumber&#125;==&quot;00&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0/usb3/3-3&#x27;:<br>    KERNELS==&quot;3-3&quot;<br>    SUBSYSTEMS==&quot;usb&quot;<br>    DRIVERS==&quot;usb&quot;<br>    ATTRS&#123;idProduct&#125;==&quot;ea60&quot;<br>    ATTRS&#123;bConfigurationValue&#125;==&quot;1&quot;<br>    ATTRS&#123;tx_lanes&#125;==&quot;1&quot;<br>    ATTRS&#123;bNumInterfaces&#125;==&quot; 1&quot;<br>    ATTRS&#123;maxchild&#125;==&quot;0&quot;<br>    ATTRS&#123;avoid_reset_quirk&#125;==&quot;0&quot;<br>    ATTRS&#123;devpath&#125;==&quot;3&quot;<br>    ATTRS&#123;bDeviceSubClass&#125;==&quot;00&quot;<br>    ATTRS&#123;bDeviceClass&#125;==&quot;00&quot;<br>    ATTRS&#123;ltm_capable&#125;==&quot;no&quot;<br>    ATTRS&#123;quirks&#125;==&quot;0x0&quot;<br>    ATTRS&#123;serial&#125;==&quot;0001&quot;<br>    ATTRS&#123;bDeviceProtocol&#125;==&quot;00&quot;<br>    ATTRS&#123;speed&#125;==&quot;12&quot;<br>    ATTRS&#123;busnum&#125;==&quot;3&quot;<br>    ATTRS&#123;bNumConfigurations&#125;==&quot;1&quot;<br>    ATTRS&#123;manufacturer&#125;==&quot;Silicon Labs&quot;<br>    ATTRS&#123;bMaxPacketSize0&#125;==&quot;64&quot;<br>    ATTRS&#123;version&#125;==&quot; 1.10&quot;<br>    ATTRS&#123;bcdDevice&#125;==&quot;0100&quot;<br>    ATTRS&#123;devnum&#125;==&quot;6&quot;<br>    ATTRS&#123;rx_lanes&#125;==&quot;1&quot;<br>    ATTRS&#123;authorized&#125;==&quot;1&quot;<br>    ATTRS&#123;removable&#125;==&quot;removable&quot;<br>    ATTRS&#123;product&#125;==&quot;CP2102 USB to UART Bridge Controller&quot;<br>    ATTRS&#123;configuration&#125;==&quot;&quot;<br>    ATTRS&#123;bMaxPower&#125;==&quot;100mA&quot;<br>    ATTRS&#123;urbnum&#125;==&quot;12&quot;<br>    ATTRS&#123;bmAttributes&#125;==&quot;80&quot;<br>    ATTRS&#123;idVendor&#125;==&quot;10c4&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0/usb3&#x27;:<br>    KERNELS==&quot;usb3&quot;<br>    SUBSYSTEMS==&quot;usb&quot;<br>    DRIVERS==&quot;usb&quot;<br>    ATTRS&#123;devpath&#125;==&quot;0&quot;<br>    ATTRS&#123;authorized_default&#125;==&quot;1&quot;<br>    ATTRS&#123;ltm_capable&#125;==&quot;no&quot;<br>    ATTRS&#123;speed&#125;==&quot;480&quot;<br>    ATTRS&#123;bNumInterfaces&#125;==&quot; 1&quot;<br>    ATTRS&#123;configuration&#125;==&quot;&quot;<br>    ATTRS&#123;bMaxPower&#125;==&quot;0mA&quot;<br>    ATTRS&#123;bmAttributes&#125;==&quot;e0&quot;<br>    ATTRS&#123;avoid_reset_quirk&#125;==&quot;0&quot;<br>    ATTRS&#123;serial&#125;==&quot;0000:00:14.0&quot;<br>    ATTRS&#123;manufacturer&#125;==&quot;Linux 5.15.0-139-generic xhci-hcd&quot;<br>    ATTRS&#123;busnum&#125;==&quot;3&quot;<br>    ATTRS&#123;interface_authorized_default&#125;==&quot;1&quot;<br>    ATTRS&#123;bConfigurationValue&#125;==&quot;1&quot;<br>    ATTRS&#123;bDeviceClass&#125;==&quot;09&quot;<br>    ATTRS&#123;bMaxPacketSize0&#125;==&quot;64&quot;<br>    ATTRS&#123;quirks&#125;==&quot;0x0&quot;<br>    ATTRS&#123;bcdDevice&#125;==&quot;0515&quot;<br>    ATTRS&#123;idProduct&#125;==&quot;0002&quot;<br>    ATTRS&#123;tx_lanes&#125;==&quot;1&quot;<br>    ATTRS&#123;rx_lanes&#125;==&quot;1&quot;<br>    ATTRS&#123;product&#125;==&quot;xHCI Host Controller&quot;<br>    ATTRS&#123;urbnum&#125;==&quot;98&quot;<br>    ATTRS&#123;removable&#125;==&quot;unknown&quot;<br>    ATTRS&#123;bNumConfigurations&#125;==&quot;1&quot;<br>    ATTRS&#123;devnum&#125;==&quot;1&quot;<br>    ATTRS&#123;bDeviceProtocol&#125;==&quot;01&quot;<br>    ATTRS&#123;version&#125;==&quot; 2.00&quot;<br>    ATTRS&#123;idVendor&#125;==&quot;1d6b&quot;<br>    ATTRS&#123;maxchild&#125;==&quot;12&quot;<br>    ATTRS&#123;bDeviceSubClass&#125;==&quot;00&quot;<br>    ATTRS&#123;authorized&#125;==&quot;1&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0&#x27;:<br>    KERNELS==&quot;0000:00:14.0&quot;<br>    SUBSYSTEMS==&quot;pci&quot;<br>    DRIVERS==&quot;xhci_hcd&quot;<br>    ATTRS&#123;local_cpus&#125;==&quot;ffff&quot;<br>    ATTRS&#123;dma_mask_bits&#125;==&quot;64&quot;<br>    ATTRS&#123;power_state&#125;==&quot;D0&quot;<br>    ATTRS&#123;device&#125;==&quot;0x51ed&quot;<br>    ATTRS&#123;subsystem_device&#125;==&quot;0x3037&quot;<br>    ATTRS&#123;ari_enabled&#125;==&quot;0&quot;<br>    ATTRS&#123;class&#125;==&quot;0x0c0330&quot;<br>    ATTRS&#123;msi_bus&#125;==&quot;1&quot;<br>    ATTRS&#123;vendor&#125;==&quot;0x8086&quot;<br>    ATTRS&#123;revision&#125;==&quot;0x01&quot;<br>    ATTRS&#123;local_cpulist&#125;==&quot;0-15&quot;<br>    ATTRS&#123;label&#125;==&quot;Onboard - Other&quot;<br>    ATTRS&#123;numa_node&#125;==&quot;-1&quot;<br>    ATTRS&#123;driver_override&#125;==&quot;(null)&quot;<br>    ATTRS&#123;consistent_dma_mask_bits&#125;==&quot;64&quot;<br>    ATTRS&#123;subsystem_vendor&#125;==&quot;0x8086&quot;<br>    ATTRS&#123;dbc&#125;==&quot;disabled&quot;<br>    ATTRS&#123;enable&#125;==&quot;1&quot;<br>    ATTRS&#123;broken_parity_status&#125;==&quot;0&quot;<br>    ATTRS&#123;irq&#125;==&quot;145&quot;<br>    ATTRS&#123;d3cold_allowed&#125;==&quot;1&quot;<br>    ATTRS&#123;index&#125;==&quot;7&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00&#x27;:<br>    KERNELS==&quot;pci0000:00&quot;<br>    SUBSYSTEMS==&quot;&quot;<br>    DRIVERS==&quot;&quot;<br>    ATTRS&#123;waiting_for_supplier&#125;==&quot;0&quot;<br></code></pre></td></tr></table></figure><h4 id="3-在udev规则下写入串口信息"><a href="#3-在udev规则下写入串口信息" class="headerlink" title="3. 在udev规则下写入串口信息"></a>3. 在udev规则下写入串口信息</h4><p>如果没有相同ID设备的话可直接写入。</p><p>其中<code>KERNEL==&quot;ttyUSB*&quot;</code>表明绑定的设备是串口，<code>ATTRS&#123;idVendor&#125;==&quot;10c4&quot;, ATTRS&#123;idProduct&#125;==&quot;ea60&quot;</code>是Step2中设备的信息，<code>MODE:=&quot;0777&quot;</code>给予设备最高权限，<code>SYMLINK+=&quot;ttyUSB_TTL2USB&quot;</code>为绑定后设备的名称。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">KERNEL==&quot;ttyUSB*&quot;, ATTRS&#123;idVendor&#125;==&quot;10c4&quot;, ATTRS&#123;idProduct&#125;==&quot;ea60&quot;, MODE:=&quot;0777&quot;, SYMLINK+=&quot;ttyUSB_TTL2USB&quot;<br></code></pre></td></tr></table></figure><p>若有相同ID设备，则可再添加<code>ATTRS&#123;devpath&#125;==&quot;5.2&quot;</code>信息，该量一般与设备与电脑链接的端口号有关。</p><h4 id="4-重启udev"><a href="#4-重启udev" class="headerlink" title="4. 重启udev"></a>4. 重启udev</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo service udev reload<br>sudo service udev restart<br></code></pre></td></tr></table></figure><p>再次查看串口设备，即可看到绑定成功后的名称。若还没成功，可尝试重启电脑或者热插拔设备。</p><img src="../images/复现FAST-LIVO2/50.jpg" alt="图15-绑定串口显示" style="zoom:50%;" /><p style="text-align:center;">图15-绑定串口显示</p><h3 id="5-雷达设置"><a href="#5-雷达设置" class="headerlink" title="5. 雷达设置"></a>5. 雷达设置</h3><p>雷达选型 : Livox AVIA</p><p>转换器 : Livox Converter 2.0</p><h4 id="Livox雷达时间同步说明"><a href="#Livox雷达时间同步说明" class="headerlink" title="Livox雷达时间同步说明"></a>Livox雷达时间同步说明</h4><p>参考:<a href="https://github.com/Livox-SDK/Livox-SDK/wiki/livox-device-time-synchronization-manual-cn#%E9%99%84%E5%BD%95">https://github.com/Livox-SDK/Livox-SDK/wiki/livox-device-time-synchronization-manual-cn#%E9%99%84%E5%BD%95</a></p><p>Livox设备支持3种时间同步方式：</p><ul><li>PTP：IEEE 1588v2.0 PTP 网络协议同步；</li><li>GPS：秒脉冲+GPRMC时间数据，组成GPS时间同步方式；</li><li>PPS：秒脉冲同步，需要上层应用程序通过其他途径（如：uart）获取每个脉冲的时间信息，并修正点云时间。</li></ul><p>FAST-LIO只涉及GPS和PPS两种,只介绍这两种。</p><h5 id="GPS"><a href="#GPS" class="headerlink" title="GPS"></a>GPS</h5><p>GPS时钟源的PPS端口每秒发送一次硬件脉冲（PPS信号），随后数据端口发送一次对应这个脉冲上升沿的时间信息（GPRMC格式）。Livox设备接收到PPS信号上升沿，并由GPRMC数据解析出正确的时间信息后，会设置点云时间为GPS时间，并保持此时间基准持续累加，来实现和GPS设备的时间同步。</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/17.png" alt="图17-GPS信号示意图"></p><p style="text-align:center;">图17-GPS信号示意图</p><p><strong>Livox Converter 2.0</strong>将GPS模块的时间信号（GPRMC）通过TTL转usb模块接入PC，PPS信号接入LiDAR转接盒同步口（Sync Port）。</p><img src="../images/复现FAST-LIVO2/18.png" alt="图18-Livox Converter 2.0连线图" style="zoom: 67%;" /><p style="text-align:center;">图18-Livox Converter 2.0连线图</p><h5 id="PPS"><a href="#PPS" class="headerlink" title="PPS"></a>PPS</h5><p>Livox LiDAR每次接收到PPS信号的上升沿后，会将当前时刻的点云时间置为0，然后重新开始计时直到下一个PPS脉冲到来,利用这个特性，来实现PPS脉冲对LiDAR时间的同步。</p><p>伪代码:</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// PPS Time Synchronization</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span> lidar_time_last;<br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span> lidar_time_real;<br><br><span class="hljs-comment">// 1. Read the PPS rising edge time, Unit is nanosecond.</span><br><span class="hljs-type">uint64_t</span> pps_time_ns = get_pps_rising_nsecond();<br><span class="hljs-comment">// 2. Read LiDAR point time, Unit is nanosecond.</span><br><span class="hljs-type">uint64_t</span> lidar_time = get_lidar_pack_time();<br><span class="hljs-comment">// 3. Update real time.</span><br><span class="hljs-keyword">if</span> (lidar_time &lt; lidar_time_last)<br>&#123;<br>    <span class="hljs-comment">//LiDAR time jump indicates the generation of PPS rising edge.</span><br>    lidar_time_real = pps_time_ns + lidar_time%(<span class="hljs-number">1000000000</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    lidar_time_real += lidar_time - lidar_time_last;<br>&#125;<br><span class="hljs-comment">//Update history</span><br>lidar_time_last = lidar_time;<br></code></pre></td></tr></table></figure><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><h4 id="1-安装Livox-Viewer"><a href="#1-安装Livox-Viewer" class="headerlink" title="1. 安装Livox Viewer"></a>1. 安装Livox Viewer</h4><p> Livox Viewer 0.10.0(64bit) : <a href="https://www.livoxtech.com/downloads">https://www.livoxtech.com/downloads</a></p><blockquote><p>注：Livox Viewer2并不支持Avia</p></blockquote><p>以太网设置:</p><img src="../images/复现FAST-LIVO2/47.jpg" alt="图19-Livox雷达以太网设置" style="zoom: 50%;" /><p style="text-align:center;">图19-Livox雷达以太网设置</p><p>点击左上角播放按钮,出现点云.</p><img src="../images/复现FAST-LIVO2/48.jpg" alt="图20-Livox Viewer点云示意图" style="zoom: 67%;" /><p style="text-align:center;">图20-Livox Viewer点云示意图</p><p>插上硬同步设备后,查看雷达的连接转态和数据的读取状态，来确认雷达是否已进入PPS同步状态 <strong>(在这里不能修改TIme Sync &#x2F; PPS State,此设置为连接硬同步后自动触发)</strong></p><img src="../images/复现FAST-LIVO2/49.png" alt="图21-Livox Viewer设置状态图" style="zoom: 50%;" /><p style="text-align:center;">图21-Livox Viewer设置状态图</p><h4 id="2-修改livox-lidar-config-json"><a href="#2-修改livox-lidar-config-json" class="headerlink" title="2. 修改livox_lidar_config.json"></a>2. 修改livox_lidar_config.json</h4><img src="../images/复现FAST-LIVO2/51.jpg" alt= "图22-livox_lidar_config.json参数设置" style="zoom: 50%;" /><p style="text-align:center;">图22-livox_lidar_config.json参数设置</p><h4 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs SHELL">roslaunch livox_ros_driver livox_lidar_rviz.launch<br></code></pre></td></tr></table></figure><p>可以在自动弹出来的rviz中查看是否有点云正常输出和显示</p><h3 id="6-相机设置"><a href="#6-相机设置" class="headerlink" title="6. 相机设置"></a>6. 相机设置</h3><p>相机 : 海康相机MV-CS020-10UC</p><p>驱动 : MVS_STD_V3.0.1</p><h4 id="1-安装驱动"><a href="#1-安装驱动" class="headerlink" title="1. 安装驱动"></a>1. 安装驱动</h4><p>海康威视工业相机SDK的ros驱动依赖MVS的库文件，先安装MVS客户端.</p><p>官方下载地址：<a href="https://gitee.com/link?target=https://www.hikrobotics.com/cn/machinevision/service/download/?module=0">https://www.hikrobotics.com/cn/machinevision/service/download/?module=0</a></p><h4 id="2-下载和编译相机的雷达ros驱动"><a href="#2-下载和编译相机的雷达ros驱动" class="headerlink" title="2. 下载和编译相机的雷达ros驱动"></a>2. 下载和编译相机的雷达ros驱动</h4><p> (见<a href="#mvs_ros_pkg">NUC环境搭建 - 3.工作空间配置</a>)</p><h4 id="3-调整配置文件"><a href="#3-调整配置文件" class="headerlink" title="3. 调整配置文件"></a>3. 调整配置文件</h4><p>路径 : mvs_ros_driver&#x2F;config</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">%YAML:1.0</span><br><br><span class="hljs-comment">#--------------------------------------------------------------------------------------------</span><br><span class="hljs-comment"># Camera Parameters. Adjust them!</span><br><span class="hljs-comment">#--------------------------------------------------------------------------------------------</span><br><span class="hljs-attr">SerialNumber:</span> <span class="hljs-string">&quot;DA2099368&quot;</span> <span class="hljs-comment"># Not needed for single camera. Specify serial number for multiple cameras. </span><br><span class="hljs-attr">TopicName:</span> <span class="hljs-string">&quot;left_camera/image&quot;</span><br><br><span class="hljs-attr">TriggerEnable:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 0 stands for Off, 1 stands for On</span><br><br><span class="hljs-attr">ExposureAutoMode:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 0 stands for Off, 1 stands for Once, 2 stands for Continues</span><br><span class="hljs-attr">ExposureTime:</span> <span class="hljs-number">5000</span> <span class="hljs-comment"># us</span><br><br><span class="hljs-comment"># ExposureAutoMode: 2</span><br><span class="hljs-comment"># AutoExposureTimeLower: 100</span><br><span class="hljs-comment"># AutoExposureTimeUpper: 20000</span><br><br><span class="hljs-attr">image_scale:</span> <span class="hljs-number">0.5</span> <span class="hljs-comment"># 1 0.5</span><br><span class="hljs-attr">GainAuto:</span> <span class="hljs-number">2</span> <span class="hljs-comment"># Gain Auto, 0 stands for Off, 1 stands for Once, 2 stands for Continues</span><br><span class="hljs-attr">Gain:</span> <span class="hljs-number">15</span> <span class="hljs-comment"># min: 0   max: 17.0166</span><br><span class="hljs-attr">Gamma:</span> <span class="hljs-number">0.7</span>  <span class="hljs-comment"># min: 0   max: 17.0166</span><br><span class="hljs-attr">GammaSelector:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 0 stands for user, 1 stands for sRGB</span><br><span class="hljs-comment"># GammaEnable: 1</span><br><br><span class="hljs-attr">PixelFormat:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 0: RGB8, 1: BayerRG8, 2: BayerRG12Packed, 3: BayerGB12Packed, 4: BayerGB8</span><br></code></pre></td></tr></table></figure><p>最重要的参数是<strong>PixelFormat</strong>,需要根据相机型号调整。遍历一遍看哪个数值可用当然可以,代价是报错的时候不能理解其中原因,会造成很多麻烦。</p><p><strong>如何找到适合本相机的PixelFormat :</strong></p><ul><li>查阅海康相机官网<a href="https://www.hikrobotics.com/cn/machinevision/productdetail/?id=12379">https://www.hikrobotics.com/cn/machinevision/productdetail/?id=12379</a></li></ul><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/41.png" alt="图23-相机支持像素格式"></p><p style="text-align:center;">图23-相机支持像素格式</p><p>​看似这个相机支持RGB8 &#x2F; BayerRG8 &#x2F; BayerRG12Packed, PixelFormat选择0&#x2F;1&#x2F;2都可以, 实则不然。</p><p>​当选择1或2的时候,运行<code>roslaunch mvs_ros_driver mvs_camera_trigger.launch</code>时, 出现报错 :</p><img src="../images/复现FAST-LIVO2/42.jpg" alt="图24-mvs_camera_trigger报错图" style="zoom:50%;" /><p style="text-align:center;">图24-mvs_camera_trigger报错图</p><p>​针对这个报错, 打开MVS的官方图形化界面看一下 : </p><p>​图形化界面参数太多了,再查阅海康机器人USB3.0工业面阵相机用户手册,发现Gamma参数应该在Analog Control 属性中.</p><img src="../images/复现FAST-LIVO2/43.png" alt="图25-海康相机用户手册详细参数" style="zoom:33%;" /><p style="text-align:center;">图25-海康相机用户手册详细参数</p><p>​在Bayer RG 8 &#x2F; BayerRG12Packed模式下 , 没有Gamma这个参数 ．只有在RGB8模式下才有Gamma参数．</p><img src="../images/复现FAST-LIVO2/44.jpg" alt="图26-海康相机图形化界面参数" style="zoom: 80%;" /><p style="text-align:center;">图26-海康相机图形化界面参数</p><img src="../images/复现FAST-LIVO2/45.jpg" alt="图27-海康相机图形化界面参数" style="zoom: 80%;" /><p style="text-align:center;">图27-海康相机图形化界面参数</p><p>​探究一下原理：</p><ul><li><p>Bayer 格式是原始图像数据（Raw），<code>Bayer RG8</code> 是未经过处理的原始图像数据格式，每个像素仅包含单色信息（红、绿或蓝中的一个）。在这种格式下，图像还没有完成 去马赛克（Demosaicing）、白平衡、Gamma 校正等ISP流程。</p></li><li><p>RGB8 是处理后的彩色图像格式，可以进行Gamma调节．</p><blockquote><p>注 : 如果把yaml文件中的Gamma和GammaSelector注释掉,该驱动包也能正常跑.但是之后我都选择使用<strong>RGB8</strong>格式,故BayerRG8 &#x2F; BayerRG12Packed能否跑完全流程并不确定．</p></blockquote></li></ul><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h4><ul><li><p>如果需要<strong>单独测试相机驱动</strong>,需要把mvs_ros_driver&#x2F;config中的<strong>TriggerEnable参数改为0</strong>,否则节点无图像数据！</p></li><li><p>相机插NUC的<strong>USB3.0</strong>的插口</p></li><li><p>指令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch mvs_ros_pkg mvs_camera_trigger.launch<br></code></pre></td></tr></table></figure><p>rviz中查看图像是否正常输出．</p><img src="../images/复现FAST-LIVO2/46.jpg" alt="图28-mvs_camera_trigger的rviz界面" style="zoom: 33%;" /><p style="text-align:center;">图28-mvs_camera_trigger的rviz界面</p></li></ul><h3 id="7-烧录"><a href="#7-烧录" class="headerlink" title="7. 烧录"></a>7. 烧录</h3><ol><li><p>STLINK驱动安装</p><p><a href="https://docs.qq.com/doc/DT2hyS2ZjY21WQkZt">https://docs.qq.com/doc/DT2hyS2ZjY21WQkZt</a></p></li><li><p>硬件连接</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/20.png" alt="图29-烧录硬件连接原理图"></p><p style="text-align:center;">图29-烧录硬件连接原理图</p><img src="../images/复现FAST-LIVO2/21.jpg" alt="图30-实物图(stlink正面)" style="zoom: 25%;" /><p style="text-align:center;">图30-实物图(stlink正面)</p></li></ol><img src="../images/复现FAST-LIVO2/22.jpg" alt="图31-实物图(stlink侧面)" style="zoom: 25%;" /><p style="text-align:center;">图31-实物图(stlink侧面)</p><img src="../images/复现FAST-LIVO2/23.jpg" alt="图32-实物图(stm32背面)" style="zoom: 25%;" /><p style="text-align:center;">图32-实物图(stm32背面)</p><ol start="3"><li><p>Keil烧录</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/24.png" alt="图33-烧录步骤-1"></p><p style="text-align:center;">图33-烧录步骤-1</p></li></ol><img src="../images/复现FAST-LIVO2/25.png" alt="图34-烧录步骤-2" style="zoom:50%;" /><p style="text-align:center;">图34-烧录步骤-2</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/26.png" alt="图35-烧录步骤-3"></p><p style="text-align:center;">图35-烧录步骤-3</p><img src="../images/复现FAST-LIVO2/27.png" alt="图36-烧录步骤-4" style="zoom:50%;" /><p style="text-align:center;">图36-烧录步骤-4</p><img src="../images/复现FAST-LIVO2/28.png" alt="图37-烧录步骤-5" style="zoom:50%;" /><p style="text-align:center;">图37-烧录步骤-5</p><img src="../images/复现FAST-LIVO2/29.png" alt="图38-烧录步骤-6" style="zoom:50%;" /><p style="text-align:center;">图38-烧录步骤-6</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/30.png" alt="图39-烧录步骤-7"></p><p style="text-align:center;">图39-烧录步骤-7</p><h2 id="标定"><a href="#标定" class="headerlink" title="标定"></a>标定</h2><h3 id="相机内参标定"><a href="#相机内参标定" class="headerlink" title="相机内参标定"></a>相机内参标定</h3><p>张正友平面标定法</p><ol><li><p>准备标定素材</p><p>海康相机不能直接用opencv打开,必须调用mvs_ros_driver包,在自己写的订阅相机图片节点捕获图像.</p><blockquote><p>注意mvs_ros_driver发布图片话题时有scale &#x3D; 0.5,后面标定得到的参数需要*2。</p></blockquote></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">订阅相机图像话题并截图的ros_node</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sensor_msgs/Image.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cv_bridge/cv_bridge.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/filesystem.hpp&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> fs = boost::filesystem;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageCapture</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ImageCapture</span>(ros::NodeHandle&amp; nh, <span class="hljs-type">const</span> std::string&amp; save_dir)<br>        : <span class="hljs-built_in">save_dir_</span>(save_dir)<br>    &#123;<br>        sub_ = nh.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;/left_camera/image&quot;</span>, <span class="hljs-number">1</span>, &amp;ImageCapture::imageCallback, <span class="hljs-keyword">this</span>);<br>        <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;等待按下空格键保存图像，按 &#x27;q&#x27; 退出&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (!fs::<span class="hljs-built_in">exists</span>(save_dir_))<br>        &#123;<br>            fs::<span class="hljs-built_in">create_directories</span>(save_dir_);<br>            <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;创建保存目录: %s&quot;</span>, save_dir_.<span class="hljs-built_in">c_str</span>());<br>        &#125;<br><br>        cv::<span class="hljs-built_in">namedWindow</span>(<span class="hljs-string">&quot;View&quot;</span>, cv::WINDOW_NORMAL);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spin</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">ros::Rate <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<br>        <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>        &#123;<br>            &#123;<br>                <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>                <span class="hljs-keyword">if</span> (!latest_image_.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    cv::<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;View&quot;</span>, latest_image_);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-type">int</span> key = cv::<span class="hljs-built_in">waitKey</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (key == <span class="hljs-number">32</span>) <span class="hljs-comment">// 空格</span><br>            &#123;<br>                <span class="hljs-built_in">saveImage</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&#x27;q&#x27;</span> || key == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            &#123;<br>                <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;用户退出程序&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            ros::<span class="hljs-built_in">spinOnce</span>();<br>            rate.<span class="hljs-built_in">sleep</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ros::Subscriber sub_;<br>    cv::Mat latest_image_;<br>    std::mutex mutex_;<br>    std::string save_dir_;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">imageCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::ImageConstPtr&amp; msg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            cv::Mat image = cv_bridge::<span class="hljs-built_in">toCvShare</span>(msg, <span class="hljs-string">&quot;bgr8&quot;</span>)-&gt;image;<br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>            latest_image_ = image.<span class="hljs-built_in">clone</span>();<br>        &#125;<br>        <span class="hljs-built_in">catch</span> (cv_bridge::Exception&amp; e)<br>        &#123;<br>            <span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;cv_bridge 异常: %s&quot;</span>, e.<span class="hljs-built_in">what</span>());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">saveImage</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        <span class="hljs-keyword">if</span> (!latest_image_.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            std::string filename = save_dir_ + <span class="hljs-string">&quot;/image_&quot;</span> + std::<span class="hljs-built_in">to_string</span>(ros::Time::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">toNSec</span>()) + <span class="hljs-string">&quot;.jpg&quot;</span>;<br>            cv::<span class="hljs-built_in">imwrite</span>(filename, latest_image_);<br>            <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;图像已保存为 %s&quot;</span>, filename.<span class="hljs-built_in">c_str</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">ROS_WARN</span>(<span class="hljs-string">&quot;没有图像可保存&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;image_capture_node&quot;</span>);<br>    <span class="hljs-function">ros::NodeHandle <span class="hljs-title">nh</span><span class="hljs-params">(<span class="hljs-string">&quot;~&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 获取保存目录参数（默认当前目录）</span><br>    std::string save_dir;<br>    nh.<span class="hljs-built_in">param</span>&lt;std::string&gt;(<span class="hljs-string">&quot;save_dir&quot;</span>, save_dir, <span class="hljs-string">&quot;./&quot;</span>);<br><br>    <span class="hljs-function">ImageCapture <span class="hljs-title">ic</span><span class="hljs-params">(nh, save_dir)</span></span>;<br>    ic.<span class="hljs-built_in">spin</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>使用MATLAB进行标定:</li></ol><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/77.png" alt="图40-在matlab中选择标定"></p><p style="text-align:center;">图40-在matlab中选择标定</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/78.png" alt="图41-标定过程"></p><p style="text-align:center;">图41-标定过程</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/79.png" alt="图42-标定得到的数据"></p><p style="text-align:center;">图42-标定得到的数据</p><blockquote><p>得到参数:</p><p>&gt;&gt; cameraParams.IntrinsicMatrix</p><p>   671.9949         0          0         </p><p>   0                672.0204   0  </p><p>  410.0420    323.3874  1.0000 </p><p> &gt;&gt; cameraParams.RadialDistortion     -0.0572    0.0895</p></blockquote><p>对应camera_pinhole.yaml中</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cam_model:</span> <span class="hljs-string">Pinhole</span><br><span class="hljs-attr">cam_width:</span> <span class="hljs-number">1624</span><br><span class="hljs-attr">cam_height:</span> <span class="hljs-number">1240</span><br><span class="hljs-attr">scale:</span> <span class="hljs-number">0.5</span><br><span class="hljs-attr">cam_fx:</span> <span class="hljs-number">1343.9898</span><br><span class="hljs-attr">cam_fy:</span> <span class="hljs-number">1344.0408</span><br><span class="hljs-attr">cam_cx:</span> <span class="hljs-number">820.0840</span><br><span class="hljs-attr">cam_cy:</span> <span class="hljs-number">646.7748</span><br><span class="hljs-attr">cam_d0:</span> <span class="hljs-number">-0.0572</span><br><span class="hljs-attr">cam_d1:</span> <span class="hljs-number">0.0895</span><br><span class="hljs-attr">cam_d2:</span> <span class="hljs-number">0.0</span><br><span class="hljs-attr">cam_d3:</span> <span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><h3 id="外参标定"><a href="#外参标定" class="headerlink" title="外参标定"></a>外参标定</h3><ul><li><p>将相机内参同步到<code>FAST-Calib/config/qr_params.yaml</code>中。</p></li><li><p>运行roslaunch livox_ros_driver livox_lidar_msg<br>在<code>/FAST-Calib/calib_data</code> 下运行 <code> rosbag record -a</code></p></li><li><p>拍照当前相机图片</p><p>标定数据组织如下 (data.txt为自行记录标定数据,不需要预先创建)</p></li></ul><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/80.jpg" alt="图43-FAST-Calib标定数据组织"></p><p style="text-align:center;">图43-FAST-Calib标定数据组织</p><p>运行:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch fast_calib calib.launch<br></code></pre></td></tr></table></figure><blockquote><p>注意修改qr_params.yaml中和filter相关的参数.</p><p>否则会报错 :</p><p>[pcl::TransformationEstimationSVD::estimateRigidTransformation] Number or points in source (0) differs than target (4)! [Result] RMSE:  [computeRMSE] Point cloud sizes do not match, cannot compute RMSE.  -1.0000 m</p></blockquote><p>参考qr_params.yaml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Camera intrinsics  </span><br>  <span class="hljs-comment"># mid360</span><br>  <span class="hljs-comment"># fx: 522.123514287681</span><br>  <span class="hljs-comment"># fy: 522.275153384482</span><br>  <span class="hljs-comment"># cx: 773.466430504725</span><br>  <span class="hljs-comment"># cy: 534.053165700174</span><br>  <span class="hljs-comment"># k1: 0.00324949759262203</span><br>  <span class="hljs-comment"># k2: -0.0171040538369167</span><br>  <span class="hljs-comment"># p1: 0.000669657443377146</span><br>  <span class="hljs-comment"># p2: -0.000350205468789575</span><br><br>  <span class="hljs-comment"># avia</span><br>  <span class="hljs-attr">fx:</span> <span class="hljs-number">1343.9898</span><br>  <span class="hljs-attr">fy:</span> <span class="hljs-number">1344.0408</span><br>  <span class="hljs-attr">cx:</span> <span class="hljs-number">820.0840</span><br>  <span class="hljs-attr">cy:</span> <span class="hljs-number">646.7748</span><br>  <span class="hljs-attr">k1:</span> <span class="hljs-number">-0.0572</span><br>  <span class="hljs-attr">k2:</span> <span class="hljs-number">0.0895</span><br>  <span class="hljs-attr">p1:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">p2:</span> <span class="hljs-number">0</span><br><br>  <span class="hljs-comment"># ouster</span><br>  <span class="hljs-comment"># fx: 1466.16500795563</span><br>  <span class="hljs-comment"># fy: 1465.32657394431</span><br>  <span class="hljs-comment"># cx: 1214.39964380518</span><br>  <span class="hljs-comment"># cy: 1010.97681425650</span><br>  <span class="hljs-comment"># k1: -0.0458344972140773</span><br>  <span class="hljs-comment"># k2: 0.0896961240772692</span><br>  <span class="hljs-comment"># p1: -0.000731746350601389</span><br>  <span class="hljs-comment"># p2: -0.000201478932371979</span><br><br><span class="hljs-comment"># Calibration target parameters</span><br>  <span class="hljs-attr">marker_size:</span> <span class="hljs-number">0.17</span> <span class="hljs-comment"># ArUco marker size (our test data uses 0.16m; adjust to match your marker size)</span><br>  <span class="hljs-attr">delta_width_qr_center:</span> <span class="hljs-number">0.55</span> <span class="hljs-comment"># Half the distance between the centers of two markers in the horizontal direction </span><br>  <span class="hljs-attr">delta_height_qr_center:</span> <span class="hljs-number">0.35</span> <span class="hljs-comment"># Half the distance between the centers of two markers in the vertical direction</span><br>  <span class="hljs-attr">delta_width_circles:</span> <span class="hljs-number">0.5</span> <span class="hljs-comment"># Distance between the centers of two circles in the horizontal direction</span><br>  <span class="hljs-attr">delta_height_circles:</span> <span class="hljs-number">0.4</span> <span class="hljs-comment"># Distance between the centers of two circles in the vertical direction</span><br>  <span class="hljs-attr">circle_radius:</span> <span class="hljs-number">0.12</span> <span class="hljs-comment"># Radius of the circle </span><br><br><span class="hljs-comment"># Distance filter</span><br>  <span class="hljs-attr">x_min:</span> <span class="hljs-number">1.8</span><br>  <span class="hljs-attr">x_max:</span> <span class="hljs-number">2.4</span><br>  <span class="hljs-attr">y_min:</span> <span class="hljs-number">-1</span><br>  <span class="hljs-attr">y_max:</span> <span class="hljs-number">1.0</span><br>  <span class="hljs-attr">z_min:</span> <span class="hljs-number">-0.2</span> <span class="hljs-comment"># avia and mid360: -0.5 ouster: -0.8</span><br>  <span class="hljs-attr">z_max:</span> <span class="hljs-number">2.5</span><br><br><span class="hljs-comment"># Input</span><br>  <span class="hljs-attr">lidar_topic:</span> <span class="hljs-string">&quot;/livox/lidar&quot;</span> <span class="hljs-comment"># /ouster/points /livox/lidar</span><br>  <span class="hljs-attr">bag_path:</span> <span class="hljs-string">&quot;$(find fast_calib)/calib_data/1.bag&quot;</span><br>  <span class="hljs-attr">image_path:</span> <span class="hljs-string">&quot;$(find fast_calib)/calib_data/1.png&quot;</span><br><br><span class="hljs-comment"># Output</span><br>  <span class="hljs-attr">output_path:</span> <span class="hljs-string">&quot;$(find fast_calib)/output&quot;</span><br></code></pre></td></tr></table></figure><p>标定结果:</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/82.png" alt="图44-FAST-Calib标定的点云"></p><p style="text-align:center;">图44-FAST-Calib标定的点云</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/83.png" alt="图45-FAST-Calib标定的彩色图像"></p><p style="text-align:center;">图45-FAST-Calib标定的彩色图像</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/81.png" alt="图46-FAST-Calib得到的数据"></p><p style="text-align:center;">图46-FAST-Calib得到的数据</p><blockquote><p>输出:</p><p>[Result] Extrinsic parameters T_cam_lidar:<br>-0.096829 -0.994963 -0.025938 -1.142585<br>-0.081987  0.033945 -0.996055 -0.876730<br> 0.991919 -0.094320 -0.084861  2.192050<br> 0.000000  0.000000  0.000000  1.000000</p><p>对应的Rcl和Pcl:</p><p>Rcl: [-0.096829, -0.994963, -0.025938,<br>      -0.081987,  0.033945, -0.996055,<br>       0.991919, -0.094320, -0.084861]<br>Pcl: [-1.142585, -0.876730, 2.192050]</p><p>和真值偏移很大,彩色点云图中也有畸变,怀疑是标定板形变,以及标定板没有按照FAST-Calib官方推荐固定并悬挂的原因.</p></blockquote><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="跑包"><a href="#跑包" class="headerlink" title="跑包"></a>跑包</h3><p>HKU_Lecture_Center_02.bag</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch fast_livo mapping_avia.launch<br>rosbag play HKU_Lecture_Center_02.bag<br></code></pre></td></tr></table></figure><h4 id="建图精度"><a href="#建图精度" class="headerlink" title="建图精度"></a>建图精度</h4><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/2.jpg" alt="图47-rviz-1"></p><p style="text-align:center;">图47-rviz-1</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/3.jpg" alt="图48-rviz-2"></p><p style="text-align:center;">图48-rviz-2</p><p>墙面与地面分界线清晰</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/4.jpg" alt="图49-rviz-3"></p><p style="text-align:center;">图49-rviz-3</p><p>图片处理(拉高亮度)后,可以看到墙面纹路,转角非常清晰</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/5.jpg" alt="图50-rviz-4"></p><p style="text-align:center;">图50-rviz-4</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/6.jpg" alt="图51-rviz-5"></p><p style="text-align:center;">图51-rviz-5</p><h4 id="系统资源占用"><a href="#系统资源占用" class="headerlink" title="系统资源占用"></a>系统资源占用</h4><p>运行launch和rviz : 资源主要由rviz占用,且初始rviz config中点云queue数值极大,rviz实时看全局着色点云很卡</p><ol><li>可以把queue值 &#x2F; decay值适当改小;</li><li>可以重建完成后保存pcd文件,通过pcl_viewer（最好+显卡 +opengl）或者cloud compare等软件离线查看;</li><li>使用带gpu的电脑提升实时rviz性能.</li></ol><table><thead><tr><th align="center"><strong>字段</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">PRI</td><td align="center">Priority（优先级）</td></tr><tr><td align="center">NI</td><td align="center">Nice 值（友好度）</td></tr><tr><td align="center">VIRT</td><td align="center">Virtual Memory（虚拟内存大小）</td></tr><tr><td align="center">RES</td><td align="center">Resident Memory（常驻内存） 当前进程实际占用的物理内存大小</td></tr><tr><td align="center">SHR</td><td align="center">Shared Memory（共享内存）</td></tr><tr><td align="center">S</td><td align="center">State（进程状态）R：运行（Running）S：休眠（Sleeping）</td></tr><tr><td align="center">CPU%</td><td align="center">进程当前使用的 CPU 百分比（所有核总和）</td></tr><tr><td align="center">MEM%</td><td align="center">进程使用的物理内存占系统总内存的百分比</td></tr></tbody></table><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/7.jpg" alt="图52-htop查看资源占用"></p><p style="text-align:center;">图52-htop查看资源占用</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/8.jpg" alt="图53-fast-livo2运行占用资源"></p><p style="text-align:center;">图53-fast-livo2运行占用资源</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/9.jpg" alt="图54-fast-livo2的rviz占用资源"></p><p style="text-align:center;">图54-fast-livo2的rviz占用资源</p><p>只运行launch: </p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/10.jpg" alt="图55-只运行launch系统占用资源"></p><p style="text-align:center;">图55-只运行launch系统占用资源</p><h4 id="里程计数据"><a href="#里程计数据" class="headerlink" title="里程计数据"></a>里程计数据</h4><p>纵轴单位(m) ,三条曲线分别是x轴,y轴,z轴里程计数据变化</p><ul><li><p>蓝色-x轴</p></li><li><p>红色-y轴</p></li><li><p>绿色-z轴</p><p>取最后一段平稳曲线部分放大 : 静态波动在厘米级,峰峰值4-6cm</p></li></ul><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/11.jpg" alt="图56-里程计数据总览"></p><p style="text-align:center;">图56-里程计数据总览</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/12.png" alt="图57-里程计数据细节(图56蓝色框部分)"></p><p style="text-align:center;">图57-里程计数据细节(图56蓝色框部分)</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/13.jpg" alt="图58-里程计数据统计(统计图57中数据部分)"></p><p style="text-align:center;">图58-里程计数据统计(统计图57中数据部分)</p><h4 id="处理时间"><a href="#处理时间" class="headerlink" title="处理时间"></a>处理时间</h4><p>参考该帧处理时间数量级</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/14.jpg" alt="图59-处理时间参考"></p><p style="text-align:center;">图59-处理时间参考</p><p>###可行性初测试</p><h4 id="修改参数"><a href="#修改参数" class="headerlink" title="修改参数"></a>修改参数</h4><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/53.png" alt="图60-fast-livo2文件结构"></p><p style="text-align:center;">图60-fast-livo2文件结构</p><ul><li><p>&#x2F;congfig&#x2F;avia.yaml: Avia雷达的参数配置</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/54.png" alt="图61-雷达参数配置文件"></p><p style="text-align:center;">图61-雷达参数配置文件</p><blockquote><ul><li><p><strong>extrin_calib</strong> 中：</p><ol><li><p>extrinsic_T 和extrinsic_R 为雷达到IMU的外参（平移与旋转）</p></li><li><p>Rcl 和 Pcl 为相机到 LiDAR 的旋转矩阵和平移向量, 需要外参标定得出，更新到该位置即可</p><p>-作者在issue中的原回答:</p><p>The extrinsic_R in avia_resize.yaml doesn’t have to be an identity matrix.<br>extrinsic_R represents the rotation matrix of LiDAR frame w.r.t. IMU frame.<br>extrinsic_T represents the translation of LiDAR frame w.r.t. IMU frame.<br>If you set them correctly according to the physical meaning, there should be no wrong alignment of the image and LiDAR scan.</p></li></ol></li><li><p><strong>preprocess</strong> 预处理中：</p><p>1.lidar_type： LiDAR 类型<br> 保持值仍为1 （1：Livox Avia &#x2F; Mid360）</p><p>2.scan_line:  扫描线数量<br> 这里仍为6  （Avia：6，Mid360：4）</p></li><li><p><strong>time_offset</strong>时间偏移: </p><p>-作者在issue中的原回答:</p><p>img_time_offset: 0.1，在我们提供的<a href="https://github.com/xuankuzcr/LIV_handhold">同步方案</a>中，LiDAR会将其时间戳存储到共享内存中，相机帧则会读取内存中最新的时间戳。由于LiDAR scan是一个段时间测量，需要等0.1秒扫完后才会将其header的时间戳存到内存里。此时被触发的相机读取的时间戳实际上是0.1秒前的，因此其真实采样时间戳需要+0.1s。 对于NTU-VIRAL数据集，我设置lidar_time_offset: -0.1，因为该数据集中的LiDAR scan提供的是帧末时间戳，而我们的系统需要的是header时间戳，因此需要-0.1s。这一判断是基于在静止条件下观察EKF估计出的位姿抖动程度得出的。 </p><p>时间没对上不影响，只要在一个时间轴上就可以，evo会用高频的真值轨迹插值出LiDAR或相机采样时刻的位姿的。</p></li></ul></blockquote></li><li><p>&#x2F;congfig&#x2F;camara_pinhole.yaml: 相机的参数配置</p><p>相机选型: 海康相机MV-CS020-10UC</p><p>相机原始图像尺寸大小 : 1624*1240</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs SHELL">cam_model: Pinhole<br>cam_width: 1624<br>cam_height: 1240<br>scale: 0.5<br>cam_fx: 1343.9898<br>cam_fy: 1344.0408<br>cam_cx: 820.0840<br>cam_cy: 646.7748<br>cam_d0: -0.0572<br>cam_d1: 0.0895<br>cam_d2: 0.0<br>cam_d3: 0.0<br></code></pre></td></tr></table></figure><blockquote><p>除了要修改雷达的内参参数外,还要注意<code>cam_width</code> &#x2F; <code>cam_height</code> &#x2F; <code>scale</code> 三个参数 :</p><ul><li>在 mvs_ros_driver &#x2F; config &#x2F; left_camera_trigger.yaml中,scale默认为0.5,camara_pinhole.yaml中的值需要与其保持一致</li><li>mvs_ros_driver中默认不修改相机图像大小,<code>cam_width</code> &#x2F; <code>cam_height</code> 为相机原尺寸</li><li>图像传输时缩放了 0.5 倍，尺寸变为 812×620。</li></ul></blockquote><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>启动雷达：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch livox_ros_driver livox_lidar_msg.launch<br></code></pre></td></tr></table></figure><p>注意：这里我们启动的是Avia雷达的自定义消息格式，而非PointCloud2格式</p><p>启动相机:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch mvs_ros_pkg mvs_camera_trigger.launch<br></code></pre></td></tr></table></figure><p>Fast Livo2主节点启动:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch fast_livo mapping_avia.launch<br></code></pre></td></tr></table></figure><p>建图效果，如下方所示：</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/52.jpg" alt="图62-实时rviz"></p><p style="text-align:center;">图62-实时rviz</p><h4 id="包数据分析"><a href="#包数据分析" class="headerlink" title="包数据分析"></a>包数据分析</h4><p>对齐效果 :</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/56.jpg" alt="图63-包对齐总览"></p><p style="text-align:center;">图63-包对齐总览</p><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/55.jpg" alt="图64-包对齐细节"></p><p style="text-align:center;">图64-包对齐细节</p><blockquote><ul><li>雷达 &#x2F; imu &#x2F; 图像均为10hz</li><li>图像和雷达时间差约为30ms,查看官方包也是这样的偏差,目前暂时不清楚这个时间差意味着什么</li></ul></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="完全测试"><a href="#完全测试" class="headerlink" title="完全测试"></a>完全测试</h3><h4 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h4><img src="../images/复现FAST-LIVO2/59.jpg" alt="图65-硬件设备设计图" style="zoom:50%;" /><p style="text-align:center;">图65-硬件设备设计图</p><img src="../images/复现FAST-LIVO2/57.jpg" alt="图66-硬件设备实物图" style="zoom:50%;" /><p style="text-align:center;">图66-硬件设备实物图</p><img src="../images/复现FAST-LIVO2/58.jpg" alt="图67-硬件设备实物图" style="zoom:50%;" /><p style="text-align:center;">图67-硬件设备实物图</p><p>设备标注:</p><img src="../images/复现FAST-LIVO2/76.jpeg" alt="图68-硬件设备标注" style="zoom:50%;" /><p style="text-align:center;">图68-硬件设备标注</p><p>设备接线:</p><img src="../images/复现FAST-LIVO2/75.jpeg" alt="图69-设备接线标注" style="zoom:50%;" /><p style="text-align:center;">图69-设备接线标注</p><p>设备供电:</p><ol><li><p>使用一块4S航模电池为雷达 &#x2F; NUC供电</p><ul><li><p>4S航模电池直供NUC</p></li><li><p>4S航模电池经过Livox Converter 2.0降压连接雷达</p></li></ul></li><li><p>NUC为相机 &#x2F; 屏幕供电</p><ol><li><p>使用一块4S航模电池为雷达 &#x2F; NUC供电</p><ol><li>4S航模电池直供NUC</li><li>4S航模电池经过Livox Converter 2.0降压连接雷达</li></ol></li><li><p>NUC为相机 &#x2F; 屏幕供电</p></li></ol></li></ol><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/84.png" alt="图70-设备供电展示"></p><p style="text-align:center;">图70-设备供电展示</p><h4 id="建图精度-1"><a href="#建图精度-1" class="headerlink" title="建图精度"></a>建图精度</h4><p>表现 : 基本可以看清大色块纹理,也许需要更准确的标定数据?<strong>(存疑)</strong></p><img src="../images/复现FAST-LIVO2/62.jpg" alt="图71-复杂墙面建图总览" style="zoom:50%;" /><p style="text-align:center;">图71-复杂墙面建图总览</p><img src="../images/复现FAST-LIVO2/60.png" alt="图72-复杂墙面建图细节-1" style="zoom:50%;" /><p style="text-align:center;">图72-复杂墙面建图细节-1</p><img src="../images/复现FAST-LIVO2/61.png" alt="图73-复杂墙面建图细节-2" style="zoom:50%;" /><p style="text-align:center;">图73-复杂墙面建图细节-2</p><img src="../images/复现FAST-LIVO2/63.jpg" alt="图74-大号文字墙面建图" style="zoom:50%;" /><p style="text-align:center;">图74-大号文字墙面建图</p><h4 id="回环精度"><a href="#回环精度" class="headerlink" title="回环精度"></a>回环精度</h4><p>表现 : 长距离回环 z轴有1.8m左右的漂移, x轴,y轴回环较为稳定</p><img src="../images/复现FAST-LIVO2/64.png" alt="图75-回环路径展示" style="zoom:50%;" /><p style="text-align:center;">图75-回环路径展示</p><img src="../images/复现FAST-LIVO2/65.png" alt="图76-回环里程计数据-z轴" style="zoom:50%;" /><p style="text-align:center;">图76-回环里程计数据-z轴</p><img src="../images/复现FAST-LIVO2/66.png" alt="图77-回环里程计数据-x轴(蓝)/y轴(绿)" style="zoom:50%;" /><p style="text-align:center;">图77-回环里程计数据-x轴(蓝)/y轴(绿)</p><h4 id="不同场景"><a href="#不同场景" class="headerlink" title="不同场景"></a>不同场景</h4><ol><li><p>12分钟+室内+室外</p><p>表现 : 里程计数据基本平滑 , 室外相机有过曝情况 , 代码里没有看到和论文中对应的自动调整曝光的部分,也没有发布自动曝光话题 <strong>(存疑)</strong></p><img src="../images/复现FAST-LIVO2/71.jpg" alt="图78-室外场景实时rviz" style="zoom:50%;" /><p style="text-align:center;">图78-室外场景实时rviz</p><img src="../images/复现FAST-LIVO2/67.jpg" alt="图79-室外场景里程计数据总览" style="zoom:50%;" /><p style="text-align:center;">图79-室外场景里程计数据总览</p><img src="../images/复现FAST-LIVO2/68.png" alt="图80-室外场景里程计数据细节" style="zoom:50%;" /><p style="text-align:center;">图80-室外场景里程计数据细节</p></li><li><p>室内</p><p>表现 : 玻璃会影响建图精度,从开发空间进入密闭空间(推门走进楼梯间)易造成错误建图</p><img src="../images/复现FAST-LIVO2/72.jpg" alt="图81-室内场景rviz-1" style="zoom:50%;" /><p style="text-align:center;">图81-室内场景rviz-1</p><img src="../images/复现FAST-LIVO2/73.jpg" alt="图82-室内场景rviz-2" style="zoom:50%;" /><p style="text-align:center;">图82-室内场景rviz-2</p><img src="../images/复现FAST-LIVO2/74.jpg" alt="图83-室内场景rviz-3" style="zoom:50%;" /><p style="text-align:center;">图83-室内场景rviz-3</p></li><li><p>楼梯间</p><p>表现 : 跑飞,窗户处建图错误</p><p>推测 : 楼梯间狭窄且全为白墙,特征点少,avia雷达1-2m处点云质量差,存在盲区</p></li></ol><img src="../images/复现FAST-LIVO2/69.jpg" alt="图84-楼梯间rviz-1" style="zoom:50%;" /><p style="text-align:center;">图84-楼梯间rviz-1</p><img src="../images/复现FAST-LIVO2/70.jpg" alt="图85-楼梯间rviz-2" style="zoom:50%;" /><p style="text-align:center;">图85-楼梯间rviz-2</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目名称-FAST-LIVO2复现&quot;&gt;&lt;a href=&quot;#项目名称-FAST-LIVO2复现&quot; class=&quot;headerlink&quot; title=&quot;项目名称 : FAST-LIVO2复现&quot;&gt;&lt;/a&gt;项目名称 : FAST-LIVO2复现&lt;/h1&gt;&lt;h2 id=&quot;任</summary>
      
    
    
    
    
    <category term="project" scheme="http://example.com/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>课程设计_背单词软件调试记录</title>
    <link href="http://example.com/2025/05/22/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1_%E8%83%8C%E5%8D%95%E8%AF%8D%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2025/05/22/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1_%E8%83%8C%E5%8D%95%E8%AF%8D%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</id>
    <published>2025-05-21T18:05:19.000Z</published>
    <updated>2025-07-04T06:41:05.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h1><h2 id="5-21测试记录"><a href="#5-21测试记录" class="headerlink" title="5.21测试记录"></a>5.21测试记录</h2><p>目前采用静态网页进行可视化</p><ol><li>用户登录未测试,现在根据用户名区分不同用户,密码不管是什么都能登录</li><li>增加home界面,在该页面可选择词书,查询单词,选择学习&#x2F;复习,复习下选择释义测试&#x2F;拼写测试</li><li>查询单词后可选择标记</li><li>个人中心中增加我的数据&#x2F;学习进度.我的数据子菜单下可展开每个掌握度的单词</li><li>将不同词书隔离,不同词书学习进度独立,学习的单词独立</li><li>在Learning界面中乱序展示所有单词,可进行标记</li></ol><h2 id="5-22测试记录"><a href="#5-22测试记录" class="headerlink" title="5.22测试记录"></a>5.22测试记录</h2><p>目前采用静态网页进行可视化</p><ol><li>增加每日学习部分.</li><li>增加profile中学习成果及可视化部分.</li><li>增加复习规则&#x2F;learn帮助&#x2F;review帮助</li><li>缺少按记忆曲线进行复习部分.</li></ol><p>代码已推送至dictionary的visual分支</p><p>&#96;在home界面可更改每日学习词数</p><h2 id="5-23测试记录"><a href="#5-23测试记录" class="headerlink" title="5.23测试记录"></a>5.23测试记录</h2><p>现在复习的逻辑已经完善了<br>可以在个人中心看到今日学习数据&#x2F;复习曲线&#x2F;待复习列表,复习只会在当天对应复习列表的词汇中抽取</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;调试记录&quot;&gt;&lt;a href=&quot;#调试记录&quot; class=&quot;headerlink&quot; title=&quot;调试记录&quot;&gt;&lt;/a&gt;调试记录&lt;/h1&gt;&lt;h2 id=&quot;5-21测试记录&quot;&gt;&lt;a href=&quot;#5-21测试记录&quot; class=&quot;headerlink&quot; title=&quot;5</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Path_planning_learning</title>
    <link href="http://example.com/2025/04/06/Path-planning-learning/"/>
    <id>http://example.com/2025/04/06/Path-planning-learning/</id>
    <published>2025-04-06T10:04:20.000Z</published>
    <updated>2025-05-18T16:26:24.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h1><h2 id="前端-路径寻找"><a href="#前端-路径寻找" class="headerlink" title="前端:路径寻找"></a>前端:路径寻找</h2><h3 id="基于搜索"><a href="#基于搜索" class="headerlink" title="基于搜索"></a>基于搜索</h3><ul><li>图搜索基础</li><li>Dijkstra and A*</li><li>Jump Point Search</li></ul><h3 id="基于采样"><a href="#基于采样" class="headerlink" title="基于采样"></a>基于采样</h3><ul><li>Probabilstic Road Map</li><li>RRT</li><li>RRT* &#x2F; Informed RRT</li></ul><h3 id="基于运动学动态路径寻找"><a href="#基于运动学动态路径寻找" class="headerlink" title="基于运动学动态路径寻找"></a>基于运动学动态路径寻找</h3><ul><li>State-state Boundary Value Optimal Control Problem</li><li>State Lattic Search</li><li>Kinodynamic RRT*</li><li>Hybrid A*</li></ul><h2 id="后端-轨迹生成"><a href="#后端-轨迹生成" class="headerlink" title="后端:轨迹生成"></a>后端:轨迹生成</h2><h3 id="MINIMUN-SNAP-TRAJECTORY-GENERATION"><a href="#MINIMUN-SNAP-TRAJECTORY-GENERATION" class="headerlink" title="MINIMUN SNAP TRAJECTORY GENERATION"></a>MINIMUN SNAP TRAJECTORY GENERATION</h3><h3 id="SOFT-AND-HARD-CONSTRAINED-TRAJECTORY-OPTIMIZATION"><a href="#SOFT-AND-HARD-CONSTRAINED-TRAJECTORY-OPTIMIZATION" class="headerlink" title="SOFT AND HARD CONSTRAINED TRAJECTORY OPTIMIZATION"></a>SOFT AND HARD CONSTRAINED TRAJECTORY OPTIMIZATION</h3><h1 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h1><h2 id="Occupancy-grid-map"><a href="#Occupancy-grid-map" class="headerlink" title="Occupancy grid map"></a>Occupancy grid map</h2><p>github:<a href="https://github.com/ANYbotics/grid_map">https://github.com/ANYbotics/grid_map</a></p><ul><li>排列紧密</li><li>结构化</li><li>索引队列访问</li></ul><p>缺点:当切分过于细密时空间占用率大.</p><h2 id="Octo-map"><a href="#Octo-map" class="headerlink" title="Octo-map"></a>Octo-map</h2><p>github:<a href="https://github.com/OctoMap/octomap_mapping">https://github.com/OctoMap/octomap_mapping</a></p><p>地图中大部分为稀疏部分,使用八叉树的数据结构储存.如果一个区块没有障碍物,不再细分该区块;如果一个区块有障碍物则细分至最小包含该障碍物的区块.</p><p><strong>Octree</strong></p><p>八叉树（Octree）是一种用于描述三维空间的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，将八个子节点所表示的体积元素加在一起就等于父节点的体积。八叉树是四叉树在三维空间上的扩展，二维上我们有四个象限，而三维上，我们有8个卦限。八叉树主要用于空间划分和最近邻搜索。</p><p>实现Octree的原理:</p><ul><li>将当前的立方体细分为八个子立方体。</li><li>如果任何一个子立方体内包含多个点，则将其进一步细分为八个子立方体。</li><li>重复以上操作使得每个子立方体内包含最多一个点。</li></ul><p><img src="/images/path_planning_learning/1.png" alt="八叉树1"></p><p><img src="/images/path_planning_learning/2.webp" alt="八叉树2"></p><ul><li>排列稀疏</li><li>结构化</li><li>非直接索引访问(树的查询)</li></ul><h2 id="Voxel-hashing"><a href="#Voxel-hashing" class="headerlink" title="Voxel hashing"></a>Voxel hashing</h2><p>github:<a href="https://github.com/niessner/VoxelHashing">https://github.com/niessner/VoxelHashing</a></p><p>记录存在碰撞的区块 —-&gt; 哈希表,<strong>字典</strong></p><p>一个bucket中划分为更小的voxel blocks</p><p><img src="/images/path_planning_learning/3.png" alt="Voxel"></p><ul><li>排列最稀疏</li><li>结构化</li><li>非直接索引访问(字典查询)</li></ul><h2 id="Point-Cloud-Map"><a href="#Point-Cloud-Map" class="headerlink" title="Point Cloud Map"></a>Point Cloud Map</h2><ul><li>无序</li><li>无法通过索引队列访问(除非自发遍历)</li></ul><h2 id="TSDF-map"><a href="#TSDF-map" class="headerlink" title="TSDF map"></a>TSDF map</h2><p><strong>Truncated Signed Distance Functions (截断&#x2F;有符号&#x2F;距离函数)</strong></p><p>github:</p><p>TSDF 是一种用于表示3D空间表面的体素网格地图.</p><h3 id="Signed-Distance-Function-SDF"><a href="#Signed-Distance-Function-SDF" class="headerlink" title="Signed Distance Function (SDF)"></a>Signed Distance Function (SDF)</h3><p>对于空间中任意一点 x，SDF 给出它到最近表面的距离 d：<br>$$<br>SDF(x)&#x3D;±d<br>$$</p><ul><li>+d：点在<strong>表面外部</strong>（通常指相机方向）</li><li>−d：点在<strong>表面内部</strong></li><li>d&#x3D;0：点在表面上（即零交叉点）</li></ul><h3 id="Truncated-SDF（TSDF）"><a href="#Truncated-SDF（TSDF）" class="headerlink" title="Truncated SDF（TSDF）"></a>Truncated SDF（TSDF）</h3><p>真实计算中远离表面部分的距离信息不重要且不准确，因此会进行截断：</p><ul><li>若 ∣d∣&gt; μ，则 TSDF 值为截断值。</li><li>μ 是截断距离阈值（truncation distance）。</li></ul><h3 id="Voxel-Grid（体素网格）"><a href="#Voxel-Grid（体素网格）" class="headerlink" title="Voxel Grid（体素网格）"></a>Voxel Grid（体素网格）</h3><p>TSDF 存在于一个 3D 网格中（类似立方体像素）：</p><ul><li>每个体素（voxel）存储：<ul><li>当前体素的 TSDF 值</li><li>加权平均值（来自多个观测帧）</li><li>权重（用于融合多个观测）</li></ul></li></ul><p><img src="/images/path_planning_learning/4.png" alt="TSDF1"></p><p><img src="/images/path_planning_learning/5.png" alt="TSDF2"></p><h2 id="ESDF-Map"><a href="#ESDF-Map" class="headerlink" title="ESDF Map"></a>ESDF Map</h2><p><strong>Euclidean Signed Distance Field 欧几里得有符号距离场</strong></p><p>以 3D 网格（体素）的形式表示环境中每一点<strong>到障碍物最近点的欧几里得距离</strong>，并附带符号来表示点位于障碍物内部或外部。局部ESDF地图:只记忆感兴趣部分的ESDF值.</p><p><img src="/images/path_planning_learning/6.png" alt="ESDF1"></p><p><img src="/images/path_planning_learning/7.png" alt="ESDF2"></p><h2 id="Free-space-Roadmap"><a href="#Free-space-Roadmap" class="headerlink" title="Free-space Roadmap"></a>Free-space Roadmap</h2><p>概率路线图 —-&gt; 安全通行区域,使用<strong>凸多边体</strong>表示</p><p>得到的是一个宽阔的解空间</p><h2 id="Voronoi-Diagram-Map"><a href="#Voronoi-Diagram-Map" class="headerlink" title="Voronoi Diagram Map"></a>Voronoi Diagram Map</h2><p>高效利用ESDF提取地图骨架 —-&gt; 稀疏</p><h1 id="基于搜索的路径寻找"><a href="#基于搜索的路径寻找" class="headerlink" title="基于搜索的路径寻找"></a>基于搜索的路径寻找</h1><h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><p>A*算法在Dijkstra算法的基础上引入了启发函数(贪心思想)，启发函数是对当前节点到目标节点所需代价的预估.启发式函数一般使用曼哈顿距离、欧几里德距离。</p><blockquote><ol><li><p>从起点开始，将其加入待探索的节点集合（open set）。</p></li><li><p>每次选择 f 值最小的节点进行扩展，其中 <code>f(n) = g(n) + h(n)</code></p></li></ol><ul><li><code>g(n)</code> 是从起点到当前节点的实际代价</li><li><code>h(n)</code> 是从当前节点到终点的启发式估计（如直线距离）</li></ul><ol start="3"><li><p>对当前节点的所有相邻节点，计算新的 g 值，更新路径记录。</p></li><li><p>如果发现更优路径（g 值更小），则更新该邻居的记录，并加入 open set。</p></li><li><p>重复以上步骤，直到终点被选中扩展，表示找到最短路径。</p></li><li><p>通过路径记录表回溯，重建从起点到终点的完整路径。</p></li></ol></blockquote><p>伪代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">• 维护一个优先级队列来存储所有待扩容节点<br>• 所有节点的启发式函数<span class="hljs-built_in">h</span>(n)是预定义的<br>• 优先级队列初始化为起始状态 X S<br>• 对图中所有其他节点赋值<span class="hljs-built_in">g</span>(X S) = <span class="hljs-number">0</span>, <span class="hljs-built_in">g</span>(n) = infinite<br>• Loop<br>    •如果队列为空，则返回FALSE；BREAK;<br>    •从优先级队列中删除<span class="hljs-built_in">f</span>(n)=<span class="hljs-built_in">g</span>(n)+<span class="hljs-built_in">h</span>(n)最小的节点“n”<br>    •将节点“n”标记为展开<br>    •如果节点“n”是目标状态，返回TRUE；BREAK;<br>    •对于节点n的所有未展开的邻居 m<br>•<span class="hljs-function">If <span class="hljs-title">g</span><span class="hljs-params">(m)</span> </span>= infinite<br>• <span class="hljs-built_in">g</span>(m)= <span class="hljs-built_in">g</span>(n) + Cnm<br>    •对于节点n的所有未展开的邻居 m<br>•If <span class="hljs-built_in">g</span>(m) = infinite<br>• <span class="hljs-built_in">g</span>(m)= <span class="hljs-built_in">g</span>(n) + Cnm<br>• Push node “m” into the queue<br>•If <span class="hljs-built_in">g</span>(m) &gt; <span class="hljs-built_in">g</span>(n) + C nm<br>•<span class="hljs-built_in">g</span>(m)= <span class="hljs-built_in">g</span>(n) + Cnm<br>•end<br>• End Loop<br></code></pre></td></tr></table></figure><h3 id="Weighted-A-Search"><a href="#Weighted-A-Search" class="headerlink" title="Weighted A* Search"></a>Weighted A* Search</h3><p>Sub-Optimal Solution</p><p>通过人为加大启发函数的影响力来获得更快的搜索速度，以牺牲路径最优性为代价。</p><p>f &#x3D; g + εh, ε &gt; 1 &#x3D;bias towards states that are closer to goal.</p><p><img src="/images/path_planning_learning/8.png" alt="Weighted_A*_Search"></p><ul><li><p>Most Greedy（最贪婪）</p></li><li><p>参数：a&#x3D;0,b&#x3D;1</p></li><li><p>只考虑启发式代价，完全不考虑当前路径代价</p></li><li><p>结果：趋向于直接朝目标点移动，但路径不一定最短或最优</p></li></ul><hr><ul><li><p>Tunable Greediness（可调贪婪度）</p></li><li><p>参数：a&#x3D;1,b&#x3D;ε&gt;1</p></li><li><p>综合考虑当前路径和启发式估计，但偏向启发式</p></li><li><p>结果：平衡探索性和效率，路径更合理</p></li></ul><hr><ul><li><p>Optimal（最优路径）</p></li><li><p>参数：a&#x3D;1,b&#x3D;1</p></li><li><p>平等考虑已知路径和启发估计</p></li><li><p>结果：找到最优路径</p></li></ul><hr><ul><li><p>Dijkstra算法</p></li><li><p>参数：a&#x3D;1,b&#x3D;0</p></li><li><p>完全不使用启发式，只靠实际代价 g,效率低</p></li></ul><h3 id="A-的实施流程"><a href="#A-的实施流程" class="headerlink" title="A*的实施流程"></a>A*的实施流程</h3><ol><li><p>建立地图 → 生成网格节点数组</p></li><li><p>设定障碍 → 标记不可达节点</p></li><li><p>编写邻居搜索函数</p></li><li><p>编写A*主循环：</p><ul><li><p>从openList中取出f值最小的节点</p></li><li><p>计算邻居的g&#x2F;h&#x2F;f值，加入openList</p></li><li><p>更新已访问节点（closedList）</p></li></ul></li><li><p>使用<code>priority_queue</code>或<code>multimap</code>优化性能</p></li></ol><h3 id="最好的启发函数"><a href="#最好的启发函数" class="headerlink" title="最好的启发函数"></a><strong>最好的启发函数</strong></h3><p><strong>最好:tight</strong>,正确的最短距离函数</p><blockquote><p>二维最佳启发函数:<br>$$<br>h2D​&#x3D;(dx+dy)+(2<br>​−2)⋅min(dx,dy)<br>$$<br>三维最佳启发函数:</p><p>我们记 dx,dy,dz为三维网格中当前点与目标点在三个轴上的距离（均为非负整数），有：<br>$$<br>h3D&#x3D;dmin⋅3+(dmid−dmin)⋅2+(dmax−dmid)⋅1<br>$$<br>其中：dmin,dmid,dmax是 dx,dy,dzdx,dy,dz 的排序结果，使得</p><p>$$<br>dmin≤dmid≤dmax<br>$$</p></blockquote><h3 id="Tie-Breaker"><a href="#Tie-Breaker" class="headerlink" title="Tie Breaker"></a>Tie Breaker</h3><p>平局处理器,打破 f 值相等时的探索顺序</p><ul><li>问题:</li></ul><p>​A* 会选取 f 值最小的节点扩展（f&#x3D;g+h）</p><p>​但在一些情形下，很多节点的 f 值完全相等,尤其是在网格图中启发函数不够 tight 的时候</p><p>​导致算法要探索很多不必要的节点，降低效率</p><blockquote><ul><li><strong>解决方法:</strong></li></ul><ol><li>人为干扰 h，让 f 值不同:</li></ol><p>  将原来的启发函数 h乘上一个微小因子：<br>$$<br>  h&#x3D;h×(1.0+p)<br>$$<br>  其中：<br>$$<br>  p &lt; \frac{\text{最小步长代价}}{\text{预期路径总长度}}<br>$$<br>  这样能 <strong>轻微打破平局</strong>，减少无效扩展</p><p>  代价是轻微地破坏启发式的“可采纳性”（admissibility），但常常实际无影响或带来更好效率.</p><ol start="2"><li>优先选 h值小的节点</li></ol><p>  如果两个节点 f 一样，选择 h 小的那个（靠近终点）</p><ol start="3"><li>加入伪随机干扰项（Deterministic random）</li></ol><ul><li>给每个节点加一个唯一扰动，保持一致性但不完全对称</li></ul><ol start="4"><li>优先靠近起点-终点连线的路径</li></ol><p>$$<br>cross&#x3D;∣dx1×dy2−dx2×dy1∣<br>$$</p><p><strong>这其实是在衡量点偏离直线的“面积”，越小越靠近理想路径。</strong></p></blockquote><h2 id="Jump-Point-Search"><a href="#Jump-Point-Search" class="headerlink" title="Jump Point Search"></a>Jump Point Search</h2><p>核心思想:<strong>在两点之间没有障碍物时，中间的节点不考虑,只考虑重要节点.</strong></p><ol><li>邻居修剪 Neighbor Pruning</li></ol><ul><li><p>灰色节点：较差的邻居，当去到它们时，没有分值的路径更便宜。丢弃。</p></li><li><p>白色节点：自然邻居。</p></li></ul><p>​只需要考虑<strong>自然邻居</strong>.</p><p><img src="/images/path_planning_learning/9.png" alt="Neighbor Pruning"></p><ol start="2"><li>强迫邻居 Forced Neighbors</li></ol><p>节点X的邻居节点有障碍物，且X的父节点P经过X到达N的距离代价，比不经过X到大N的任一路径的距离代价都小，则称N是X的强迫邻居。</p><ul><li><p>有相邻的障碍</p></li><li><p>红色节点是强制邻居。</p></li><li><p>一条从父母到他们通过障碍的更便宜的路径被阻断。</p></li></ul><p><img src="/images/path_planning_learning/10.png" alt="Forced Neighbors"></p><ol start="3"><li>跳点(Jump Point)：什么样的节点可以作为跳点<br> (1)节点 A 是起点、终点.<br> (2)节点A 至少有一个强迫邻居.<br> (3)父节点在斜方向(斜向搜索)，节点A的水平或者垂直方向上有满足 (1)、(2) 的节点</li></ol><p><img src="/images/path_planning_learning/11.png" alt="Jump Point"></p><p>跳点搜索中，会递归地检查路径上的邻居节点是否是“跳点”。在检查对角线方向前，会优先尝试直线方向。只要某个节点通往某些邻居的最短路径必须经过它，它就会被标记为跳点。同时，对“强制邻居”不能剪枝，必须展开。</p><h1 id="基于采样的路径寻找"><a href="#基于采样的路径寻找" class="headerlink" title="基于采样的路径寻找"></a>基于采样的路径寻找</h1><h2 id="Probabilistic-Road-Map"><a href="#Probabilistic-Road-Map" class="headerlink" title="Probabilistic Road Map"></a>Probabilistic Road Map</h2><p>图结构</p><p>将规划分为两个阶段：<br>·学习阶段<br>·查询阶段</p><p>检查采样配置和连接的样本之间的碰撞可以有效率地完成任务。<br>数量相对较少的里程碑和局部路径足以捕获的连通性。</p><ul><li>限制路径点连接的长度避免图结构过于复杂</li></ul><h3 id="学习阶段"><a href="#学习阶段" class="headerlink" title="学习阶段:"></a>学习阶段:</h3><ul><li>在c空间中采样N个点</li><li>删除碰撞点</li></ul><p><img src="/images/path_planning_learning/12.png" alt="PRM-Learning1"></p><ul><li>连接到最近的点，并获得无碰撞段。</li><li>删除碰撞段</li></ul><p><img src="/images/path_planning_learning/13.png" alt="PRM-Learning2"></p><h3 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段:"></a>查询阶段:</h3><ul><li>在路线图上搜索，找到从起点到终点的路径目标（使用Dijkstra算法或A*算法）。</li><li>路线图现在类似于网格地图</li></ul><p><img src="/images/path_planning_learning/14.png" alt="PRM-Query"></p><p> 优点</p><ul><li>概率完备</li></ul><p>缺点</p><ul><li><p>要求解决两点边值问题</p></li><li><p>在状态空间上构建图，但不特别关注生成路径</p></li><li><p>效率不高</p></li></ul><h3 id="Lazy-collision-checking"><a href="#Lazy-collision-checking" class="headerlink" title="Lazy collision-checking"></a>Lazy collision-checking</h3><p><strong>效率低</strong>: PRM（Probabilistic Roadmap）或 RRT（Rapidly-exploring Random Tree) 需要频繁地检查从一个配置到另一个配置（或状态）之间的路径是否与障碍物发生碰撞。但碰撞检测是一个昂贵的计算操作，尤其在高维空间或复杂环境中，频繁的碰撞检测会成为性能瓶颈。</p><ul><li>不考虑采样点和生成分段碰撞（懒惰）</li></ul><p>先构建图（PRM）或树（RRT）时不立即检查碰撞，等到真正要使用这条路径时（例如在查询最短路径、或者将路径从树&#x2F;图中提取出来时），再执行碰撞检测。</p><h4 id="PRM-Lazy-collision-checking"><a href="#PRM-Lazy-collision-checking" class="headerlink" title="PRM+Lazy collision-checking"></a><strong>PRM+Lazy collision-checking</strong></h4><ol><li><p>构建 roadmap：采样节点、连接边，不做碰撞检测。</p></li><li><p>查询路径：使用 A* 或 Dijkstra 等算法找到一条从起点到终点的路径。</p></li><li><p>在该路径上进行逐段碰撞检测：</p><ul><li><p>如果全部无碰撞，路径有效；</p></li><li><p>如果某段有碰撞，将该边标记为无效（不可达），从图中删除，重新搜索。</p></li></ul></li></ol><p><img src="/images/path_planning_learning/15.png" alt="Lazy collision-checking"></p><h2 id="Rapidly-exploring-Random-Tree"><a href="#Rapidly-exploring-Random-Tree" class="headerlink" title="Rapidly-exploring Random Tree"></a>Rapidly-exploring Random Tree</h2><p><strong>核心思想:</strong></p><blockquote><p>通过生成next构建树状态在树中通过执行随机控制,从起点开始，不断向随机方向扩展一棵树，迅速探索整个状态空间。</p></blockquote><p>伪代码:</p><p><img src="/images/path_planning_learning/16.png" alt="RRT伪代码"></p><ul><li>初始化一棵树 <code>T</code>，将起始点 <code>X_init</code> 作为树的根节点。</li><li>循环:</li><li>在整个状态空间中随机采样一个点 <code>X_rand</code>，用于探索新方向。</li><li>找出树 <code>T</code> 中距离 <code>X_rand</code> 最近的已有节点 <code>X_nearest</code>。</li><li>从 <code>X_nearest</code> 朝 <code>q_rand</code> 方向延伸一个固定步长delta，生成新点 <code>X_new</code>。</li></ul><p>如果新点 <code>X_new</code> 是可行的（比如不与障碍物碰撞），则执行以下操作:</p><ul><li>把这个新点 <code>X_new</code> 加入树中，作为新的节点。</li><li>在树中添加一条从 <code>X_nearest</code> 到 <code>X_new</code> 的路径边。</li><li>返回整个搜索生成的树 <code>T</code>，它包含从起点开始探索出来的路径结构。</li></ul><p>**提前停止的条件：**因为每一段树枝的末端都是Xnew，所以每产生一次Xnew节点，我们都判断一下Xnew与终点之间的距离，看这个距离是否小于步长，如果小于步长且没有经过障碍物，则就直接把Xnew与终点进行相连。</p><blockquote><p>优点:<br>·旨在找到从起点到目标的路径<br>·比PRM更有针对性<br>缺点:<br>·非最优解<br>·效率不高,在 <strong>narrow环境</strong> 中效率低<br>·整个空间取样</p></blockquote><h3 id="KD树"><a href="#KD树" class="headerlink" title="KD树"></a>KD树</h3><p> Kd-Tree，即K-dimensional  tree，是一棵二叉树，树中存储的是一些K维数据。在一个K维数据集合上构建一棵Kd-Tree代表了对该K维数据集合构成的K维空间的一个划分，即树中的每个结点就对应了一个K维的超矩形区域（Hyperrectangle）。</p><p>关键术语:</p><ul><li>维度（K）：表示数据点所在的空间维数。例如，二维空间中的点有x和y坐标，三维空间中的点有x、y、z坐标。</li><li>节点：KD树的每个节点包含一个K维点及其分割超平面的信息。</li><li>超平面：在K维空间中用于将空间划分为两个部分的（K-1）维子空间。例如，二维空间中的超平面是直线，三维空间中的超平面是平面。</li></ul><p>构建步骤:</p><ol><li><p>输入数据：假设有N个K维数据点。</p></li><li><p>选择分割维度：按照循环顺序选择当前维度。例如，第一个维度（x轴）用于根节点，第二个维度（y轴）用于其子节点，依此类推。</p></li><li><p>选择分割值：在当前分割维度上找到<strong>中位数</strong>点，将其作为当前节点。</p></li><li><p>划分数据：</p><ul><li><p>左子集：所有在当前分割维度上小于中位数点的点。</p></li><li><p>右子集：所有在当前分割维度上大于中位数点的点。</p></li></ul></li><li><p>递归构建子树：对左子集和右子集重复上述步骤，直到所有点都被包含在树中。</p></li><li><p>终止条件：当某一子集为空时，递归终止。</p></li></ol><p><img src="/images/path_planning_learning/17.png" alt="一个创建KD树的例子"></p><p>使用KD树提高<strong>路径规划</strong>效率</p><h3 id="Bidirectional-RRT-RRT-Connect-双向快速扩展随机树"><a href="#Bidirectional-RRT-RRT-Connect-双向快速扩展随机树" class="headerlink" title="Bidirectional RRT &#x2F; RRT-Connect 双向快速扩展随机树"></a>Bidirectional RRT &#x2F; RRT-Connect 双向快速扩展随机树</h3><blockquote><ol><li>初始化两棵树：T_start 以 q_start 为根，T_goal 以 q_goal 为根。</li><li>重复以下过程直到路径找到或迭代上限：<br>a. 从状态空间中采样一个随机点 q_rand。<br>b. 使用 Extend 操作从 T_start 向 q_rand 延伸，得到 q_new。<br>c. 如果扩展成功：<br>i. 使用 Connect 操作让 T_goal 向 q_new 不断扩展，直到无法前进。<br>ii. 如果两个树在某个点连接，则路径找到。<br>d. 交换 T_start 和 T_goal。</li></ol></blockquote><table><thead><tr><th align="center">项目</th><th align="center">单向 RRT</th><th align="center">双向 RRT（RRT-Connect）</th></tr></thead><tbody><tr><td align="center">扩展方向</td><td align="center">只从起点扩展</td><td align="center">起点和终点同时扩展</td></tr><tr><td align="center">搜索速度</td><td align="center">较慢</td><td align="center">更快，更高效</td></tr><tr><td align="center">成功率</td><td align="center">容易陷入复杂障碍</td><td align="center">双向推进更容易绕障碍</td></tr><tr><td align="center">路径质量</td><td align="center">一般</td><td align="center">更好</td></tr><tr><td align="center">复杂性</td><td align="center">低</td><td align="center">高</td></tr></tbody></table><h2 id="Optimal-sampling-based-path-planning-methods"><a href="#Optimal-sampling-based-path-planning-methods" class="headerlink" title="Optimal sampling-based path planning methods"></a>Optimal sampling-based path planning methods</h2><p>在传统采样方法（如 RRT、PRM）的基础上，进一步加入了<strong>路径最优性保证</strong>的算法。最经典的代表是 <strong>RRT</strong>*</p><h3 id="RRT"><a href="#RRT" class="headerlink" title="RRT*"></a>RRT*</h3><p><img src="/images/path_planning_learning/18.png" alt="RRT*伪代码"></p><p><strong>Choose Best Parent</strong>：在新节点周围半径内的已有节点中，选择一条“代价最小”的路径作为父节点；</p><p><strong>Rewire</strong>：反过来看新节点是否能以更小的代价更新周围节点的父节点。</p><h3 id="Kinodynamic-RRT"><a href="#Kinodynamic-RRT" class="headerlink" title="Kinodynamic-RRT*"></a>Kinodynamic-RRT*</h3><p>更改Steer（）函数以适应机器人的运动或其他限制导航(曲线)</p><h2 id="Advanced-Sampling-based-Methods"><a href="#Advanced-Sampling-based-Methods" class="headerlink" title="Advanced Sampling-based Methods"></a>Advanced Sampling-based Methods</h2><h3 id="Inform-RRT"><a href="#Inform-RRT" class="headerlink" title="Inform RRT*"></a>Inform RRT*</h3><p>一旦找到一条路径，其代价为 <code>c_best</code>，就只在以下区域采样：</p><blockquote><p><strong>从起点 <code>q_start</code> 到终点 <code>q_goal</code> 的椭球体区域（Ellipsoidal Sampling Space）</strong><br> 半长轴为 <code>c_best/2</code>，焦点为起点与终点，构成一个最短路径所有可能穿过的区域。</p></blockquote><p><img src="/images/path_planning_learning/18.png" alt="Inform RRT*"></p><h3 id="Cross-entropy-motion-planning"><a href="#Cross-entropy-motion-planning" class="headerlink" title="Cross-entropy motion planning"></a>Cross-entropy motion planning</h3><ol><li><p><strong>初始化一个轨迹分布模型</strong></p><ul><li><p>比如用高斯分布建模一条轨迹（多个中间点组成）</p></li><li><p>初始均值：可能是直线路径，初始方差大</p></li></ul></li><li><p><strong>采样多个轨迹</strong></p><p>每条轨迹是从当前分布中采样得到的一个完整路径（可加速度约束等）</p></li><li><p><strong>评估轨迹代价</strong>:碰撞检测、路径长度、平滑性、目标接近度等</p></li><li><p><strong>选取表现最好的轨迹（Top-k）</strong>:选出“精英轨迹”，即代价最小的那一部分</p></li><li><p>**用精英轨迹更新分布参数:**更新高斯均值和协方差，使下次采样更集中于好路径附近</p></li><li><p><strong>迭代</strong>:重复 2-5，直到满足终止条件（如达到最小代价、收敛、超时等）</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OverView&quot;&gt;&lt;a href=&quot;#OverView&quot; class=&quot;headerlink&quot; title=&quot;OverView&quot;&gt;&lt;/a&gt;OverView&lt;/h1&gt;&lt;h2 id=&quot;前端-路径寻找&quot;&gt;&lt;a href=&quot;#前端-路径寻找&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>接入网综合课设</title>
    <link href="http://example.com/2025/03/10/%E6%8E%A5%E5%85%A5%E7%BD%91%E8%AF%BE%E8%AE%BE/"/>
    <id>http://example.com/2025/03/10/%E6%8E%A5%E5%85%A5%E7%BD%91%E8%AF%BE%E8%AE%BE/</id>
    <published>2025-03-10T02:25:26.000Z</published>
    <updated>2025-04-03T06:36:47.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接入网综合课设"><a href="#接入网综合课设" class="headerlink" title="接入网综合课设"></a>接入网综合课设</h1><h2 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h2><ol><li><p>完成虚拟机选型，并配置至少两个网段， 分别测试子网内和子网间连通性； </p></li><li><p>设计PPPOE本地认证拓扑图及IP地址规划 (客户至少两个网段)  ；</p></li><li><p>选型PPPOE服务器软件，并在虚拟环境下 完成PPPoE接入本地认证的搭建、配置、 实验测试。</p></li></ol><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><h4 id="子网规划"><a href="#子网规划" class="headerlink" title="子网规划"></a>子网规划</h4><p>虚拟机选型：ubuntu20.04</p><p>配置网段：</p><ul><li>Vmnet1:192.168.10.0&#x2F;24</li><li>Vmnet2:192.168.20.0&#x2F;24 </li><li>Vmnet3:192.168.30.0&#x2F;24</li></ul><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/1.png" alt="子网规划"></p><h4 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h4><ol><li>在ubuntu编辑-虚拟网络编辑器中选择更改设置，赋予管理员权限后选择添加网络，类型为<strong>仅主机模式</strong>，修改子网IP和子网掩码。</li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/2.png" alt="虚拟网络编辑器"></p><ol start="2"><li>在ubuntu虚拟机设置中添加网卡，三张为子网规划中定义所对应的网卡。</li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/3.png" alt="虚拟机设置"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/4.png" alt="硬件设置"></p><p>对应网络适配器选择自定义-特定虚拟网络-选择对应网卡-确定。</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/5.png" alt="虚拟机设置"></p><ol start="3"><li>在ubuntu中输入</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><p>出现对应网卡信息。</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/6.png" alt="网卡信息"></p><ol start="4"><li>配置静态IP。参考博客：<a href="https://blog.csdn.net/weixin_58305495/article/details/130554393">Ubuntu配置静态IP</a>，注意与网卡名称匹配。</li></ol><p><strong>Ubuntu 16.04 及更早版本</strong>：网络管理工具使用 <code>ifupdown</code>，网络配置文件在 <code>/etc/network/interfaces</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">auto lo<br>iface lo inet loopback<br><br>auto eth0<br>iface eth0 inet dhcp<br><br>auto eth1<br>iface eth1 inet static<br>address 192.168.10.10<br>netmask 255.255.255.0<br>gateway 192.168.10.1<br>dns-nameservers 8.8.8.8 8.8.4.4<br><br>auto eth2<br>iface eth2 inet static<br>address 192.168.20.10<br>netmask 255.255.255.0<br>gateway 192.168.20.1<br><br>auto eth3<br>iface eth3 inet static<br>address 192.168.30.10<br>netmask 255.255.255.0<br>gateway 192.168.30.1<br><br></code></pre></td></tr></table></figure><p><strong>Ubuntu 17.10 及更高版本</strong>：网络管理工具使用 <code>Netplan</code>，配置文件位于 <code>/etc/netplan/00-installer-config.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Let NetworkManager manage all devices on this system</span><br><span class="hljs-attr">network:</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span><br>  <span class="hljs-attr">ethernets:</span><br>    <span class="hljs-attr">ens33:</span>            <br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span>                          <br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.4</span><span class="hljs-number">.4</span>]       <br><br>    <span class="hljs-attr">ens37:</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.10</span><span class="hljs-string">/24</span>]        <br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span> <span class="hljs-string">default</span><br>          <span class="hljs-attr">via:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.1</span>                <br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">false</span>                          <br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.4</span><span class="hljs-number">.4</span>]      <br><br>    <span class="hljs-attr">ens38:</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.10</span><span class="hljs-string">/24</span>]         <br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span> <span class="hljs-string">default</span><br>          <span class="hljs-attr">via:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.1</span>                <br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">false</span>                          <br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.4</span><span class="hljs-number">.4</span>]   <br><br>    <span class="hljs-attr">ens39:</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.30</span><span class="hljs-number">.10</span><span class="hljs-string">/24</span>]        <br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span> <span class="hljs-string">default</span><br>          <span class="hljs-attr">via:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.30</span><span class="hljs-number">.1</span>              <br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">false</span>                     <br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.4</span><span class="hljs-number">.4</span>]   <br></code></pre></td></tr></table></figure><p>配置完成后执行命令使配置生效。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo netplan apply<br></code></pre></td></tr></table></figure><p>执行<code>ifconfig</code>命令查看当前IP地址。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><strong>子网间连通性</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/7.png" alt="Linux子网间连通性"></p><p>Client1(192.168.10.20)</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/8.png" alt="Client1子网间连通性"></p><p>Client2(192.168.20.20)</p><img src="/images/接入网综合课设/9.png" alt="image-20250308132954522" style="zoom: 80%;" /><p><strong>子网内连通性</strong></p><p>Client1(192.168.10.20)</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/10.png" alt="Client1子网内连通性"></p><p>Client2(192.168.20.20)</p><img src="/images/接入网综合课设/11.png" alt="image-20250308133215681" style="zoom:80%;" /><h3 id="任务三"><a href="#任务三" class="headerlink" title="任务三"></a>任务三</h3><h4 id="PPPoE服务器端"><a href="#PPPoE服务器端" class="headerlink" title="PPPoE服务器端"></a>PPPoE服务器端</h4><p><a href="https://zhuanlan.zhihu.com/p/41499761">参考博客:基于Linux环境的PPPOE服务器搭建</a></p><ol><li>安装PPPoE服务器程序</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get install pppoe<br></code></pre></td></tr></table></figure><p>使用<code>pppoe-server -h</code>查看pppoe安装情况及版本,该PPPoE-Server版本为3.12。</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/12.png" alt="PPPoE服务器版本"></p><ol start="2"><li>编辑&#x2F;etc&#x2F;ppp&#x2F;options文件</li></ol><ul><li>PAP：明文密码认证协议。</li><li>CHAP：挑战握手认证协议，<strong>三次握手</strong>机制，使用哈希加密。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">14+ ms-dns 8.8.8.8<br>57  local<br>144 #+pap  // 关闭pap<br>147 -pap<br>151 +chap  // 开启chap<br>154 #-chap<br>208 proxyarp<br></code></pre></td></tr></table></figure><ol start="3"><li>编辑 pppoe-server-options文件</li></ol><p>创建&#x2F;etc&#x2F;ppp&#x2F;pppoe-server-options文件，使用chap验证协议require-chap，如果使用pap验证协议则配置为 require-pap。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">auth<br>require-chap<br>lcp-echo-interval 60<br>lcp-echo-failure 5     <br>logfile /var/log/pppd.log<br></code></pre></td></tr></table></figure><ol start="3"><li>编辑&#x2F;etc&#x2F;ppp&#x2F;chap-secrets 文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Secrets <span class="hljs-keyword">for</span> authentication using CHAP</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">clientserversecretIP addresses</span><br>test * test *<br></code></pre></td></tr></table></figure><p>用户名为test，密码为test，服务器名和IP地址为任意。</p><ol start="4"><li>开启IP转发功能</li></ol><p>​编辑&#x2F;etc&#x2F;sysctl.conf文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">28 net.ipv4.ip_forward=1<br></code></pre></td></tr></table></figure><p>​运行<code>sudo sysctl -p</code>生效配置。</p><ol start="5"><li>启动PPPoE服务器</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo pppoe-server -I ens37 -L 192.168.10.10 -R 192.168.10.11 -N 20   <br>sudo pppoe-server -I ens38 -L 192.168.20.10 -R 192.168.20.11 -N 20   <br></code></pre></td></tr></table></figure><p><strong>指令含义：</strong></p><table><thead><tr><th>pppoe-server</th><th>启动 PPPoE 服务器进程</th></tr></thead><tbody><tr><td>-I xxx</td><td>监听物理网卡xxx，接受客户端的 PPPoE 拨号请求</td></tr><tr><td>-L IP地址</td><td>PPP 服务器的 IP 地址</td></tr><tr><td>-R IP地址</td><td>客户端分配 IP 的起始地址</td></tr><tr><td>-N n</td><td>最多允许 n 个 PPPoE 客户端同时连接</td></tr></tbody></table><ol start="6"><li>查看PPPoE服务器的启用情况</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ps -ef|grep pppoe<br></code></pre></td></tr></table></figure><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/13.png" alt="pppoe服务器的启用情况"></p><ul><li>如果需要关闭PPPoE服务器，指令为：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo killall pppoe-server<br></code></pre></td></tr></table></figure><ul><li><p>每次电脑重启均需要重新运行PPPoE启动命令，设置开机自启动脚本：</p><ol><li><p>创建systemd服务文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /etc/systemd/system/pppoe-server.service<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs SHELL">[Unit]<br>Description=PPPoE Server Service<br>After=network.target # 等到网络启动后再启动<br><br>[Service]<br>ExecStart=/usr/local/bin/start-pppoe.sh<br>Restart=always<br>RestartSec=5<br>User=root<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">无限制重启</span><br>StartLimitIntervalSec=0<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/bin/start-pppoe.sh<br></code></pre></td></tr></table></figure></li><li><p>创建脚本文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/bin/start-pppoe.sh<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>pppoe-server -I ens37 -L 192.168.10.10 -R 192.168.10.11 -N 20<br>pppoe-server -I ens38 -L 192.168.20.10 -R 192.168.20.11 -N 20<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">保持进程运行</span><br>tail -f /dev/null<br></code></pre></td></tr></table></figure><p>赋予执行权限：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo chmod +x /usr/local/bin/start-pppoe.sh<br></code></pre></td></tr></table></figure></li><li><p>重新加载配置，重启服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo systemctl daemon-reload<br>sudo systemctl reset-failed<br>sudo systemctl enable pppoe-server<br>sudo systemctl start pppoe-server<br></code></pre></td></tr></table></figure></li><li><p>重启后检查服务状态：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ps -ef|grep pppoe<br>sudo systemctl status pppoe-server<br></code></pre></td></tr></table></figure><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/24.png" alt="重启后的服务状态"></p></li></ol><ul><li><p>注：如果systemd服务文件中没有添加<code>StartLimitIntervalSec=0</code>,脚本文件中没有<code>tail -f /dev/null</code>,则有可能报错：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo systemctl status pppoe-server<br>● pppoe-server.service - PPPoE Server Service<br>     Loaded: loaded (/etc/systemd/system/pppoe-server.service; enabled; vendor&gt;<br>     Active: failed (Result: start-limit-hit) since Mon 2025-03-10 00:16:20 CS&gt;<br>    Process: 2386 ExecStart=/usr/local/bin/start-pppoe.sh (code=exited, status&gt;<br>   Main PID: 2386 (code=exited, status=0/SUCCESS)<br><br>3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Scheduled&gt;<br>3月 10 00:16:20 xu-virtual-machine systemd[1]: Stopped PPPoE Server Service.<br>3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Start req&gt;<br>3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Failed wi&gt;<br>3月 10 00:16:20 xu-virtual-machine systemd[1]: Failed to start PPPoE Server Se&gt;<br></code></pre></td></tr></table></figure><p>失败的原因： <code>start-limit-hit</code>，短时间内该服务多次失败，触发了 systemd 的启动限制机制。原脚本<code>start-pppoe.sh</code> 脚本执行完后立即退出，systemd 误以为它崩溃并尝试重启，导致触发 <code>start-limit-hit</code>。</p></li></ul></li></ul><h4 id="PPPoE客户端"><a href="#PPPoE客户端" class="headerlink" title="PPPoE客户端"></a>PPPoE客户端</h4><p>Windows端拨号步骤：</p><ol><li>选择网络和Internet设置</li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/14.png" alt="选择网络和Internet设置"></p><ol start="2"><li>选择拨号-设置新连接-连接到Internet-下一页-宽带</li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/15.png" alt="拨号选择"></p><ol start="3"><li><p>输入用户名和密码</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/16.png" alt="用户名和密码"></p></li><li><p>连接成功</p></li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/17.png" alt="拨号成功"></p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p> 客户端连接成功后，在服务器端输入<code>ifconfig</code>会看到PPP接口信息</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/18.png" alt="PPP接口"></p><p>在客户端输入<code>ipconfig /all</code>  会看到PPP服务器分配的IP地址</p><p><strong>Client1(192.168.10.20)</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/19.png" alt="Client1"></p><p><strong>测试ping通：</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/20.png" alt="Client1"></p><p><strong>Client2(192.168.20.20)</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/21.png" alt="Client2"></p><p>测试ping通：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/22.png" alt="Client2"></p><p><strong>抓包分析</strong></p><p><strong>注意</strong>：执行 <code>sudo wireshark</code> </p><p>Filter 选择pppoe|ppoes。</p><p><strong>PPPoE报文类型</strong></p><table><thead><tr><th>阶段</th><th>以太网协议号</th><th>报文类型</th></tr></thead><tbody><tr><td><strong>发现阶段</strong>（Discovery）</td><td><code>0x8863</code></td><td>PADI, PADO, PADR, PADS, PADT</td></tr><tr><td><strong>会话阶段</strong>（Session）</td><td><code>0x8864</code></td><td>PPP 数据包（LCP、PAP&#x2F;CHAP、IP 数据等）</td></tr></tbody></table><p><strong>PPPoE交互过程</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/32.png" alt="PPPoE交互过程"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/25.png" alt="抓包pppoed"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/26.png" alt="抓包pppoes-1"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/27.png" alt="抓包pppoes-2"></p><p><strong>PPPoE 发现阶段</strong></p><p>PPPoE 发现阶段用于 建立 PPPoE 连接有5种报文：</p><ol><li>PADI（PPPoE Active Discovery Initiation）</li></ol><ul><li><strong>客户端 → 广播</strong> 发送 <strong>PADI</strong>（发现请求）。</li><li>用于查找可用的 PPPoE 服务器（AC, Access Concentrator）。</li><li><strong>目标 MAC 地址：<code>FF:FF:FF:FF:FF:FF</code></strong>（广播）。</li><li>只有Service-Name为空的服务器会响应。</li></ul><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/28.png" alt="抓包pppoed-PADI"></p><ol start="2"><li>PADO（PPPoE Active Discovery Offer）</li></ol><ul><li><strong>服务器（AC）→ 客户端</strong> 回复 <strong>PADO</strong>（提供服务）。</li><li>服务器响应客户端，表明自己可用。</li><li>包含 <strong>服务器名称</strong> 和 <strong>支持的服务</strong>。</li></ul><p><img src="/./images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/29.png" alt="抓包pppoed-PADO"></p><ol start="3"><li>PADR（PPPoE Active Discovery Request）</li></ol><ul><li><p><strong>客户端 → 服务器（AC）</strong> 发送 <strong>PADR</strong>（连接请求）。</p></li><li><p>用户主机可能会收到多个 PADO，但仅查看它收到的 PADO 数据包并选择一个，并请求建立会话。</p></li><li><p>包含 <strong>服务名</strong> 和 <strong>唯一的标识符</strong>。</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/30.png" alt="抓包pppoed-PADR"></p></li></ul><ol start="4"><li>PADS（PPPoE Active Discovery Session-confirmation）</li></ol><ul><li><strong>服务器（AC）→ 客户端</strong> 发送 <strong>PADS</strong>（会话确认）。</li><li><strong>分配一个 PPPoE 会话 ID</strong>，表示连接已建立。</li></ul><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/31.png" alt="抓包pppoed-PADS"></p><ol start="5"><li>PADT（PPPoE Active Discovery Terminate）</li></ol><ul><li>客户端或服务器 发送 <strong>PADT</strong>（终止连接）。</li><li>关闭 PPPoE 连接。</li></ul><p><strong>PPPoE 会话阶段</strong></p><p>PPPoE 发现阶段完成后，客户端和服务器通过 <strong>PPPoE 会话 ID</strong> 进行通信。<br> 此时 PPPoE 封装标准 PPP 报文，包括4种报文：</p><ol><li><strong>LCP（Link Control Protocol）</strong>：链路协商。</li><li><strong>PAP&#x2F;CHAP（Password Authentication Protocol &#x2F; Challenge Handshake Authentication Protocol）</strong>:  用户身份认证。</li><li><strong>NCP（Network Control Protocol)</strong> : 分配 IP 地址。</li><li><strong>IP 数据报文</strong>: 网络通信数据（TCP&#x2F;IP、UDP）。</li></ol><h2 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h2><ol><li>设计PPPoE+RADIUS远程接入控制拓扑图及IP地址规划（客户机至少两个网段）。</li><li>选型RADIUS服务器软件，并在虚拟平台下完成PPPOE+RADIUS远程接入认证的搭建、配置、实验测试。</li></ol><h3 id="任务一-1"><a href="#任务一-1" class="headerlink" title="任务一"></a>任务一</h3><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/42.png" alt="42"></p><h3 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h3><ul><li>RADIUS服务器：FreeRADIUS 3.0.27 （最新stable版本）</li><li>RADIUS客户端：FreeRADIUS -client-1.1.7</li></ul><h4 id="配置Radius服务器及客户端静态IP"><a href="#配置Radius服务器及客户端静态IP" class="headerlink" title="配置Radius服务器及客户端静态IP"></a>配置Radius服务器及客户端静态IP</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /etc/netplan/01-network-manager-all.yaml<br></code></pre></td></tr></table></figure><ul><li><strong>服务器</strong></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Let NetworkManager manage all devices on this system</span><br>network:<br>  version: 2<br>  renderer: NetworkManager<br>  ethernets:<br>    ens33:            <br>      dhcp4: true                           # 启用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br>        <br>    ens37:<br>      addresses: [192.168.30.2/24]        <br>      routes:<br>        - to: default<br>          via: 192.168.30.1                <br>      dhcp4: false                          <br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4] <br></code></pre></td></tr></table></figure><p>配置完成后执行命令使配置生效。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo netplan apply<br></code></pre></td></tr></table></figure><p>执行<code>ifconfig</code>命令查看当前IP地址</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/40.png" alt="40"></p><ul><li><strong>客户端（PPPoE服务器）</strong></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Let NetworkManager manage all devices on this system</span><br>network:<br>  version: 2<br>  renderer: NetworkManager<br>  ethernets:<br>    ens33:            <br>      dhcp4: true                           # 启用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br>        <br>    ens37:<br>      addresses: [192.168.10.1/24]           # 静态 IP 地址<br>      routes:<br>        - to: default<br>          via: 192.168.10.1  # 默认网关<br>      dhcp4: false                           # 禁用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br>        <br>    ens38:<br>      addresses: [192.168.20.1/24]           # 静态 IP 地址<br>      routes:<br>        - to: default<br>          via: 192.168.20.1  # 默认网关<br>      dhcp4: false                           # 禁用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br>        <br>    ens39:<br>      addresses: [192.168.30.1/24]           # 静态 IP 地址<br>      routes:<br>        - to: default<br>          via: 192.168.30.1  # 默认网关<br>      dhcp4: false                           # 禁用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br><br>      link: ens37<br>      addresses:<br>        - 192.168.10.129/25<br></code></pre></td></tr></table></figure><p>配置完成后执行命令使配置生效。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo netplan apply<br></code></pre></td></tr></table></figure><p>执行<code>ifconfig</code>命令查看当前IP地址</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/41.png" alt="41"></p><h4 id="安装Radius服务器"><a href="#安装Radius服务器" class="headerlink" title="安装Radius服务器"></a>安装Radius服务器</h4><ol><li><p>下载Radius：</p><p>freeradius官方网站：<a href="http://freeradius.org/download.html">http://freeradius.org/download.html</a></p><p>freeradius官方文档：</p></li><li><p>解压：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">tar -zxvf freeradius-server-3.0.27.tar.gz <br></code></pre></td></tr></table></figure></li><li><p>安装依赖项</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install build-essential -y<br>sudo apt install libtalloc-dev -y<br>sudo apt install libssl-dev -y<br>sudo apt install libhiredis-dev -y<br>sudo apt install freeradius-mysql<br></code></pre></td></tr></table></figure></li><li><p>编译及安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd  freeradius-server-3.0.26<br>./configure <br>make<br>sudo make install # 默认安装在 /usr/local/etc/raddb下<br></code></pre></td></tr></table></figure></li><li><p>启动Radius</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">debug模式启动</span><br>sudo radiusd -X<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">后台进程方式启动</span><br>systemctl start radiusd<br>systemctl enable radiusd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">日志</span><br>/var/log/radius/radius.log <br></code></pre></td></tr></table></figure></li><li><p>添加用户</p><p>在 &#x2F;usr&#x2F;local&#x2F;etc&#x2F;raddb&#x2F;users 的末尾添加：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">test</span> 的用户设置明文密码为 <span class="hljs-string">&quot;test&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">user Cleartext-Password := <span class="hljs-string">&quot;password&quot;</span></span><br>test Cleartext-Password := &quot;test&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">radtest &lt;用户名&gt; &lt;密码&gt; &lt;服务器地址&gt; &lt;端口&gt; &lt;共享密钥&gt;</span><br>radtest testing password123 127.0.0.1 0 testing123  <br></code></pre></td></tr></table></figure><p>本地测试成功</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/34.png" alt="34"></p></li></ol><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>1.安装mariadb</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install mariadb-server mariadb-client<br>sudo systemctl start mariadb<br>sudo systemctl enable mariadb<br></code></pre></td></tr></table></figure><p>若此时直接运行安全设置<code>mysql_secure_installation</code>，则报错：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">xu@xu-virtual-machine:~/Desktop$ mysql_secure_installation<br><br>NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB<br>      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!<br><br>In order to log into MariaDB to secure it, we&#x27;ll need the current<br>password for the root user.  If you&#x27;ve just installed MariaDB, and<br>you haven&#x27;t set the root password yet, the password will be blank,<br>so you should just press enter here.<br><br>Enter current password for root (enter for none): <br>ERROR 1698 (28000): Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27;<br>Enter current password for root (enter for none): <br>Aborting!<br><br>Cleaning up...<br></code></pre></td></tr></table></figure><p>这是因为 MariaDB 默认使用 <strong><code>auth_socket</code> 插件</strong> 进行身份验证，它不接受通过普通密码登录，只通过 Unix 套接字进行验证。</p><p>解决方案：</p><ul><li><p>通过root用户登录:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo mysql -u root<br></code></pre></td></tr></table></figure></li><li><p>禁用 <code>auth_socket</code> 插件并设置密码:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo mysql<br>USE mysql;<br>SET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;1&#x27;);<br><span class="hljs-meta prompt_"># </span><span class="language-bash">刷新权限并退出</span><br>FLUSH PRIVILEGES;<br>EXIT;<br></code></pre></td></tr></table></figure></li></ul><p>​运行<code>mysql_secure_installation</code>进行安全设置：</p><img src="/images/接入网综合课设/35.png" alt="35" style="zoom: 80%;" /><ol start="2"><li>进入数据库</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p<br></code></pre></td></tr></table></figure><ol start="3"><li>创建数据库并授权</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">MariaDB [(<span class="hljs-keyword">none</span>)]<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> database radius；<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>MariaDB [(<span class="hljs-keyword">none</span>)]<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> radius.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> radius@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;radius&#x27;</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>MariaDB [(<span class="hljs-keyword">none</span>)]<span class="hljs-operator">&gt;</span> flush privileges;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h4 id="配置Radius服务器端和数据库"><a href="#配置Radius服务器端和数据库" class="headerlink" title="配置Radius服务器端和数据库"></a>配置Radius服务器端和数据库</h4><ol><li>导入数据库</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /usr/local/etc/raddb/mods-config/sql/main/mysql<br>mysql -u radius -p radius&lt; schema.sql<br></code></pre></td></tr></table></figure><p>如果报错：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">root@xu-virtual-machine:/usr/local/etc/raddb/mods-config/sql/main/mysql# mysql -u radius -p radius&lt; schema.sql<br>Enter password: <br>ERROR 1045 (28000): Access denied for user &#x27;radius&#x27;@&#x27;localhost&#x27; (using password: YES)<br></code></pre></td></tr></table></figure><p>这是因为 MySQL 用户 <code>radius</code> 在 <code>localhost</code> 上的访问被拒绝，重新设置密码</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;radius&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;your_password&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> radius.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;radius&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>配置Radius</p><ul><li><p>配置default文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo -i<br>gedit /usr/local/etc/raddb/sites-enabled/default<br></code></pre></td></tr></table></figure><p>使用数据库储存用户信息&#x2F;计费：</p><p>在538行authenticate {}部分，注释files，解注释sql</p><p>在673行accounting{}部分，解注释 sql</p></li><li><p>配置sql文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo -i<br>gedit /usr/local/etc/raddb/mods-available/sql<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置文件</span><br>tls_required = no<br>driver = &quot;rlm_sql_mysql&quot;  # 指定 FreeRADIUS 使用 MySQL 数据库作为后端数据库来进行认证和计费<br>dialect = &quot;mysql&quot;         # mysql 表示使用 MySQL 数据库的 SQL 方言<br>server = &quot;localhost&quot;      # 数据库运行在本地计算机上<br>port = 3306 <br>login = &quot;radius&quot;<br>password = &quot;radius&quot;<br>radius_db = &quot;radius&quot;<br>read_clients = yes         # 允许 FreeRADIUS 从数据库中读取客户端信息                                      、<br></code></pre></td></tr></table></figure></li></ul></li><li><p>客户端认证设置</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/raddb/clients.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">定义 PPPoE 客户端连接到服务器时需要使用的 IP 地址和密码（共享密钥）</span><br>client pppoe-server &#123;<br>    ipaddr = 192.168.30.1<br>    secret = testing123<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>配置组与用户信息</li></ol><ul><li>进入radius库</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo mysql -u root -p radius<br></code></pre></td></tr></table></figure><ul><li>新建组</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">insert into radgroupcheck (groupname,attribute,op,value) values  (&#x27;usr&#x27;,&#x27;Auth- Type&#x27;,&#x27;:=&#x27;,&#x27;Local&#x27;);<br>insert into radgroupcheck (groupname,attribute,op,value) values (&#x27;usr&#x27;,&#x27;Service-Type&#x27;,&#x27;:=&#x27;,&#x27;Framed-User&#x27;);<br>insert into radgroupcheck (groupname,attribute,op,value) values (&#x27;usr&#x27;,&#x27;Framed-IP-Address&#x27;,&#x27;:=&#x27;,&#x27;255.255.255.255&#x27;);<br>insert into radgroupcheck (groupname,attribute,op,value) values (&#x27;usr&#x27;,&#x27;Framed-IP-Netmask&#x27;,&#x27;:=&#x27;,&#x27;255.255.255.0&#x27;);<br></code></pre></td></tr></table></figure><p>查看新建组 <code>select * from radgroupcheck; </code></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/36.png" alt="36"></p><p>可以看到，<code>usr</code> 组的认证方式为 <strong>本地认证（Local）</strong>， <code>Service-Type</code> 为 Framed-User，即拨号用户，用于 <strong>PPP&#x2F;PPPoE 认证</strong>。分配给用户的 IP 地址为255.255.255.255，表示 不指定具体 IP 地址，由PPPoE 服务器动态分配。若分配了 IP 地址，默认子网掩码为 <code>255.255.255.0</code>。</p><ul><li><p>配置 RADIUS 认证用户</p><p>定义 RADIUS 用户，用于身份验证。</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/raddb/users<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对于 client-1</span><br>user1 Cleartext-Password := &quot;test-1&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">对于 client-2</span><br>user2 Cleartext-Password := &quot;test-2&quot;<br></code></pre></td></tr></table></figure><ul><li>插入用户</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> radcheck (username, attribute, op, <span class="hljs-keyword">value</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;user1&#x27;</span>, <span class="hljs-string">&#x27;Cleartext-Password&#x27;</span>, <span class="hljs-string">&#x27;:=&#x27;</span>, <span class="hljs-string">&#x27;test-1&#x27;</span>); <br><span class="hljs-keyword">INSERT INTO</span> radcheck (username, attribute, op, <span class="hljs-keyword">value</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;user2&#x27;</span>, <span class="hljs-string">&#x27;Cleartext-Password&#x27;</span>, <span class="hljs-string">&#x27;:=&#x27;</span>, <span class="hljs-string">&#x27;test-2&#x27;</span>); <br></code></pre></td></tr></table></figure><p>查看用户信息 <code>SELECT * FROM radcheck; </code></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/37.png" alt="37"></p><ul><li>关联用户和组</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> radusergroup (username, groupname) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;user1&#x27;</span>, <span class="hljs-string">&#x27;usr&#x27;</span>);<br><span class="hljs-keyword">INSERT INTO</span> radusergroup (username, groupname) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;user2&#x27;</span>, <span class="hljs-string">&#x27;usr&#x27;</span>);<br></code></pre></td></tr></table></figure><p>查看用户和组的关联信息 <code>SELECT * FROM radusergroup; </code></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/38.png" alt="38"></p><ul><li>建立软链接</li></ul><p>在 FreeRADIUS 服务器的配置目录中启用 SQL 模块</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo -i<br>cd /usr/local/etc/raddb/mods-enabled<br>ln -s /usr/local/etc/raddb/mods-available/sql ./<br></code></pre></td></tr></table></figure><p>查看软链接信息 <code>ls -l /usr/local/etc/raddb/mods-enabled/sql </code><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/39.png" alt="39"></p><ul><li>本地测试用户链接：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">radtest user1 test-1 127.0.0.1 0 testing123<br>radtest user2 test-2 127.0.0.1 0 testing123<br></code></pre></td></tr></table></figure><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/44.png" alt="44"></p><h4 id="配置Radius客户端"><a href="#配置Radius客户端" class="headerlink" title="配置Radius客户端"></a>配置Radius客户端</h4><ol><li>下载并安装RADIUS -clients</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wget ftp://ftp.freeradius.org/pub/freeradius/freeradius-client-1.1.7.tar.gz<br>tar -xzvf freeradius-client-1.1.7.tar.gz <br><br>cd freeradius-client-1.1.7/<br>./configure <br>sudo make<br>sudo make install<br></code></pre></td></tr></table></figure><ol start="2"><li>在 PPPoE 服务器中启用 RADIUS 认证</li></ol><p>​在&#x2F;etc&#x2F;ppp&#x2F;pppoe-server-options中增加</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加载 radius.so 插件</span><br>plugin /usr/lib/pppd/2.4.7/radius.so<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定 RADIUS 客户端配置文件</span><br>radius-config-file /usr/local/etc/radiusclient/radiusclient.conf<br></code></pre></td></tr></table></figure><ol start="3"><li>配置radiusclient.conf文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/radiusclient/radiusclient.conf<br></code></pre></td></tr></table></figure><p>在文件末尾添加：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">认证顺序：先本地认证，再 RADIUS 远程认证</span><br>auth_order      local,radius<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS 认证服务器</span><br>authserver      192.168.30.2:1812<br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS 计费服务器</span><br>acctserver      192.168.30.2:1813<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS 共享密钥存放</span><br>servers        /usr/local/etc/radiusclient/servers<br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS 共享密钥文件</span><br>seqfile        /var/run/radius.seq<br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS映射文件</span><br>mapfile        /usr/local/etc/radiusclient/port-id-map<br>dictionary     /usr/local/etc/radiusclient/dictionary<br>login_radius   /usr/local/sbin/login.radius<br></code></pre></td></tr></table></figure><ol start="4"><li>配置 server 文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/radiusclient/servers<br></code></pre></td></tr></table></figure><p>在文件末尾添加：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">[RADIUS服务器IP]  [共享密钥]  [可选参数]</span><br>192.168.30.2 testing123<br></code></pre></td></tr></table></figure><ol start="5"><li>配置dictionary文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/radiusclient/dictionary<br></code></pre></td></tr></table></figure><p>在文件末尾添加：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">INCLUDE /usr/local/etc/radiusclient/dictionary.sip<br>INCLUDE /usr/local/etc/radiusclient/dictionary.ascend<br>INCLUDE /usr/local/etc/radiusclient/dictionary.merit<br>INCLUDE /usr/local/etc/radiusclient/dictionary.compat<br>INCLUDE /usr/local/etc/radiusclient/dictionary.microsoft<br></code></pre></td></tr></table></figure><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><ul><li><p>PPPoE服务器启动情况</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/43.png" alt="43"></p></li><li><p>Radius服务器启动情况</p></li></ul><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/45.png" alt="45"></p><ul><li><strong>Client1</strong></li></ul><p>输入正确用户及密码（user1，test-1），拨号成功</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/46.png" alt="46"></p><p>PPPoE服务器已分配地址：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/47.png" alt="47"></p><p>上网测试：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/49.png" alt="49"></p><p>在Radius服务器端本次会话记录:</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/50.png" alt="50"></p><p>输入错误用户及密码（user1，test-2），拨号失败</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/51.png" alt="51"></p><p>在Radius服务器端本次会话记录:</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/53.png" alt="53"></p><ul><li><strong>Client2</strong></li></ul><p>输入正确用户密码（user2，test-2），拨号成功</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/46.png" alt="46"></p><p>PPPoE服务器已分配地址：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/48.png" alt="48"></p><p>上网测试：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/49.png" alt="49"></p><p>在Radius服务器端本次会话记录:</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/52.png" alt="52"></p><p>输入错误用户及密码（user2，test-1），拨号失败</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/51.png" alt="51"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/54.png" alt="54"></p><h4 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h4><p>RADIUS报文格式</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/55.png" alt="55"></p><p>RADIUS 报文类型分为 认证报文 和 计费报文：</p><p><strong>1. 认证报文（Authentication Messages）</strong></p><p>认证报文用于 <strong>用户身份验证</strong>，确保用户合法，并为其分配相应权限。常见类型如下：</p><table><thead><tr><th>报文类型</th><th>代码</th><th>作用</th></tr></thead><tbody><tr><td><strong>Access-Request</strong></td><td><code>1</code></td><td>认证请求，客户端（NAS）向 RADIUS 服务器发送，包含用户名、密码等信息</td></tr><tr><td><strong>Access-Accept</strong></td><td><code>2</code></td><td>认证通过，RADIUS 服务器返回，NAS 允许用户访问</td></tr><tr><td><strong>Access-Reject</strong></td><td><code>3</code></td><td>认证失败，RADIUS 服务器拒绝用户访问</td></tr><tr><td><strong>Access-Challenge</strong></td><td><code>11</code></td><td>质询认证，要求客户端提供额外凭证（如 EAP 认证）</td></tr></tbody></table><p>** 2. 计费报文（Accounting Messages）**</p><p>计费报文用于 <strong>记录用户上网时长、流量等信息</strong>，用于后续计费。常见类型如下：</p><table><thead><tr><th>报文类型</th><th>代码</th><th>作用</th></tr></thead><tbody><tr><td><strong>Accounting-Request</strong></td><td><code>4</code></td><td>计费请求，NAS 发送给 RADIUS 服务器，包含用户会话信息</td></tr><tr><td><strong>Accounting-Response</strong></td><td><code>5</code></td><td>计费响应，RADIUS 服务器收到计费信息后确认</td></tr></tbody></table><p><code>Accounting-Request</code> 又分为：</p><ul><li><strong>Start</strong>（用户上线）：用户开始上网时发送，记录 <code>acctstarttime</code>。</li><li><strong>Interim-Update</strong>（状态更新）：定期发送，更新流量、时长等数据。</li><li><strong>Stop</strong>（用户下线）：用户断开时发送，记录 <code>acctstoptime</code>、<code>acctsessiontime</code>、流量。</li></ul><p>RADIUS客户端与服务器交互过程：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/56.png" alt="56"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/57.png" alt="57"></p><p><strong>Access-Request</strong>：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/58.png" alt="58"></p><p><strong>Access-Accept</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/59.png" alt="59"></p><p><strong>Access-Reject</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/60.png" alt="60"></p><p><strong>Accounting-Request</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/61.png" alt="61"></p><p><strong>Accounting-Response</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/62.png" alt="62"></p><h4 id="遇到的问题及调试方法"><a href="#遇到的问题及调试方法" class="headerlink" title="遇到的问题及调试方法"></a>遇到的问题及调试方法</h4><p>在Radius全面配置好后，windows客户端无法直接拨号，否则显示691错误码，在radius端无信息反馈。推测PPPoE与客户端间传输存在问题。接回PPPoE本地测试可通。</p><p>使用<code>sudo tail -f /var/log/syslog | grep ppp</code>监听PPPoE服务器信息</p><p>当客户端拨号时，报错：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Apr  3 11:19:13 xu-virtual-machine pppd[2901]: rc_read_dictionary: invalid type on line 92 of dictionary /usr/local/etc/radiusclient/dictionary<br>Apr  3 11:19:13 xu-virtual-machine pppd[2901]: RADIUS: Can&#x27;t read dictionary file /usr/local/etc/radiusclient/dictionary<br>Apr  3 11:19:13 xu-virtual-machine pppd[2901]: Peer user2 failed CHAP authentication<br></code></pre></td></tr></table></figure><ul><li><p>把<code>/usr/local/etc/radiusclient/dictionary</code>文件中所有<code>ipv6addr</code>和<code>ipv6prdeix</code>改成<code>string</code></p></li><li><p>下载dictionary.microsoft，只有使用该文件才支持Windows拨号</p></li><li><p>在<code>/usr/local/etc/radiusclient/dictionary</code>末尾加上</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">INCLUDE /usr/local/etc/radiusclient/dictionary.sip<br>INCLUDE /usr/local/etc/radiusclient/dictionary.ascend<br>INCLUDE /usr/local/etc/radiusclient/dictionary.merit<br>INCLUDE /usr/local/etc/radiusclient/dictionary.compat<br>INCLUDE /usr/local/etc/radiusclient/dictionary.microsoft<br></code></pre></td></tr></table></figure><p>之后再拨号，Radius服务器端显示报错信息，根据具体报错信息修改即可。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;接入网综合课设&quot;&gt;&lt;a href=&quot;#接入网综合课设&quot; class=&quot;headerlink&quot; title=&quot;接入网综合课设&quot;&gt;&lt;/a&gt;接入网综合课设&lt;/h1&gt;&lt;h2 id=&quot;阶段一&quot;&gt;&lt;a href=&quot;#阶段一&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="课设" scheme="http://example.com/tags/%E8%AF%BE%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>网络算法基础</title>
    <link href="http://example.com/2025/02/27/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2025/02/27/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2025-02-27T06:35:01.000Z</published>
    <updated>2025-10-16T06:28:58.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法与分治"><a href="#算法与分治" class="headerlink" title="算法与分治"></a>算法与分治</h1><p>Divide and Conquer（DC）</p><p>Divide：将源问题分解为规模较小的子问题，<strong>拆分问题性质相同</strong>，将子问题的解组合成原问题的解。</p><p>Conquer：如果子问题仍然困难，就继续对子问题进行分解，直到子问题可以被trivial。</p><p>Recursion：用递归的方式实现。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>问题定义：</p><ul><li><p>输入：n个数构成的数组;</p></li><li><p>输出：排列该n个数的有序数组。</p></li></ul><p>Merg Sort：</p><ul><li>分解：将原数组等分为两个子数组;</li><li>求解：递归地对两个子数组分别排序;</li><li>合并：将两个已排序的子数组合并。</li></ul><h3 id="Merge-Step"><a href="#Merge-Step" class="headerlink" title="Merge Step"></a>Merge Step</h3><p> <strong>CLAIM</strong>：对于n ≥ 1的数组，MergeSort需要的运行时间T(n) ≤ $ 6n \log_2 n + 6n $</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/1.PNG" alt="图片" title="证明"></p><h3 id="函数增长的渐进符号"><a href="#函数增长的渐进符号" class="headerlink" title="函数增长的渐进符号"></a>函数增长的渐进符号</h3><p><strong>Big O</strong>: 如果存在正数c和N，对于所有的n&gt;&#x3D;N，有f(n)&lt;&#x3D;c*g(n)，则f(n)&#x3D;O(g(n))。</p><p><strong>Big Omega</strong>：如果存在正数c和N，对于所有的n&gt;&#x3D;N，有f(n)&gt;&#x3D;c*g(n)，则f(n)&#x3D;Omega(g(n))。</p><p><strong>Big Theta</strong>：f(n)&#x3D;Theta(g(n))，当且仅当f(n)&#x3D;O(g(n))且f(n)&#x3D;Omega(g(n))。</p><h3 id="基于比较的排序"><a href="#基于比较的排序" class="headerlink" title="基于比较的排序"></a>基于比较的排序</h3><p><strong>CLAIM</strong>：任何基于比较的排序算法，RT不可能低于O(nlogn)。</p><p>任何基于两两比较的排序算法都可以表达为一棵决策树（完全二叉树）。</p><p>完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/2.PNG" alt="图片" title="决策树的性质"></p><h3 id="主办法（Master-Method）"><a href="#主办法（Master-Method）" class="headerlink" title="主办法（Master Method）"></a>主办法（Master Method）</h3><p><strong>主定理</strong></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/3.PNG" alt="图片" title="主定理的定义"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/4.PNG" alt="图片" title="主定理的证明"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/5.PNG" alt="图片" title="参数"></p><h1 id="图简介"><a href="#图简介" class="headerlink" title="图简介"></a>图简介</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><strong>树</strong>：不包含任何圈的连通图。</p><p><strong>生成树(Spanning Tree)</strong>：如果图G的一个子图包含了G的全部顶点，且为树，则称之为G的生成树。</p><h2 id="图搜索"><a href="#图搜索" class="headerlink" title="图搜索"></a>图搜索</h2><h3 id="循环不变式"><a href="#循环不变式" class="headerlink" title="循环不变式"></a>循环不变式</h3><ul><li>概念：每次循环开始时都要保持的性质 &#x2F; 状态。</li><li><strong>INVARIANT</strong>：已探索集合和未探索集合应该处于正确的状态。边界点集合应准备好了。<ul><li>循环开始时，从边界点集合中选择一个顶点进行探索。</li><li>循环结束前，将新扩展的边界点纳入集合。</li></ul></li><li>维护边界点集合：<ul><li><strong>BFS：队列(FIFO)</strong></li><li><strong>DFS：堆栈(LIFO)</strong></li></ul></li></ul><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>BFS的伪代码：</p><pre><code>BFS(Graph, start):B.EnQueue(s)WHILE B is not empty:    d=B.DeQueue();    标记d为“已探索”    FOR each neighbor t of d:        IF t is not in visited:            B.EnQueue(t)        ENDIF    ENDFORENDWHILE</code></pre><p><strong>聚合分析复杂度</strong>：O(n+m)</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>DFS的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">DFS(Graph, start):<br>B.Push(s)<br>WHILE B is not empty:<br> d = B.Pop()<br> 标记 d 为“已探索”<br> FOR each neighbor t of d:<br>  IF t is not in visited:<br>   B.Push(t)<br>  ENDIF<br> ENDFOR<br>ENDWHILE<br></code></pre></td></tr></table></figure><p><strong>聚合分析复杂度</strong>：O(n+m)</p><h2 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h2><h3 id="无向图的连通分量"><a href="#无向图的连通分量" class="headerlink" title="无向图的连通分量"></a><u>无向图</u>的连通分量</h3><p>下述等价关系的等价类：当且仅当图中具有u-v路径时，称u~v。</p><h4 id="BFS求无向连通分量"><a href="#BFS求无向连通分量" class="headerlink" title="BFS求无向连通分量"></a>BFS求无向连通分量</h4><p>BFS求无向连通分量的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Loop-BFS(G):<br>FOR i=1 to n<br>IF t is not in visited:<br>BFS(G,i);<br>ENDFOR<br></code></pre></td></tr></table></figure><p><strong>聚合分析复杂度</strong>：O(n+m)</p><h3 id="有向图的强连通分量（Strongly-Connected-Component-SCC）"><a href="#有向图的强连通分量（Strongly-Connected-Component-SCC）" class="headerlink" title="有向图的强连通分量（Strongly Connected Component,SCC）"></a><u>有向图</u>的强连通分量（Strongly Connected Component,SCC）</h3><p>下述等价关系的等价类：当且仅当有向图G中具有u -&gt; v路径且具有v -&gt; u路径时，称称u~v。</p><h4 id="TWO-PASS算法-Kosaraju算法"><a href="#TWO-PASS算法-Kosaraju算法" class="headerlink" title="TWO-PASS算法(Kosaraju算法)"></a>TWO-PASS算法(Kosaraju算法)</h4><ol><li>构建逆图。</li><li><strong>在逆图中进行 Loop-DFS</strong>，记录每个节点的<strong>完成时间</strong> f(v)。</li><li><strong>在原图中运行 Loop-DFS</strong>，按照逆图 DFS 完成的节点顺序进行，确定每个节点的 Leader。</li></ol><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/6.PNG" alt="图片" title="Kosaraju算法-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/7.PNG" alt="图片" title="Kosaraju算法-2"></p><p><strong>聚合分析复杂度</strong>：O(n+m)</p><h4 id="关键引理"><a href="#关键引理" class="headerlink" title="关键引理"></a><strong>关键引理</strong></h4><p>Key Lemma：考虑有向图G中的两个临接SCC，f(v)表示顶点v在反向图G’中Loop-DFS的完成时间，则有：<br>$$<br>\max_{v \in C_1} f(v) &lt; \max_{v \in C_2} f(v)<br>$$<br>推论：最大的f值必然在”sink“SCC中。</p><h1 id="贪心MST"><a href="#贪心MST" class="headerlink" title="贪心MST"></a>贪心MST</h1><h2 id="贪心vs分治"><a href="#贪心vs分治" class="headerlink" title="贪心vs分治"></a>贪心vs分治</h2><ul><li><strong>决策过程</strong>：<ul><li><strong>分治</strong>：每个子问题的解都会考虑整个子问题的情况，逐步拆解，最终合并。</li><li><strong>贪心</strong>：每一步决策只关注当前的局部最优解，不回头。</li></ul></li><li><strong>全局与局部</strong>：<ul><li><strong>分治</strong>：每个子问题的解可能涉及整个问题的全局结构。</li><li><strong>贪心</strong>：每一步只考虑局部最优解，期望通过局部最优解得到全局最优解。</li></ul></li><li><strong>解决问题的方式</strong>：<ul><li><strong>分治</strong>：递归地分解问题，直到子问题足够简单直接求解。</li><li><strong>贪心</strong>：通过逐步选择当前最优的解来构建最终解。</li></ul></li><li><strong>是否需要回溯</strong>：<ul><li><strong>分治</strong>：通常会回溯并合并结果。</li><li><strong>贪心</strong>：不会回溯，一旦做出选择就不再修改。</li></ul></li></ul><h2 id="MST（前提：无向图）"><a href="#MST（前提：无向图）" class="headerlink" title="MST（前提：无向图）"></a>MST（前提：无向图）</h2><p><strong>定义</strong>：最小权重生成树T。</p><ul><li>必须是无向图;</li><li>生成树的权重定义为树上边权重之和;</li><li>生成树定义为E的子集：<ol><li>必须覆盖V;</li><li>无环;</li><li>连通。</li></ol></li></ul><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/8.PNG" alt="图片" title="MST"></p><h3 id="割"><a href="#割" class="headerlink" title="割"></a>割</h3><p>割的概念：图G(V，E)的一个割(Cut)是V的一个划分，该划分将集合V分为两个非空的集合。</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/9.PNG" alt="图片" title="割"></p><ul><li>n个顶点的图最多有 $ 2^n-2 $ 个不同的割。</li></ul><p><strong>Empty-Cut引理</strong>：图G不连通，当且仅当Cut(A，B)没有割边。</p><p><strong>Double-Crossing Lemma</strong>：如果某个圈C⊆E中有边跨越了Cut(A，B)，则C中<strong>至少还有一条边</strong>跨越Cut(A，B)。</p><p><strong>Lonely-Cut Corollary</strong>：如果边e是跨越了Cut(A，B)的唯一一条边，则e不可能在<strong>任一</strong>圈中。</p><p><strong>The Cut Property</strong>：考虑图G中的一条边e，如果存在Cut(A，B)，使得e是所有跨越该割的所有边中权最小者，则e一定在G的MST中。</p><p>割的证明：</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/10.PNG" alt="图片" title="割的证明-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/11.PNG" alt="图片" title="割的证明-2"></p><h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><p>一个容器，其中元素具有key。</p><p>常规操作及对应的RT：</p><ul><li>Heapify：建堆 O(n)</li><li>Insert：加入一个新的对象 O(logn)</li><li>Extract-Min：从堆中取出具有最小key的元素 O(logn)</li><li>Delete：删除指定元素 O(logn)</li></ul><h4 id="Heap-Property"><a href="#Heap-Property" class="headerlink" title="Heap Property"></a><strong>Heap Property</strong></h4><ul><li>堆是一颗有根，二叉，尽可能完全的树。</li><li>任何节点的key都不大于其所有子代的key。 ——&gt; <strong>根元素具有最小key</strong></li></ul><h4 id="用数组实现堆"><a href="#用数组实现堆" class="headerlink" title="用数组实现堆"></a><strong>用数组实现堆</strong></h4><ul><li>Parent (i) &#x3D; i &#x2F; 2  （下标i为奇数时向下取整）</li><li>LeftC (i) &#x3D; 2i</li><li>RightC (i) &#x3D; 2i + 1</li></ul><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/12.PNG" alt="图片" title="堆的操作-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/13.PNG" alt="图片" title="堆的操作-2"></p><h3 id="Prime算法"><a href="#Prime算法" class="headerlink" title="Prime算法"></a><strong>Prime算法</strong></h3><p>基本思想：</p><ul><li>从一个节点开始（任意选择一个节点作为起点），将它加入生成树。</li><li>找到当前生成树中所有节点与其他节点之间的边，选择权重最小的边。</li><li>将与该边相连的节点加入生成树，更新最小边的权重，重复选择最小边的过程。</li><li>直到所有节点都被加入到生成树中。</li></ul><p>Pim的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Prim(Graph, start):<br>    初始化最小生成树的边集合 MST = &#123;&#125;<br>    初始化一个优先队列 Q，用于存储每个节点及其最小边的权重<br>    对于每个节点 v ∈ Graph:<br>        设置 v 的最小权重为无穷大（∞）<br>    设置 start 节点的最小权重为 0，并将其加入 Q<br><br>    WHILE Q is not empty:<br>        选择 Q 中最小的权重的节点 u<br>        标记 u 为“已加入到最小生成树”<br><br>        对于 u 的每个邻居 v:<br>            IF v is not in MST AND weight(u, v) &lt; v 的当前权重:<br>                更新 v 的最小权重为 weight(u, v)<br>                将 v 更新到 Q 中，以反映其新的最小权重<br><br>        ENDFOR<br>    ENDWHILE<br></code></pre></td></tr></table></figure><p>Prim算法的证明：</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/14.PNG" alt="图片" title="Prim的证明-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/15.PNG" alt="图片" title="Prim的证明-2"></p><p>用堆实现Prim：</p><pre><code>Prim(Graph, start):    初始化最小生成树 MST = &#123;&#125;    初始化最小堆 MinHeap    初始化一个集合 Visited，用于记录已加入 MST 的节点    将 (0, start) 插入 MinHeap  // (边的权重, 节点)    初始化 total_weight = 0  // 记录最小生成树的总权重WHILE MinHeap is not empty:    (weight, node) = MinHeap.Pop()  // 取出当前权重最小的边    IF node 已在 Visited:        CONTINUE  // 如果该节点已经在 MST 中，跳过    标记 node 为已访问    total_weight += weight  // 累加权重    MST.Add(node)    FOR each (neighbor, edge_weight) in Graph[node]:  // 遍历邻居        IF neighbor 不在 Visited:            MinHeap.Push((edge_weight, neighbor))  // 只加入未访问的节点RETURN MST, total_weight</code></pre><p><strong>复杂度分析</strong>：</p><ul><li>n次Extract-Min：O(nlogn)</li><li>m次Delete和m次Insert：O(mlogn)</li></ul><p>总RT &#x3D; O(nlogn)+O(mlogn) &#x3D; <strong>O(mlogn)</strong></p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>基本思想：</p><ul><li>按权重升序对边排序。</li><li>按序逐条检查边。</li><li>只要不成环，就将边加入T。</li></ul><p>Kruskal的伪代码：</p><pre><code>Kruskal(Graph):    初始化最小生成树 MST = &#123;&#125;    初始化并查集（Union-Find）来管理连通性    按照权重从小到大排序 Graph 的所有边 EdgeListFOR (u, v, weight) in EdgeList:  // 遍历排序后的边    IF u 和 v 不在同一个连通分量 (Find(u) ≠ Find(v)):        MST.Add((u, v, weight))  // 加入最小生成树        Union(u, v)  // 合并连通分量    IF MST 的边数 == V - 1:        BREAK  // 最小生成树构建完成RETURN MST</code></pre><p>Kruskal算法的证明：</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/16.PNG" alt="图片" title="Kruskal的证明-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/17.PNG" alt="图片" title="Kruskal的证明-2"></p><h4 id="UNION-FIND算法"><a href="#UNION-FIND算法" class="headerlink" title="UNION-FIND算法"></a>UNION-FIND算法</h4><p>Union-Find（并查集）是一种高效的数据结构，主要用于<strong>处理动态连通性问题</strong>。它支持两种核心操作：</p><ol><li><strong>Find(x)</strong>：查找元素 <code>x</code> 所属的集合（返回它的代表元素）。</li><li><strong>Union(x, y)</strong>：合并 <code>x</code> 和 <code>y</code> 所在的两个集合。</li></ol><p>核心思想：</p><ul><li><strong>每个集合用一棵树表示</strong>，树的根节点作为该集合的<strong>代表元</strong>（代表元素）。</li><li><strong>Find(x)</strong> 操作用于查找 <code>x</code> 所在集合的代表元（根节点）。</li><li><strong>Union(x, y)</strong> 操作用于合并两个集合，<strong>将其中一个集合的根节点指向另一个集合的根</strong>。</li></ul><h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><p>Dijkstra的前提：<strong>无负权图（源点到第一层点的权重可为负值），避免负圈。</strong></p><p>Dijkstra的基本思路：</p><ol><li>初始化：</li></ol><ul><li>设 <code>dist[s] = 0</code>（起点到自身的距离为 0），其他所有点 <code>dist[v] = ∞</code>（起始时认为未知）。</li><li>用一个**优先队列（最小堆）**维护当前已发现的最短距离点。</li></ul><ol start="2"><li>贪心扩展：</li></ol><ul><li>每次从<strong>未访问的节点中选取当前 <code>dist[v]</code> 最小的点 <code>u</code></strong>。</li><li>遍历 u的所有邻居 v，尝试松弛：<ul><li><strong>如果 <code>dist[u] + w(u, v) &lt; dist[v]</code>，更新 <code>dist[v]</code></strong>，并将 <code>v</code> 加入优先队列。</li></ul></li></ul><ol start="3"><li>终止：所有节点均已访问，或优先队列为空（所有可达点已确定最短路径）。</li></ol><p>Dijkstra的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Dijkstra(Graph, start):<br>    初始化 dist[]，所有点设为 ∞，dist[start] = 0<br>    初始化优先队列 PQ，插入 (0, start)  // (当前最短距离, 顶点)<br>    初始化 visited[] 记录已确定最短路径的点<br><br>    WHILE PQ 不为空:<br>        (d, u) = PQ.Pop()  // 取出当前最短距离的点<br>        IF u 已访问:<br>            CONTINUE<br>        标记 u 为已访问<br><br>        FOR each 邻居 (v, weight) of u:<br>            IF dist[u] + weight &lt; dist[v]:  // 进行松弛操作<br>                dist[v] = dist[u] + weight<br>                PQ.Push((dist[v], v))  // 将 v 加入优先队列<br>    <br>    RETURN dist[]<br></code></pre></td></tr></table></figure><h2 id="循环桶"><a href="#循环桶" class="headerlink" title="循环桶"></a>循环桶</h2><p><strong>桶（Bucket）</strong> 是一种数据存储和分类的方法，可以根据某种规则（如哈希值、时间、范围等）<strong>将数据映射到不同的桶中</strong>，以加快查询、存储或计算的效率。</p><p>循环桶将数据按照一定规则分配到有限个桶（Bucket）中，并循环使用这些桶。</p><h3 id="循环桶的核心特点"><a href="#循环桶的核心特点" class="headerlink" title="循环桶的核心特点"></a>循环桶的核心特点</h3><ol><li>固定数量的桶（N 个）：<ul><li>设定 <code>N</code> 个桶，编号从 <code>0</code> 到 <code>N-1</code>，它们按照顺序<strong>排列成一个循环结构</strong>。</li><li>访问时<strong>基于取模（modulo）运算</strong>，保证访问永远落在 <code>0 ~ N-1</code> 之间。</li></ul></li><li>循环访问（Modulo 取模）：<ul><li>计算索引 <code>index = (当前时间 t) % N</code>，从而使得时间到了 <code>N</code> 之后会回到 <code>0</code>，形成循环管理。</li></ul></li></ol><h3 id="用循环桶实现Dijkstra算法："><a href="#用循环桶实现Dijkstra算法：" class="headerlink" title="用循环桶实现Dijkstra算法："></a>用循环桶实现Dijkstra算法：</h3><p><strong>CLAIM</strong>：Dijkstra算法中最多只需要C+1个桶。</p><ul><li>永久标记的顶点和非边界顶点不在桶中。</li><li>边界点的距离标记不会超过A[i]+C（i为当前标记点）</li><li>顶点x的桶的编号：A[x]mod(C+1)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Dijkstra_CircularBucket(Graph, start):<br>    初始化 dist[]，所有点设为 ∞，dist[start] = 0<br>    初始化桶 Bucket[]，桶的数量为 C+1，存储每个距离区间的节点<br>    初始化 visited[]，记录顶点是否已被永久标记<br>    <br>    将起点 start 放入 Bucket[0] 中（dist[start] = 0）<br>    <br>    WHILE 有节点未被永久标记:<br>        从桶中找出具有最小距离的非永久标记的边界点 u<br>        标记 u 为永久标记，并从桶中移除 u<br>        <br>        FOR 每个邻居 v of u:<br>            IF v 没有被永久标记:<br>                IF dist[u] + w(u, v) &lt; dist[v]:<br>                    dist[v] = dist[u] + w(u, v)  // 松弛操作<br>                    将 v 放入 Bucket[dist[v] mod (C + 1)] 中  // 根据 dist[v] 放入桶<br>                    更新 v 的距离标记<br><br>    RETURN dist[]<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：O(m+nC)</p><h2 id="Dijsktra算法扩展"><a href="#Dijsktra算法扩展" class="headerlink" title="Dijsktra算法扩展"></a>Dijsktra算法扩展</h2><h3 id="单源单宿最短路问题"><a href="#单源单宿最短路问题" class="headerlink" title="单源单宿最短路问题"></a>单源单宿最短路问题</h3><p>问题描述：给定图G，给定顶点s和d，求从s到d的最小权重路径。</p><p>解决方式：增加一个判断分支，d被永久标记时终止循环。</p><p>1111111111111111</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法与分治&quot;&gt;&lt;a href=&quot;#算法与分治&quot; class=&quot;headerlink&quot; title=&quot;算法与分治&quot;&gt;&lt;/a&gt;算法与分治&lt;/h1&gt;&lt;p&gt;Divide and Conquer（DC）&lt;/p&gt;
&lt;p&gt;Divide：将源问题分解为规模较小的子问题，&lt;stro</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
