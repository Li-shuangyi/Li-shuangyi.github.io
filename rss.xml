<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ether Blog</title>
  
  <subtitle>Welcome to Ether Blog !!!</subtitle>
  <link href="http://example.com/rss.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-05-21T18:09:31.108Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Li-shuangyi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>课程设计_背单词软件调试记录</title>
    <link href="http://example.com/2025/05/22/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1_%E8%83%8C%E5%8D%95%E8%AF%8D%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2025/05/22/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1_%E8%83%8C%E5%8D%95%E8%AF%8D%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</id>
    <published>2025-05-21T18:05:19.000Z</published>
    <updated>2025-05-21T18:09:31.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h1><h2 id="5-21测试记录"><a href="#5-21测试记录" class="headerlink" title="5.21测试记录"></a>5.21测试记录</h2><p>目前采用静态网页进行可视化</p><ol><li>用户登录未测试,现在根据用户名区分不同用户,密码不管是什么都能登录</li><li>增加home界面,在该页面可选择词书,查询单词,选择学习&#x2F;复习,复习下选择释义测试&#x2F;拼写测试</li><li>查询单词后可选择标记</li><li>个人中心中增加我的数据&#x2F;学习进度.我的数据子菜单下可展开每个掌握度的单词</li><li>将不同词书隔离,不同词书学习进度独立,学习的单词独立</li><li>在Learning界面中乱序展示所有单词,可进行标记</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;调试记录&quot;&gt;&lt;a href=&quot;#调试记录&quot; class=&quot;headerlink&quot; title=&quot;调试记录&quot;&gt;&lt;/a&gt;调试记录&lt;/h1&gt;&lt;h2 id=&quot;5-21测试记录&quot;&gt;&lt;a href=&quot;#5-21测试记录&quot; class=&quot;headerlink&quot; title=&quot;5</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Path_planning_learning</title>
    <link href="http://example.com/2025/04/06/Path-planning-learning/"/>
    <id>http://example.com/2025/04/06/Path-planning-learning/</id>
    <published>2025-04-06T10:04:20.000Z</published>
    <updated>2025-05-18T16:26:24.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h1><h2 id="前端-路径寻找"><a href="#前端-路径寻找" class="headerlink" title="前端:路径寻找"></a>前端:路径寻找</h2><h3 id="基于搜索"><a href="#基于搜索" class="headerlink" title="基于搜索"></a>基于搜索</h3><ul><li>图搜索基础</li><li>Dijkstra and A*</li><li>Jump Point Search</li></ul><h3 id="基于采样"><a href="#基于采样" class="headerlink" title="基于采样"></a>基于采样</h3><ul><li>Probabilstic Road Map</li><li>RRT</li><li>RRT* &#x2F; Informed RRT</li></ul><h3 id="基于运动学动态路径寻找"><a href="#基于运动学动态路径寻找" class="headerlink" title="基于运动学动态路径寻找"></a>基于运动学动态路径寻找</h3><ul><li>State-state Boundary Value Optimal Control Problem</li><li>State Lattic Search</li><li>Kinodynamic RRT*</li><li>Hybrid A*</li></ul><h2 id="后端-轨迹生成"><a href="#后端-轨迹生成" class="headerlink" title="后端:轨迹生成"></a>后端:轨迹生成</h2><h3 id="MINIMUN-SNAP-TRAJECTORY-GENERATION"><a href="#MINIMUN-SNAP-TRAJECTORY-GENERATION" class="headerlink" title="MINIMUN SNAP TRAJECTORY GENERATION"></a>MINIMUN SNAP TRAJECTORY GENERATION</h3><h3 id="SOFT-AND-HARD-CONSTRAINED-TRAJECTORY-OPTIMIZATION"><a href="#SOFT-AND-HARD-CONSTRAINED-TRAJECTORY-OPTIMIZATION" class="headerlink" title="SOFT AND HARD CONSTRAINED TRAJECTORY OPTIMIZATION"></a>SOFT AND HARD CONSTRAINED TRAJECTORY OPTIMIZATION</h3><h1 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h1><h2 id="Occupancy-grid-map"><a href="#Occupancy-grid-map" class="headerlink" title="Occupancy grid map"></a>Occupancy grid map</h2><p>github:<a href="https://github.com/ANYbotics/grid_map">https://github.com/ANYbotics/grid_map</a></p><ul><li>排列紧密</li><li>结构化</li><li>索引队列访问</li></ul><p>缺点:当切分过于细密时空间占用率大.</p><h2 id="Octo-map"><a href="#Octo-map" class="headerlink" title="Octo-map"></a>Octo-map</h2><p>github:<a href="https://github.com/OctoMap/octomap_mapping">https://github.com/OctoMap/octomap_mapping</a></p><p>地图中大部分为稀疏部分,使用八叉树的数据结构储存.如果一个区块没有障碍物,不再细分该区块;如果一个区块有障碍物则细分至最小包含该障碍物的区块.</p><p><strong>Octree</strong></p><p>八叉树（Octree）是一种用于描述三维空间的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，将八个子节点所表示的体积元素加在一起就等于父节点的体积。八叉树是四叉树在三维空间上的扩展，二维上我们有四个象限，而三维上，我们有8个卦限。八叉树主要用于空间划分和最近邻搜索。</p><p>实现Octree的原理:</p><ul><li>将当前的立方体细分为八个子立方体。</li><li>如果任何一个子立方体内包含多个点，则将其进一步细分为八个子立方体。</li><li>重复以上操作使得每个子立方体内包含最多一个点。</li></ul><p><img src="/images/path_planning_learning/1.png" alt="八叉树1"></p><p><img src="/images/path_planning_learning/2.webp" alt="八叉树2"></p><ul><li>排列稀疏</li><li>结构化</li><li>非直接索引访问(树的查询)</li></ul><h2 id="Voxel-hashing"><a href="#Voxel-hashing" class="headerlink" title="Voxel hashing"></a>Voxel hashing</h2><p>github:<a href="https://github.com/niessner/VoxelHashing">https://github.com/niessner/VoxelHashing</a></p><p>记录存在碰撞的区块 —-&gt; 哈希表,<strong>字典</strong></p><p>一个bucket中划分为更小的voxel blocks</p><p><img src="/images/path_planning_learning/3.png" alt="Voxel"></p><ul><li>排列最稀疏</li><li>结构化</li><li>非直接索引访问(字典查询)</li></ul><h2 id="Point-Cloud-Map"><a href="#Point-Cloud-Map" class="headerlink" title="Point Cloud Map"></a>Point Cloud Map</h2><ul><li>无序</li><li>无法通过索引队列访问(除非自发遍历)</li></ul><h2 id="TSDF-map"><a href="#TSDF-map" class="headerlink" title="TSDF map"></a>TSDF map</h2><p><strong>Truncated Signed Distance Functions (截断&#x2F;有符号&#x2F;距离函数)</strong></p><p>github:</p><p>TSDF 是一种用于表示3D空间表面的体素网格地图.</p><h3 id="Signed-Distance-Function-SDF"><a href="#Signed-Distance-Function-SDF" class="headerlink" title="Signed Distance Function (SDF)"></a>Signed Distance Function (SDF)</h3><p>对于空间中任意一点 x，SDF 给出它到最近表面的距离 d：<br>$$<br>SDF(x)&#x3D;±d<br>$$</p><ul><li>+d：点在<strong>表面外部</strong>（通常指相机方向）</li><li>−d：点在<strong>表面内部</strong></li><li>d&#x3D;0：点在表面上（即零交叉点）</li></ul><h3 id="Truncated-SDF（TSDF）"><a href="#Truncated-SDF（TSDF）" class="headerlink" title="Truncated SDF（TSDF）"></a>Truncated SDF（TSDF）</h3><p>真实计算中远离表面部分的距离信息不重要且不准确，因此会进行截断：</p><ul><li>若 ∣d∣&gt; μ，则 TSDF 值为截断值。</li><li>μ 是截断距离阈值（truncation distance）。</li></ul><h3 id="Voxel-Grid（体素网格）"><a href="#Voxel-Grid（体素网格）" class="headerlink" title="Voxel Grid（体素网格）"></a>Voxel Grid（体素网格）</h3><p>TSDF 存在于一个 3D 网格中（类似立方体像素）：</p><ul><li>每个体素（voxel）存储：<ul><li>当前体素的 TSDF 值</li><li>加权平均值（来自多个观测帧）</li><li>权重（用于融合多个观测）</li></ul></li></ul><p><img src="/images/path_planning_learning/4.png" alt="TSDF1"></p><p><img src="/images/path_planning_learning/5.png" alt="TSDF2"></p><h2 id="ESDF-Map"><a href="#ESDF-Map" class="headerlink" title="ESDF Map"></a>ESDF Map</h2><p><strong>Euclidean Signed Distance Field 欧几里得有符号距离场</strong></p><p>以 3D 网格（体素）的形式表示环境中每一点<strong>到障碍物最近点的欧几里得距离</strong>，并附带符号来表示点位于障碍物内部或外部。局部ESDF地图:只记忆感兴趣部分的ESDF值.</p><p><img src="/images/path_planning_learning/6.png" alt="ESDF1"></p><p><img src="/images/path_planning_learning/7.png" alt="ESDF2"></p><h2 id="Free-space-Roadmap"><a href="#Free-space-Roadmap" class="headerlink" title="Free-space Roadmap"></a>Free-space Roadmap</h2><p>概率路线图 —-&gt; 安全通行区域,使用<strong>凸多边体</strong>表示</p><p>得到的是一个宽阔的解空间</p><h2 id="Voronoi-Diagram-Map"><a href="#Voronoi-Diagram-Map" class="headerlink" title="Voronoi Diagram Map"></a>Voronoi Diagram Map</h2><p>高效利用ESDF提取地图骨架 —-&gt; 稀疏</p><h1 id="基于搜索的路径寻找"><a href="#基于搜索的路径寻找" class="headerlink" title="基于搜索的路径寻找"></a>基于搜索的路径寻找</h1><h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><p>A*算法在Dijkstra算法的基础上引入了启发函数(贪心思想)，启发函数是对当前节点到目标节点所需代价的预估.启发式函数一般使用曼哈顿距离、欧几里德距离。</p><blockquote><ol><li><p>从起点开始，将其加入待探索的节点集合（open set）。</p></li><li><p>每次选择 f 值最小的节点进行扩展，其中 <code>f(n) = g(n) + h(n)</code></p></li></ol><ul><li><code>g(n)</code> 是从起点到当前节点的实际代价</li><li><code>h(n)</code> 是从当前节点到终点的启发式估计（如直线距离）</li></ul><ol start="3"><li><p>对当前节点的所有相邻节点，计算新的 g 值，更新路径记录。</p></li><li><p>如果发现更优路径（g 值更小），则更新该邻居的记录，并加入 open set。</p></li><li><p>重复以上步骤，直到终点被选中扩展，表示找到最短路径。</p></li><li><p>通过路径记录表回溯，重建从起点到终点的完整路径。</p></li></ol></blockquote><p>伪代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">• 维护一个优先级队列来存储所有待扩容节点<br>• 所有节点的启发式函数<span class="hljs-built_in">h</span>(n)是预定义的<br>• 优先级队列初始化为起始状态 X S<br>• 对图中所有其他节点赋值<span class="hljs-built_in">g</span>(X S) = <span class="hljs-number">0</span>, <span class="hljs-built_in">g</span>(n) = infinite<br>• Loop<br>    •如果队列为空，则返回FALSE；BREAK;<br>    •从优先级队列中删除<span class="hljs-built_in">f</span>(n)=<span class="hljs-built_in">g</span>(n)+<span class="hljs-built_in">h</span>(n)最小的节点“n”<br>    •将节点“n”标记为展开<br>    •如果节点“n”是目标状态，返回TRUE；BREAK;<br>    •对于节点n的所有未展开的邻居 m<br>•<span class="hljs-function">If <span class="hljs-title">g</span><span class="hljs-params">(m)</span> </span>= infinite<br>• <span class="hljs-built_in">g</span>(m)= <span class="hljs-built_in">g</span>(n) + Cnm<br>    •对于节点n的所有未展开的邻居 m<br>•If <span class="hljs-built_in">g</span>(m) = infinite<br>• <span class="hljs-built_in">g</span>(m)= <span class="hljs-built_in">g</span>(n) + Cnm<br>• Push node “m” into the queue<br>•If <span class="hljs-built_in">g</span>(m) &gt; <span class="hljs-built_in">g</span>(n) + C nm<br>•<span class="hljs-built_in">g</span>(m)= <span class="hljs-built_in">g</span>(n) + Cnm<br>•end<br>• End Loop<br></code></pre></td></tr></table></figure><h3 id="Weighted-A-Search"><a href="#Weighted-A-Search" class="headerlink" title="Weighted A* Search"></a>Weighted A* Search</h3><p>Sub-Optimal Solution</p><p>通过人为加大启发函数的影响力来获得更快的搜索速度，以牺牲路径最优性为代价。</p><p>f &#x3D; g + εh, ε &gt; 1 &#x3D;bias towards states that are closer to goal.</p><p><img src="/images/path_planning_learning/8.png" alt="Weighted_A*_Search"></p><ul><li><p>Most Greedy（最贪婪）</p></li><li><p>参数：a&#x3D;0,b&#x3D;1</p></li><li><p>只考虑启发式代价，完全不考虑当前路径代价</p></li><li><p>结果：趋向于直接朝目标点移动，但路径不一定最短或最优</p></li></ul><hr><ul><li><p>Tunable Greediness（可调贪婪度）</p></li><li><p>参数：a&#x3D;1,b&#x3D;ε&gt;1</p></li><li><p>综合考虑当前路径和启发式估计，但偏向启发式</p></li><li><p>结果：平衡探索性和效率，路径更合理</p></li></ul><hr><ul><li><p>Optimal（最优路径）</p></li><li><p>参数：a&#x3D;1,b&#x3D;1</p></li><li><p>平等考虑已知路径和启发估计</p></li><li><p>结果：找到最优路径</p></li></ul><hr><ul><li><p>Dijkstra算法</p></li><li><p>参数：a&#x3D;1,b&#x3D;0</p></li><li><p>完全不使用启发式，只靠实际代价 g,效率低</p></li></ul><h3 id="A-的实施流程"><a href="#A-的实施流程" class="headerlink" title="A*的实施流程"></a>A*的实施流程</h3><ol><li><p>建立地图 → 生成网格节点数组</p></li><li><p>设定障碍 → 标记不可达节点</p></li><li><p>编写邻居搜索函数</p></li><li><p>编写A*主循环：</p><ul><li><p>从openList中取出f值最小的节点</p></li><li><p>计算邻居的g&#x2F;h&#x2F;f值，加入openList</p></li><li><p>更新已访问节点（closedList）</p></li></ul></li><li><p>使用<code>priority_queue</code>或<code>multimap</code>优化性能</p></li></ol><h3 id="最好的启发函数"><a href="#最好的启发函数" class="headerlink" title="最好的启发函数"></a><strong>最好的启发函数</strong></h3><p><strong>最好:tight</strong>,正确的最短距离函数</p><blockquote><p>二维最佳启发函数:<br>$$<br>h2D​&#x3D;(dx+dy)+(2<br>​−2)⋅min(dx,dy)<br>$$<br>三维最佳启发函数:</p><p>我们记 dx,dy,dz为三维网格中当前点与目标点在三个轴上的距离（均为非负整数），有：<br>$$<br>h3D&#x3D;dmin⋅3+(dmid−dmin)⋅2+(dmax−dmid)⋅1<br>$$<br>其中：dmin,dmid,dmax是 dx,dy,dzdx,dy,dz 的排序结果，使得</p><p>$$<br>dmin≤dmid≤dmax<br>$$</p></blockquote><h3 id="Tie-Breaker"><a href="#Tie-Breaker" class="headerlink" title="Tie Breaker"></a>Tie Breaker</h3><p>平局处理器,打破 f 值相等时的探索顺序</p><ul><li>问题:</li></ul><p>​A* 会选取 f 值最小的节点扩展（f&#x3D;g+h）</p><p>​但在一些情形下，很多节点的 f 值完全相等,尤其是在网格图中启发函数不够 tight 的时候</p><p>​导致算法要探索很多不必要的节点，降低效率</p><blockquote><ul><li><strong>解决方法:</strong></li></ul><ol><li>人为干扰 h，让 f 值不同:</li></ol><p>  将原来的启发函数 h乘上一个微小因子：<br>$$<br>  h&#x3D;h×(1.0+p)<br>$$<br>  其中：<br>$$<br>  p &lt; \frac{\text{最小步长代价}}{\text{预期路径总长度}}<br>$$<br>  这样能 <strong>轻微打破平局</strong>，减少无效扩展</p><p>  代价是轻微地破坏启发式的“可采纳性”（admissibility），但常常实际无影响或带来更好效率.</p><ol start="2"><li>优先选 h值小的节点</li></ol><p>  如果两个节点 f 一样，选择 h 小的那个（靠近终点）</p><ol start="3"><li>加入伪随机干扰项（Deterministic random）</li></ol><ul><li>给每个节点加一个唯一扰动，保持一致性但不完全对称</li></ul><ol start="4"><li>优先靠近起点-终点连线的路径</li></ol><p>$$<br>cross&#x3D;∣dx1×dy2−dx2×dy1∣<br>$$</p><p><strong>这其实是在衡量点偏离直线的“面积”，越小越靠近理想路径。</strong></p></blockquote><h2 id="Jump-Point-Search"><a href="#Jump-Point-Search" class="headerlink" title="Jump Point Search"></a>Jump Point Search</h2><p>核心思想:<strong>在两点之间没有障碍物时，中间的节点不考虑,只考虑重要节点.</strong></p><ol><li>邻居修剪 Neighbor Pruning</li></ol><ul><li><p>灰色节点：较差的邻居，当去到它们时，没有分值的路径更便宜。丢弃。</p></li><li><p>白色节点：自然邻居。</p></li></ul><p>​只需要考虑<strong>自然邻居</strong>.</p><p><img src="/images/path_planning_learning/9.png" alt="Neighbor Pruning"></p><ol start="2"><li>强迫邻居 Forced Neighbors</li></ol><p>节点X的邻居节点有障碍物，且X的父节点P经过X到达N的距离代价，比不经过X到大N的任一路径的距离代价都小，则称N是X的强迫邻居。</p><ul><li><p>有相邻的障碍</p></li><li><p>红色节点是强制邻居。</p></li><li><p>一条从父母到他们通过障碍的更便宜的路径被阻断。</p></li></ul><p><img src="/images/path_planning_learning/10.png" alt="Forced Neighbors"></p><ol start="3"><li>跳点(Jump Point)：什么样的节点可以作为跳点<br> (1)节点 A 是起点、终点.<br> (2)节点A 至少有一个强迫邻居.<br> (3)父节点在斜方向(斜向搜索)，节点A的水平或者垂直方向上有满足 (1)、(2) 的节点</li></ol><p><img src="/images/path_planning_learning/11.png" alt="Jump Point"></p><p>跳点搜索中，会递归地检查路径上的邻居节点是否是“跳点”。在检查对角线方向前，会优先尝试直线方向。只要某个节点通往某些邻居的最短路径必须经过它，它就会被标记为跳点。同时，对“强制邻居”不能剪枝，必须展开。</p><h1 id="基于采样的路径寻找"><a href="#基于采样的路径寻找" class="headerlink" title="基于采样的路径寻找"></a>基于采样的路径寻找</h1><h2 id="Probabilistic-Road-Map"><a href="#Probabilistic-Road-Map" class="headerlink" title="Probabilistic Road Map"></a>Probabilistic Road Map</h2><p>图结构</p><p>将规划分为两个阶段：<br>·学习阶段<br>·查询阶段</p><p>检查采样配置和连接的样本之间的碰撞可以有效率地完成任务。<br>数量相对较少的里程碑和局部路径足以捕获的连通性。</p><ul><li>限制路径点连接的长度避免图结构过于复杂</li></ul><h3 id="学习阶段"><a href="#学习阶段" class="headerlink" title="学习阶段:"></a>学习阶段:</h3><ul><li>在c空间中采样N个点</li><li>删除碰撞点</li></ul><p><img src="/images/path_planning_learning/12.png" alt="PRM-Learning1"></p><ul><li>连接到最近的点，并获得无碰撞段。</li><li>删除碰撞段</li></ul><p><img src="/images/path_planning_learning/13.png" alt="PRM-Learning2"></p><h3 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段:"></a>查询阶段:</h3><ul><li>在路线图上搜索，找到从起点到终点的路径目标（使用Dijkstra算法或A*算法）。</li><li>路线图现在类似于网格地图</li></ul><p><img src="/images/path_planning_learning/14.png" alt="PRM-Query"></p><p> 优点</p><ul><li>概率完备</li></ul><p>缺点</p><ul><li><p>要求解决两点边值问题</p></li><li><p>在状态空间上构建图，但不特别关注生成路径</p></li><li><p>效率不高</p></li></ul><h3 id="Lazy-collision-checking"><a href="#Lazy-collision-checking" class="headerlink" title="Lazy collision-checking"></a>Lazy collision-checking</h3><p><strong>效率低</strong>: PRM（Probabilistic Roadmap）或 RRT（Rapidly-exploring Random Tree) 需要频繁地检查从一个配置到另一个配置（或状态）之间的路径是否与障碍物发生碰撞。但碰撞检测是一个昂贵的计算操作，尤其在高维空间或复杂环境中，频繁的碰撞检测会成为性能瓶颈。</p><ul><li>不考虑采样点和生成分段碰撞（懒惰）</li></ul><p>先构建图（PRM）或树（RRT）时不立即检查碰撞，等到真正要使用这条路径时（例如在查询最短路径、或者将路径从树&#x2F;图中提取出来时），再执行碰撞检测。</p><h4 id="PRM-Lazy-collision-checking"><a href="#PRM-Lazy-collision-checking" class="headerlink" title="PRM+Lazy collision-checking"></a><strong>PRM+Lazy collision-checking</strong></h4><ol><li><p>构建 roadmap：采样节点、连接边，不做碰撞检测。</p></li><li><p>查询路径：使用 A* 或 Dijkstra 等算法找到一条从起点到终点的路径。</p></li><li><p>在该路径上进行逐段碰撞检测：</p><ul><li><p>如果全部无碰撞，路径有效；</p></li><li><p>如果某段有碰撞，将该边标记为无效（不可达），从图中删除，重新搜索。</p></li></ul></li></ol><p><img src="/images/path_planning_learning/15.png" alt="Lazy collision-checking"></p><h2 id="Rapidly-exploring-Random-Tree"><a href="#Rapidly-exploring-Random-Tree" class="headerlink" title="Rapidly-exploring Random Tree"></a>Rapidly-exploring Random Tree</h2><p><strong>核心思想:</strong></p><blockquote><p>通过生成next构建树状态在树中通过执行随机控制,从起点开始，不断向随机方向扩展一棵树，迅速探索整个状态空间。</p></blockquote><p>伪代码:</p><p><img src="/images/path_planning_learning/16.png" alt="RRT伪代码"></p><ul><li>初始化一棵树 <code>T</code>，将起始点 <code>X_init</code> 作为树的根节点。</li><li>循环:</li><li>在整个状态空间中随机采样一个点 <code>X_rand</code>，用于探索新方向。</li><li>找出树 <code>T</code> 中距离 <code>X_rand</code> 最近的已有节点 <code>X_nearest</code>。</li><li>从 <code>X_nearest</code> 朝 <code>q_rand</code> 方向延伸一个固定步长delta，生成新点 <code>X_new</code>。</li></ul><p>如果新点 <code>X_new</code> 是可行的（比如不与障碍物碰撞），则执行以下操作:</p><ul><li>把这个新点 <code>X_new</code> 加入树中，作为新的节点。</li><li>在树中添加一条从 <code>X_nearest</code> 到 <code>X_new</code> 的路径边。</li><li>返回整个搜索生成的树 <code>T</code>，它包含从起点开始探索出来的路径结构。</li></ul><p>**提前停止的条件：**因为每一段树枝的末端都是Xnew，所以每产生一次Xnew节点，我们都判断一下Xnew与终点之间的距离，看这个距离是否小于步长，如果小于步长且没有经过障碍物，则就直接把Xnew与终点进行相连。</p><blockquote><p>优点:<br>·旨在找到从起点到目标的路径<br>·比PRM更有针对性<br>缺点:<br>·非最优解<br>·效率不高,在 <strong>narrow环境</strong> 中效率低<br>·整个空间取样</p></blockquote><h3 id="KD树"><a href="#KD树" class="headerlink" title="KD树"></a>KD树</h3><p> Kd-Tree，即K-dimensional  tree，是一棵二叉树，树中存储的是一些K维数据。在一个K维数据集合上构建一棵Kd-Tree代表了对该K维数据集合构成的K维空间的一个划分，即树中的每个结点就对应了一个K维的超矩形区域（Hyperrectangle）。</p><p>关键术语:</p><ul><li>维度（K）：表示数据点所在的空间维数。例如，二维空间中的点有x和y坐标，三维空间中的点有x、y、z坐标。</li><li>节点：KD树的每个节点包含一个K维点及其分割超平面的信息。</li><li>超平面：在K维空间中用于将空间划分为两个部分的（K-1）维子空间。例如，二维空间中的超平面是直线，三维空间中的超平面是平面。</li></ul><p>构建步骤:</p><ol><li><p>输入数据：假设有N个K维数据点。</p></li><li><p>选择分割维度：按照循环顺序选择当前维度。例如，第一个维度（x轴）用于根节点，第二个维度（y轴）用于其子节点，依此类推。</p></li><li><p>选择分割值：在当前分割维度上找到<strong>中位数</strong>点，将其作为当前节点。</p></li><li><p>划分数据：</p><ul><li><p>左子集：所有在当前分割维度上小于中位数点的点。</p></li><li><p>右子集：所有在当前分割维度上大于中位数点的点。</p></li></ul></li><li><p>递归构建子树：对左子集和右子集重复上述步骤，直到所有点都被包含在树中。</p></li><li><p>终止条件：当某一子集为空时，递归终止。</p></li></ol><p><img src="/images/path_planning_learning/17.png" alt="一个创建KD树的例子"></p><p>使用KD树提高<strong>路径规划</strong>效率</p><h3 id="Bidirectional-RRT-RRT-Connect-双向快速扩展随机树"><a href="#Bidirectional-RRT-RRT-Connect-双向快速扩展随机树" class="headerlink" title="Bidirectional RRT &#x2F; RRT-Connect 双向快速扩展随机树"></a>Bidirectional RRT &#x2F; RRT-Connect 双向快速扩展随机树</h3><blockquote><ol><li>初始化两棵树：T_start 以 q_start 为根，T_goal 以 q_goal 为根。</li><li>重复以下过程直到路径找到或迭代上限：<br>a. 从状态空间中采样一个随机点 q_rand。<br>b. 使用 Extend 操作从 T_start 向 q_rand 延伸，得到 q_new。<br>c. 如果扩展成功：<br>i. 使用 Connect 操作让 T_goal 向 q_new 不断扩展，直到无法前进。<br>ii. 如果两个树在某个点连接，则路径找到。<br>d. 交换 T_start 和 T_goal。</li></ol></blockquote><table><thead><tr><th align="center">项目</th><th align="center">单向 RRT</th><th align="center">双向 RRT（RRT-Connect）</th></tr></thead><tbody><tr><td align="center">扩展方向</td><td align="center">只从起点扩展</td><td align="center">起点和终点同时扩展</td></tr><tr><td align="center">搜索速度</td><td align="center">较慢</td><td align="center">更快，更高效</td></tr><tr><td align="center">成功率</td><td align="center">容易陷入复杂障碍</td><td align="center">双向推进更容易绕障碍</td></tr><tr><td align="center">路径质量</td><td align="center">一般</td><td align="center">更好</td></tr><tr><td align="center">复杂性</td><td align="center">低</td><td align="center">高</td></tr></tbody></table><h2 id="Optimal-sampling-based-path-planning-methods"><a href="#Optimal-sampling-based-path-planning-methods" class="headerlink" title="Optimal sampling-based path planning methods"></a>Optimal sampling-based path planning methods</h2><p>在传统采样方法（如 RRT、PRM）的基础上，进一步加入了<strong>路径最优性保证</strong>的算法。最经典的代表是 <strong>RRT</strong>*</p><h3 id="RRT"><a href="#RRT" class="headerlink" title="RRT*"></a>RRT*</h3><p><img src="/images/path_planning_learning/18.png" alt="RRT*伪代码"></p><p><strong>Choose Best Parent</strong>：在新节点周围半径内的已有节点中，选择一条“代价最小”的路径作为父节点；</p><p><strong>Rewire</strong>：反过来看新节点是否能以更小的代价更新周围节点的父节点。</p><h3 id="Kinodynamic-RRT"><a href="#Kinodynamic-RRT" class="headerlink" title="Kinodynamic-RRT*"></a>Kinodynamic-RRT*</h3><p>更改Steer（）函数以适应机器人的运动或其他限制导航(曲线)</p><h2 id="Advanced-Sampling-based-Methods"><a href="#Advanced-Sampling-based-Methods" class="headerlink" title="Advanced Sampling-based Methods"></a>Advanced Sampling-based Methods</h2><h3 id="Inform-RRT"><a href="#Inform-RRT" class="headerlink" title="Inform RRT*"></a>Inform RRT*</h3><p>一旦找到一条路径，其代价为 <code>c_best</code>，就只在以下区域采样：</p><blockquote><p><strong>从起点 <code>q_start</code> 到终点 <code>q_goal</code> 的椭球体区域（Ellipsoidal Sampling Space）</strong><br> 半长轴为 <code>c_best/2</code>，焦点为起点与终点，构成一个最短路径所有可能穿过的区域。</p></blockquote><p><img src="/images/path_planning_learning/18.png" alt="Inform RRT*"></p><h3 id="Cross-entropy-motion-planning"><a href="#Cross-entropy-motion-planning" class="headerlink" title="Cross-entropy motion planning"></a>Cross-entropy motion planning</h3><ol><li><p><strong>初始化一个轨迹分布模型</strong></p><ul><li><p>比如用高斯分布建模一条轨迹（多个中间点组成）</p></li><li><p>初始均值：可能是直线路径，初始方差大</p></li></ul></li><li><p><strong>采样多个轨迹</strong></p><p>每条轨迹是从当前分布中采样得到的一个完整路径（可加速度约束等）</p></li><li><p><strong>评估轨迹代价</strong>:碰撞检测、路径长度、平滑性、目标接近度等</p></li><li><p><strong>选取表现最好的轨迹（Top-k）</strong>:选出“精英轨迹”，即代价最小的那一部分</p></li><li><p>**用精英轨迹更新分布参数:**更新高斯均值和协方差，使下次采样更集中于好路径附近</p></li><li><p><strong>迭代</strong>:重复 2-5，直到满足终止条件（如达到最小代价、收敛、超时等）</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OverView&quot;&gt;&lt;a href=&quot;#OverView&quot; class=&quot;headerlink&quot; title=&quot;OverView&quot;&gt;&lt;/a&gt;OverView&lt;/h1&gt;&lt;h2 id=&quot;前端-路径寻找&quot;&gt;&lt;a href=&quot;#前端-路径寻找&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>接入网综合课设</title>
    <link href="http://example.com/2025/03/10/%E6%8E%A5%E5%85%A5%E7%BD%91%E8%AF%BE%E8%AE%BE/"/>
    <id>http://example.com/2025/03/10/%E6%8E%A5%E5%85%A5%E7%BD%91%E8%AF%BE%E8%AE%BE/</id>
    <published>2025-03-10T02:25:26.000Z</published>
    <updated>2025-04-03T06:36:47.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接入网综合课设"><a href="#接入网综合课设" class="headerlink" title="接入网综合课设"></a>接入网综合课设</h1><h2 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h2><ol><li><p>完成虚拟机选型，并配置至少两个网段， 分别测试子网内和子网间连通性； </p></li><li><p>设计PPPOE本地认证拓扑图及IP地址规划 (客户至少两个网段)  ；</p></li><li><p>选型PPPOE服务器软件，并在虚拟环境下 完成PPPoE接入本地认证的搭建、配置、 实验测试。</p></li></ol><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><h4 id="子网规划"><a href="#子网规划" class="headerlink" title="子网规划"></a>子网规划</h4><p>虚拟机选型：ubuntu20.04</p><p>配置网段：</p><ul><li>Vmnet1:192.168.10.0&#x2F;24</li><li>Vmnet2:192.168.20.0&#x2F;24 </li><li>Vmnet3:192.168.30.0&#x2F;24</li></ul><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/1.png" alt="子网规划"></p><h4 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h4><ol><li>在ubuntu编辑-虚拟网络编辑器中选择更改设置，赋予管理员权限后选择添加网络，类型为<strong>仅主机模式</strong>，修改子网IP和子网掩码。</li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/2.png" alt="虚拟网络编辑器"></p><ol start="2"><li>在ubuntu虚拟机设置中添加网卡，三张为子网规划中定义所对应的网卡。</li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/3.png" alt="虚拟机设置"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/4.png" alt="硬件设置"></p><p>对应网络适配器选择自定义-特定虚拟网络-选择对应网卡-确定。</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/5.png" alt="虚拟机设置"></p><ol start="3"><li>在ubuntu中输入</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><p>出现对应网卡信息。</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/6.png" alt="网卡信息"></p><ol start="4"><li>配置静态IP。参考博客：<a href="https://blog.csdn.net/weixin_58305495/article/details/130554393">Ubuntu配置静态IP</a>，注意与网卡名称匹配。</li></ol><p><strong>Ubuntu 16.04 及更早版本</strong>：网络管理工具使用 <code>ifupdown</code>，网络配置文件在 <code>/etc/network/interfaces</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">auto lo<br>iface lo inet loopback<br><br>auto eth0<br>iface eth0 inet dhcp<br><br>auto eth1<br>iface eth1 inet static<br>address 192.168.10.10<br>netmask 255.255.255.0<br>gateway 192.168.10.1<br>dns-nameservers 8.8.8.8 8.8.4.4<br><br>auto eth2<br>iface eth2 inet static<br>address 192.168.20.10<br>netmask 255.255.255.0<br>gateway 192.168.20.1<br><br>auto eth3<br>iface eth3 inet static<br>address 192.168.30.10<br>netmask 255.255.255.0<br>gateway 192.168.30.1<br><br></code></pre></td></tr></table></figure><p><strong>Ubuntu 17.10 及更高版本</strong>：网络管理工具使用 <code>Netplan</code>，配置文件位于 <code>/etc/netplan/00-installer-config.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Let NetworkManager manage all devices on this system</span><br><span class="hljs-attr">network:</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span><br>  <span class="hljs-attr">ethernets:</span><br>    <span class="hljs-attr">ens33:</span>            <br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span>                          <br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.4</span><span class="hljs-number">.4</span>]       <br><br>    <span class="hljs-attr">ens37:</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.10</span><span class="hljs-string">/24</span>]        <br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span> <span class="hljs-string">default</span><br>          <span class="hljs-attr">via:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.1</span>                <br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">false</span>                          <br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.4</span><span class="hljs-number">.4</span>]      <br><br>    <span class="hljs-attr">ens38:</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.10</span><span class="hljs-string">/24</span>]         <br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span> <span class="hljs-string">default</span><br>          <span class="hljs-attr">via:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.1</span>                <br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">false</span>                          <br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.4</span><span class="hljs-number">.4</span>]   <br><br>    <span class="hljs-attr">ens39:</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.30</span><span class="hljs-number">.10</span><span class="hljs-string">/24</span>]        <br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span> <span class="hljs-string">default</span><br>          <span class="hljs-attr">via:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.30</span><span class="hljs-number">.1</span>              <br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">false</span>                     <br>      <span class="hljs-attr">nameservers:</span><br>        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.4</span><span class="hljs-number">.4</span>]   <br></code></pre></td></tr></table></figure><p>配置完成后执行命令使配置生效。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo netplan apply<br></code></pre></td></tr></table></figure><p>执行<code>ifconfig</code>命令查看当前IP地址。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><strong>子网间连通性</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/7.png" alt="Linux子网间连通性"></p><p>Client1(192.168.10.20)</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/8.png" alt="Client1子网间连通性"></p><p>Client2(192.168.20.20)</p><img src="/images/接入网综合课设/9.png" alt="image-20250308132954522" style="zoom: 80%;" /><p><strong>子网内连通性</strong></p><p>Client1(192.168.10.20)</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/10.png" alt="Client1子网内连通性"></p><p>Client2(192.168.20.20)</p><img src="/images/接入网综合课设/11.png" alt="image-20250308133215681" style="zoom:80%;" /><h3 id="任务三"><a href="#任务三" class="headerlink" title="任务三"></a>任务三</h3><h4 id="PPPoE服务器端"><a href="#PPPoE服务器端" class="headerlink" title="PPPoE服务器端"></a>PPPoE服务器端</h4><p><a href="https://zhuanlan.zhihu.com/p/41499761">参考博客:基于Linux环境的PPPOE服务器搭建</a></p><ol><li>安装PPPoE服务器程序</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get install pppoe<br></code></pre></td></tr></table></figure><p>使用<code>pppoe-server -h</code>查看pppoe安装情况及版本,该PPPoE-Server版本为3.12。</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/12.png" alt="PPPoE服务器版本"></p><ol start="2"><li>编辑&#x2F;etc&#x2F;ppp&#x2F;options文件</li></ol><ul><li>PAP：明文密码认证协议。</li><li>CHAP：挑战握手认证协议，<strong>三次握手</strong>机制，使用哈希加密。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">14+ ms-dns 8.8.8.8<br>57  local<br>144 #+pap  // 关闭pap<br>147 -pap<br>151 +chap  // 开启chap<br>154 #-chap<br>208 proxyarp<br></code></pre></td></tr></table></figure><ol start="3"><li>编辑 pppoe-server-options文件</li></ol><p>创建&#x2F;etc&#x2F;ppp&#x2F;pppoe-server-options文件，使用chap验证协议require-chap，如果使用pap验证协议则配置为 require-pap。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">auth<br>require-chap<br>lcp-echo-interval 60<br>lcp-echo-failure 5     <br>logfile /var/log/pppd.log<br></code></pre></td></tr></table></figure><ol start="3"><li>编辑&#x2F;etc&#x2F;ppp&#x2F;chap-secrets 文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Secrets <span class="hljs-keyword">for</span> authentication using CHAP</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">clientserversecretIP addresses</span><br>test * test *<br></code></pre></td></tr></table></figure><p>用户名为test，密码为test，服务器名和IP地址为任意。</p><ol start="4"><li>开启IP转发功能</li></ol><p>​编辑&#x2F;etc&#x2F;sysctl.conf文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">28 net.ipv4.ip_forward=1<br></code></pre></td></tr></table></figure><p>​运行<code>sudo sysctl -p</code>生效配置。</p><ol start="5"><li>启动PPPoE服务器</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo pppoe-server -I ens37 -L 192.168.10.10 -R 192.168.10.11 -N 20   <br>sudo pppoe-server -I ens38 -L 192.168.20.10 -R 192.168.20.11 -N 20   <br></code></pre></td></tr></table></figure><p><strong>指令含义：</strong></p><table><thead><tr><th>pppoe-server</th><th>启动 PPPoE 服务器进程</th></tr></thead><tbody><tr><td>-I xxx</td><td>监听物理网卡xxx，接受客户端的 PPPoE 拨号请求</td></tr><tr><td>-L IP地址</td><td>PPP 服务器的 IP 地址</td></tr><tr><td>-R IP地址</td><td>客户端分配 IP 的起始地址</td></tr><tr><td>-N n</td><td>最多允许 n 个 PPPoE 客户端同时连接</td></tr></tbody></table><ol start="6"><li>查看PPPoE服务器的启用情况</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ps -ef|grep pppoe<br></code></pre></td></tr></table></figure><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/13.png" alt="pppoe服务器的启用情况"></p><ul><li>如果需要关闭PPPoE服务器，指令为：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo killall pppoe-server<br></code></pre></td></tr></table></figure><ul><li><p>每次电脑重启均需要重新运行PPPoE启动命令，设置开机自启动脚本：</p><ol><li><p>创建systemd服务文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /etc/systemd/system/pppoe-server.service<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs SHELL">[Unit]<br>Description=PPPoE Server Service<br>After=network.target # 等到网络启动后再启动<br><br>[Service]<br>ExecStart=/usr/local/bin/start-pppoe.sh<br>Restart=always<br>RestartSec=5<br>User=root<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">无限制重启</span><br>StartLimitIntervalSec=0<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/bin/start-pppoe.sh<br></code></pre></td></tr></table></figure></li><li><p>创建脚本文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/bin/start-pppoe.sh<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>pppoe-server -I ens37 -L 192.168.10.10 -R 192.168.10.11 -N 20<br>pppoe-server -I ens38 -L 192.168.20.10 -R 192.168.20.11 -N 20<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">保持进程运行</span><br>tail -f /dev/null<br></code></pre></td></tr></table></figure><p>赋予执行权限：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo chmod +x /usr/local/bin/start-pppoe.sh<br></code></pre></td></tr></table></figure></li><li><p>重新加载配置，重启服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo systemctl daemon-reload<br>sudo systemctl reset-failed<br>sudo systemctl enable pppoe-server<br>sudo systemctl start pppoe-server<br></code></pre></td></tr></table></figure></li><li><p>重启后检查服务状态：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ps -ef|grep pppoe<br>sudo systemctl status pppoe-server<br></code></pre></td></tr></table></figure><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/24.png" alt="重启后的服务状态"></p></li></ol><ul><li><p>注：如果systemd服务文件中没有添加<code>StartLimitIntervalSec=0</code>,脚本文件中没有<code>tail -f /dev/null</code>,则有可能报错：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo systemctl status pppoe-server<br>● pppoe-server.service - PPPoE Server Service<br>     Loaded: loaded (/etc/systemd/system/pppoe-server.service; enabled; vendor&gt;<br>     Active: failed (Result: start-limit-hit) since Mon 2025-03-10 00:16:20 CS&gt;<br>    Process: 2386 ExecStart=/usr/local/bin/start-pppoe.sh (code=exited, status&gt;<br>   Main PID: 2386 (code=exited, status=0/SUCCESS)<br><br>3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Scheduled&gt;<br>3月 10 00:16:20 xu-virtual-machine systemd[1]: Stopped PPPoE Server Service.<br>3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Start req&gt;<br>3月 10 00:16:20 xu-virtual-machine systemd[1]: pppoe-server.service: Failed wi&gt;<br>3月 10 00:16:20 xu-virtual-machine systemd[1]: Failed to start PPPoE Server Se&gt;<br></code></pre></td></tr></table></figure><p>失败的原因： <code>start-limit-hit</code>，短时间内该服务多次失败，触发了 systemd 的启动限制机制。原脚本<code>start-pppoe.sh</code> 脚本执行完后立即退出，systemd 误以为它崩溃并尝试重启，导致触发 <code>start-limit-hit</code>。</p></li></ul></li></ul><h4 id="PPPoE客户端"><a href="#PPPoE客户端" class="headerlink" title="PPPoE客户端"></a>PPPoE客户端</h4><p>Windows端拨号步骤：</p><ol><li>选择网络和Internet设置</li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/14.png" alt="选择网络和Internet设置"></p><ol start="2"><li>选择拨号-设置新连接-连接到Internet-下一页-宽带</li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/15.png" alt="拨号选择"></p><ol start="3"><li><p>输入用户名和密码</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/16.png" alt="用户名和密码"></p></li><li><p>连接成功</p></li></ol><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/17.png" alt="拨号成功"></p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p> 客户端连接成功后，在服务器端输入<code>ifconfig</code>会看到PPP接口信息</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/18.png" alt="PPP接口"></p><p>在客户端输入<code>ipconfig /all</code>  会看到PPP服务器分配的IP地址</p><p><strong>Client1(192.168.10.20)</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/19.png" alt="Client1"></p><p><strong>测试ping通：</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/20.png" alt="Client1"></p><p><strong>Client2(192.168.20.20)</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/21.png" alt="Client2"></p><p>测试ping通：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/22.png" alt="Client2"></p><p><strong>抓包分析</strong></p><p><strong>注意</strong>：执行 <code>sudo wireshark</code> </p><p>Filter 选择pppoe|ppoes。</p><p><strong>PPPoE报文类型</strong></p><table><thead><tr><th>阶段</th><th>以太网协议号</th><th>报文类型</th></tr></thead><tbody><tr><td><strong>发现阶段</strong>（Discovery）</td><td><code>0x8863</code></td><td>PADI, PADO, PADR, PADS, PADT</td></tr><tr><td><strong>会话阶段</strong>（Session）</td><td><code>0x8864</code></td><td>PPP 数据包（LCP、PAP&#x2F;CHAP、IP 数据等）</td></tr></tbody></table><p><strong>PPPoE交互过程</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/32.png" alt="PPPoE交互过程"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/25.png" alt="抓包pppoed"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/26.png" alt="抓包pppoes-1"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/27.png" alt="抓包pppoes-2"></p><p><strong>PPPoE 发现阶段</strong></p><p>PPPoE 发现阶段用于 建立 PPPoE 连接有5种报文：</p><ol><li>PADI（PPPoE Active Discovery Initiation）</li></ol><ul><li><strong>客户端 → 广播</strong> 发送 <strong>PADI</strong>（发现请求）。</li><li>用于查找可用的 PPPoE 服务器（AC, Access Concentrator）。</li><li><strong>目标 MAC 地址：<code>FF:FF:FF:FF:FF:FF</code></strong>（广播）。</li><li>只有Service-Name为空的服务器会响应。</li></ul><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/28.png" alt="抓包pppoed-PADI"></p><ol start="2"><li>PADO（PPPoE Active Discovery Offer）</li></ol><ul><li><strong>服务器（AC）→ 客户端</strong> 回复 <strong>PADO</strong>（提供服务）。</li><li>服务器响应客户端，表明自己可用。</li><li>包含 <strong>服务器名称</strong> 和 <strong>支持的服务</strong>。</li></ul><p><img src="/./images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/29.png" alt="抓包pppoed-PADO"></p><ol start="3"><li>PADR（PPPoE Active Discovery Request）</li></ol><ul><li><p><strong>客户端 → 服务器（AC）</strong> 发送 <strong>PADR</strong>（连接请求）。</p></li><li><p>用户主机可能会收到多个 PADO，但仅查看它收到的 PADO 数据包并选择一个，并请求建立会话。</p></li><li><p>包含 <strong>服务名</strong> 和 <strong>唯一的标识符</strong>。</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/30.png" alt="抓包pppoed-PADR"></p></li></ul><ol start="4"><li>PADS（PPPoE Active Discovery Session-confirmation）</li></ol><ul><li><strong>服务器（AC）→ 客户端</strong> 发送 <strong>PADS</strong>（会话确认）。</li><li><strong>分配一个 PPPoE 会话 ID</strong>，表示连接已建立。</li></ul><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/31.png" alt="抓包pppoed-PADS"></p><ol start="5"><li>PADT（PPPoE Active Discovery Terminate）</li></ol><ul><li>客户端或服务器 发送 <strong>PADT</strong>（终止连接）。</li><li>关闭 PPPoE 连接。</li></ul><p><strong>PPPoE 会话阶段</strong></p><p>PPPoE 发现阶段完成后，客户端和服务器通过 <strong>PPPoE 会话 ID</strong> 进行通信。<br> 此时 PPPoE 封装标准 PPP 报文，包括4种报文：</p><ol><li><strong>LCP（Link Control Protocol）</strong>：链路协商。</li><li><strong>PAP&#x2F;CHAP（Password Authentication Protocol &#x2F; Challenge Handshake Authentication Protocol）</strong>:  用户身份认证。</li><li><strong>NCP（Network Control Protocol)</strong> : 分配 IP 地址。</li><li><strong>IP 数据报文</strong>: 网络通信数据（TCP&#x2F;IP、UDP）。</li></ol><h2 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h2><ol><li>设计PPPoE+RADIUS远程接入控制拓扑图及IP地址规划（客户机至少两个网段）。</li><li>选型RADIUS服务器软件，并在虚拟平台下完成PPPOE+RADIUS远程接入认证的搭建、配置、实验测试。</li></ol><h3 id="任务一-1"><a href="#任务一-1" class="headerlink" title="任务一"></a>任务一</h3><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/42.png" alt="42"></p><h3 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h3><ul><li>RADIUS服务器：FreeRADIUS 3.0.27 （最新stable版本）</li><li>RADIUS客户端：FreeRADIUS -client-1.1.7</li></ul><h4 id="配置Radius服务器及客户端静态IP"><a href="#配置Radius服务器及客户端静态IP" class="headerlink" title="配置Radius服务器及客户端静态IP"></a>配置Radius服务器及客户端静态IP</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /etc/netplan/01-network-manager-all.yaml<br></code></pre></td></tr></table></figure><ul><li><strong>服务器</strong></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Let NetworkManager manage all devices on this system</span><br>network:<br>  version: 2<br>  renderer: NetworkManager<br>  ethernets:<br>    ens33:            <br>      dhcp4: true                           # 启用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br>        <br>    ens37:<br>      addresses: [192.168.30.2/24]        <br>      routes:<br>        - to: default<br>          via: 192.168.30.1                <br>      dhcp4: false                          <br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4] <br></code></pre></td></tr></table></figure><p>配置完成后执行命令使配置生效。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo netplan apply<br></code></pre></td></tr></table></figure><p>执行<code>ifconfig</code>命令查看当前IP地址</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/40.png" alt="40"></p><ul><li><strong>客户端（PPPoE服务器）</strong></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Let NetworkManager manage all devices on this system</span><br>network:<br>  version: 2<br>  renderer: NetworkManager<br>  ethernets:<br>    ens33:            <br>      dhcp4: true                           # 启用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br>        <br>    ens37:<br>      addresses: [192.168.10.1/24]           # 静态 IP 地址<br>      routes:<br>        - to: default<br>          via: 192.168.10.1  # 默认网关<br>      dhcp4: false                           # 禁用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br>        <br>    ens38:<br>      addresses: [192.168.20.1/24]           # 静态 IP 地址<br>      routes:<br>        - to: default<br>          via: 192.168.20.1  # 默认网关<br>      dhcp4: false                           # 禁用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br>        <br>    ens39:<br>      addresses: [192.168.30.1/24]           # 静态 IP 地址<br>      routes:<br>        - to: default<br>          via: 192.168.30.1  # 默认网关<br>      dhcp4: false                           # 禁用 DHCP<br>      nameservers:<br>        addresses: [8.8.8.8, 8.8.4.4]        # DNS 配置<br><br>      link: ens37<br>      addresses:<br>        - 192.168.10.129/25<br></code></pre></td></tr></table></figure><p>配置完成后执行命令使配置生效。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo netplan apply<br></code></pre></td></tr></table></figure><p>执行<code>ifconfig</code>命令查看当前IP地址</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/41.png" alt="41"></p><h4 id="安装Radius服务器"><a href="#安装Radius服务器" class="headerlink" title="安装Radius服务器"></a>安装Radius服务器</h4><ol><li><p>下载Radius：</p><p>freeradius官方网站：<a href="http://freeradius.org/download.html">http://freeradius.org/download.html</a></p><p>freeradius官方文档：</p></li><li><p>解压：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">tar -zxvf freeradius-server-3.0.27.tar.gz <br></code></pre></td></tr></table></figure></li><li><p>安装依赖项</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install build-essential -y<br>sudo apt install libtalloc-dev -y<br>sudo apt install libssl-dev -y<br>sudo apt install libhiredis-dev -y<br>sudo apt install freeradius-mysql<br></code></pre></td></tr></table></figure></li><li><p>编译及安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd  freeradius-server-3.0.26<br>./configure <br>make<br>sudo make install # 默认安装在 /usr/local/etc/raddb下<br></code></pre></td></tr></table></figure></li><li><p>启动Radius</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">debug模式启动</span><br>sudo radiusd -X<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">后台进程方式启动</span><br>systemctl start radiusd<br>systemctl enable radiusd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">日志</span><br>/var/log/radius/radius.log <br></code></pre></td></tr></table></figure></li><li><p>添加用户</p><p>在 &#x2F;usr&#x2F;local&#x2F;etc&#x2F;raddb&#x2F;users 的末尾添加：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">test</span> 的用户设置明文密码为 <span class="hljs-string">&quot;test&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">user Cleartext-Password := <span class="hljs-string">&quot;password&quot;</span></span><br>test Cleartext-Password := &quot;test&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">radtest &lt;用户名&gt; &lt;密码&gt; &lt;服务器地址&gt; &lt;端口&gt; &lt;共享密钥&gt;</span><br>radtest testing password123 127.0.0.1 0 testing123  <br></code></pre></td></tr></table></figure><p>本地测试成功</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/34.png" alt="34"></p></li></ol><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>1.安装mariadb</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install mariadb-server mariadb-client<br>sudo systemctl start mariadb<br>sudo systemctl enable mariadb<br></code></pre></td></tr></table></figure><p>若此时直接运行安全设置<code>mysql_secure_installation</code>，则报错：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">xu@xu-virtual-machine:~/Desktop$ mysql_secure_installation<br><br>NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB<br>      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!<br><br>In order to log into MariaDB to secure it, we&#x27;ll need the current<br>password for the root user.  If you&#x27;ve just installed MariaDB, and<br>you haven&#x27;t set the root password yet, the password will be blank,<br>so you should just press enter here.<br><br>Enter current password for root (enter for none): <br>ERROR 1698 (28000): Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27;<br>Enter current password for root (enter for none): <br>Aborting!<br><br>Cleaning up...<br></code></pre></td></tr></table></figure><p>这是因为 MariaDB 默认使用 <strong><code>auth_socket</code> 插件</strong> 进行身份验证，它不接受通过普通密码登录，只通过 Unix 套接字进行验证。</p><p>解决方案：</p><ul><li><p>通过root用户登录:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo mysql -u root<br></code></pre></td></tr></table></figure></li><li><p>禁用 <code>auth_socket</code> 插件并设置密码:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo mysql<br>USE mysql;<br>SET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;1&#x27;);<br><span class="hljs-meta prompt_"># </span><span class="language-bash">刷新权限并退出</span><br>FLUSH PRIVILEGES;<br>EXIT;<br></code></pre></td></tr></table></figure></li></ul><p>​运行<code>mysql_secure_installation</code>进行安全设置：</p><img src="/images/接入网综合课设/35.png" alt="35" style="zoom: 80%;" /><ol start="2"><li>进入数据库</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p<br></code></pre></td></tr></table></figure><ol start="3"><li>创建数据库并授权</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">MariaDB [(<span class="hljs-keyword">none</span>)]<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> database radius；<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>MariaDB [(<span class="hljs-keyword">none</span>)]<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> radius.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> radius@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;radius&#x27;</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>MariaDB [(<span class="hljs-keyword">none</span>)]<span class="hljs-operator">&gt;</span> flush privileges;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h4 id="配置Radius服务器端和数据库"><a href="#配置Radius服务器端和数据库" class="headerlink" title="配置Radius服务器端和数据库"></a>配置Radius服务器端和数据库</h4><ol><li>导入数据库</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /usr/local/etc/raddb/mods-config/sql/main/mysql<br>mysql -u radius -p radius&lt; schema.sql<br></code></pre></td></tr></table></figure><p>如果报错：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">root@xu-virtual-machine:/usr/local/etc/raddb/mods-config/sql/main/mysql# mysql -u radius -p radius&lt; schema.sql<br>Enter password: <br>ERROR 1045 (28000): Access denied for user &#x27;radius&#x27;@&#x27;localhost&#x27; (using password: YES)<br></code></pre></td></tr></table></figure><p>这是因为 MySQL 用户 <code>radius</code> 在 <code>localhost</code> 上的访问被拒绝，重新设置密码</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;radius&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;your_password&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> radius.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;radius&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>配置Radius</p><ul><li><p>配置default文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo -i<br>gedit /usr/local/etc/raddb/sites-enabled/default<br></code></pre></td></tr></table></figure><p>使用数据库储存用户信息&#x2F;计费：</p><p>在538行authenticate {}部分，注释files，解注释sql</p><p>在673行accounting{}部分，解注释 sql</p></li><li><p>配置sql文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo -i<br>gedit /usr/local/etc/raddb/mods-available/sql<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置文件</span><br>tls_required = no<br>driver = &quot;rlm_sql_mysql&quot;  # 指定 FreeRADIUS 使用 MySQL 数据库作为后端数据库来进行认证和计费<br>dialect = &quot;mysql&quot;         # mysql 表示使用 MySQL 数据库的 SQL 方言<br>server = &quot;localhost&quot;      # 数据库运行在本地计算机上<br>port = 3306 <br>login = &quot;radius&quot;<br>password = &quot;radius&quot;<br>radius_db = &quot;radius&quot;<br>read_clients = yes         # 允许 FreeRADIUS 从数据库中读取客户端信息                                      、<br></code></pre></td></tr></table></figure></li></ul></li><li><p>客户端认证设置</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/raddb/clients.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">定义 PPPoE 客户端连接到服务器时需要使用的 IP 地址和密码（共享密钥）</span><br>client pppoe-server &#123;<br>    ipaddr = 192.168.30.1<br>    secret = testing123<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>配置组与用户信息</li></ol><ul><li>进入radius库</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo mysql -u root -p radius<br></code></pre></td></tr></table></figure><ul><li>新建组</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">insert into radgroupcheck (groupname,attribute,op,value) values  (&#x27;usr&#x27;,&#x27;Auth- Type&#x27;,&#x27;:=&#x27;,&#x27;Local&#x27;);<br>insert into radgroupcheck (groupname,attribute,op,value) values (&#x27;usr&#x27;,&#x27;Service-Type&#x27;,&#x27;:=&#x27;,&#x27;Framed-User&#x27;);<br>insert into radgroupcheck (groupname,attribute,op,value) values (&#x27;usr&#x27;,&#x27;Framed-IP-Address&#x27;,&#x27;:=&#x27;,&#x27;255.255.255.255&#x27;);<br>insert into radgroupcheck (groupname,attribute,op,value) values (&#x27;usr&#x27;,&#x27;Framed-IP-Netmask&#x27;,&#x27;:=&#x27;,&#x27;255.255.255.0&#x27;);<br></code></pre></td></tr></table></figure><p>查看新建组 <code>select * from radgroupcheck; </code></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/36.png" alt="36"></p><p>可以看到，<code>usr</code> 组的认证方式为 <strong>本地认证（Local）</strong>， <code>Service-Type</code> 为 Framed-User，即拨号用户，用于 <strong>PPP&#x2F;PPPoE 认证</strong>。分配给用户的 IP 地址为255.255.255.255，表示 不指定具体 IP 地址，由PPPoE 服务器动态分配。若分配了 IP 地址，默认子网掩码为 <code>255.255.255.0</code>。</p><ul><li><p>配置 RADIUS 认证用户</p><p>定义 RADIUS 用户，用于身份验证。</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/raddb/users<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对于 client-1</span><br>user1 Cleartext-Password := &quot;test-1&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">对于 client-2</span><br>user2 Cleartext-Password := &quot;test-2&quot;<br></code></pre></td></tr></table></figure><ul><li>插入用户</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> radcheck (username, attribute, op, <span class="hljs-keyword">value</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;user1&#x27;</span>, <span class="hljs-string">&#x27;Cleartext-Password&#x27;</span>, <span class="hljs-string">&#x27;:=&#x27;</span>, <span class="hljs-string">&#x27;test-1&#x27;</span>); <br><span class="hljs-keyword">INSERT INTO</span> radcheck (username, attribute, op, <span class="hljs-keyword">value</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;user2&#x27;</span>, <span class="hljs-string">&#x27;Cleartext-Password&#x27;</span>, <span class="hljs-string">&#x27;:=&#x27;</span>, <span class="hljs-string">&#x27;test-2&#x27;</span>); <br></code></pre></td></tr></table></figure><p>查看用户信息 <code>SELECT * FROM radcheck; </code></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/37.png" alt="37"></p><ul><li>关联用户和组</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> radusergroup (username, groupname) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;user1&#x27;</span>, <span class="hljs-string">&#x27;usr&#x27;</span>);<br><span class="hljs-keyword">INSERT INTO</span> radusergroup (username, groupname) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;user2&#x27;</span>, <span class="hljs-string">&#x27;usr&#x27;</span>);<br></code></pre></td></tr></table></figure><p>查看用户和组的关联信息 <code>SELECT * FROM radusergroup; </code></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/38.png" alt="38"></p><ul><li>建立软链接</li></ul><p>在 FreeRADIUS 服务器的配置目录中启用 SQL 模块</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo -i<br>cd /usr/local/etc/raddb/mods-enabled<br>ln -s /usr/local/etc/raddb/mods-available/sql ./<br></code></pre></td></tr></table></figure><p>查看软链接信息 <code>ls -l /usr/local/etc/raddb/mods-enabled/sql </code><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/39.png" alt="39"></p><ul><li>本地测试用户链接：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">radtest user1 test-1 127.0.0.1 0 testing123<br>radtest user2 test-2 127.0.0.1 0 testing123<br></code></pre></td></tr></table></figure><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/44.png" alt="44"></p><h4 id="配置Radius客户端"><a href="#配置Radius客户端" class="headerlink" title="配置Radius客户端"></a>配置Radius客户端</h4><ol><li>下载并安装RADIUS -clients</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wget ftp://ftp.freeradius.org/pub/freeradius/freeradius-client-1.1.7.tar.gz<br>tar -xzvf freeradius-client-1.1.7.tar.gz <br><br>cd freeradius-client-1.1.7/<br>./configure <br>sudo make<br>sudo make install<br></code></pre></td></tr></table></figure><ol start="2"><li>在 PPPoE 服务器中启用 RADIUS 认证</li></ol><p>​在&#x2F;etc&#x2F;ppp&#x2F;pppoe-server-options中增加</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加载 radius.so 插件</span><br>plugin /usr/lib/pppd/2.4.7/radius.so<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定 RADIUS 客户端配置文件</span><br>radius-config-file /usr/local/etc/radiusclient/radiusclient.conf<br></code></pre></td></tr></table></figure><ol start="3"><li>配置radiusclient.conf文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/radiusclient/radiusclient.conf<br></code></pre></td></tr></table></figure><p>在文件末尾添加：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">认证顺序：先本地认证，再 RADIUS 远程认证</span><br>auth_order      local,radius<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS 认证服务器</span><br>authserver      192.168.30.2:1812<br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS 计费服务器</span><br>acctserver      192.168.30.2:1813<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS 共享密钥存放</span><br>servers        /usr/local/etc/radiusclient/servers<br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS 共享密钥文件</span><br>seqfile        /var/run/radius.seq<br><span class="hljs-meta prompt_"># </span><span class="language-bash">RADIUS映射文件</span><br>mapfile        /usr/local/etc/radiusclient/port-id-map<br>dictionary     /usr/local/etc/radiusclient/dictionary<br>login_radius   /usr/local/sbin/login.radius<br></code></pre></td></tr></table></figure><ol start="4"><li>配置 server 文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/radiusclient/servers<br></code></pre></td></tr></table></figure><p>在文件末尾添加：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">[RADIUS服务器IP]  [共享密钥]  [可选参数]</span><br>192.168.30.2 testing123<br></code></pre></td></tr></table></figure><ol start="5"><li>配置dictionary文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /usr/local/etc/radiusclient/dictionary<br></code></pre></td></tr></table></figure><p>在文件末尾添加：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">INCLUDE /usr/local/etc/radiusclient/dictionary.sip<br>INCLUDE /usr/local/etc/radiusclient/dictionary.ascend<br>INCLUDE /usr/local/etc/radiusclient/dictionary.merit<br>INCLUDE /usr/local/etc/radiusclient/dictionary.compat<br>INCLUDE /usr/local/etc/radiusclient/dictionary.microsoft<br></code></pre></td></tr></table></figure><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><ul><li><p>PPPoE服务器启动情况</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/43.png" alt="43"></p></li><li><p>Radius服务器启动情况</p></li></ul><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/45.png" alt="45"></p><ul><li><strong>Client1</strong></li></ul><p>输入正确用户及密码（user1，test-1），拨号成功</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/46.png" alt="46"></p><p>PPPoE服务器已分配地址：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/47.png" alt="47"></p><p>上网测试：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/49.png" alt="49"></p><p>在Radius服务器端本次会话记录:</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/50.png" alt="50"></p><p>输入错误用户及密码（user1，test-2），拨号失败</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/51.png" alt="51"></p><p>在Radius服务器端本次会话记录:</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/53.png" alt="53"></p><ul><li><strong>Client2</strong></li></ul><p>输入正确用户密码（user2，test-2），拨号成功</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/46.png" alt="46"></p><p>PPPoE服务器已分配地址：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/48.png" alt="48"></p><p>上网测试：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/49.png" alt="49"></p><p>在Radius服务器端本次会话记录:</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/52.png" alt="52"></p><p>输入错误用户及密码（user2，test-1），拨号失败</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/51.png" alt="51"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/54.png" alt="54"></p><h4 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h4><p>RADIUS报文格式</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/55.png" alt="55"></p><p>RADIUS 报文类型分为 认证报文 和 计费报文：</p><p><strong>1. 认证报文（Authentication Messages）</strong></p><p>认证报文用于 <strong>用户身份验证</strong>，确保用户合法，并为其分配相应权限。常见类型如下：</p><table><thead><tr><th>报文类型</th><th>代码</th><th>作用</th></tr></thead><tbody><tr><td><strong>Access-Request</strong></td><td><code>1</code></td><td>认证请求，客户端（NAS）向 RADIUS 服务器发送，包含用户名、密码等信息</td></tr><tr><td><strong>Access-Accept</strong></td><td><code>2</code></td><td>认证通过，RADIUS 服务器返回，NAS 允许用户访问</td></tr><tr><td><strong>Access-Reject</strong></td><td><code>3</code></td><td>认证失败，RADIUS 服务器拒绝用户访问</td></tr><tr><td><strong>Access-Challenge</strong></td><td><code>11</code></td><td>质询认证，要求客户端提供额外凭证（如 EAP 认证）</td></tr></tbody></table><p>** 2. 计费报文（Accounting Messages）**</p><p>计费报文用于 <strong>记录用户上网时长、流量等信息</strong>，用于后续计费。常见类型如下：</p><table><thead><tr><th>报文类型</th><th>代码</th><th>作用</th></tr></thead><tbody><tr><td><strong>Accounting-Request</strong></td><td><code>4</code></td><td>计费请求，NAS 发送给 RADIUS 服务器，包含用户会话信息</td></tr><tr><td><strong>Accounting-Response</strong></td><td><code>5</code></td><td>计费响应，RADIUS 服务器收到计费信息后确认</td></tr></tbody></table><p><code>Accounting-Request</code> 又分为：</p><ul><li><strong>Start</strong>（用户上线）：用户开始上网时发送，记录 <code>acctstarttime</code>。</li><li><strong>Interim-Update</strong>（状态更新）：定期发送，更新流量、时长等数据。</li><li><strong>Stop</strong>（用户下线）：用户断开时发送，记录 <code>acctstoptime</code>、<code>acctsessiontime</code>、流量。</li></ul><p>RADIUS客户端与服务器交互过程：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/56.png" alt="56"></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/57.png" alt="57"></p><p><strong>Access-Request</strong>：</p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/58.png" alt="58"></p><p><strong>Access-Accept</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/59.png" alt="59"></p><p><strong>Access-Reject</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/60.png" alt="60"></p><p><strong>Accounting-Request</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/61.png" alt="61"></p><p><strong>Accounting-Response</strong></p><p><img src="/images/%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%BC%E5%90%88%E8%AF%BE%E8%AE%BE/62.png" alt="62"></p><h4 id="遇到的问题及调试方法"><a href="#遇到的问题及调试方法" class="headerlink" title="遇到的问题及调试方法"></a>遇到的问题及调试方法</h4><p>在Radius全面配置好后，windows客户端无法直接拨号，否则显示691错误码，在radius端无信息反馈。推测PPPoE与客户端间传输存在问题。接回PPPoE本地测试可通。</p><p>使用<code>sudo tail -f /var/log/syslog | grep ppp</code>监听PPPoE服务器信息</p><p>当客户端拨号时，报错：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Apr  3 11:19:13 xu-virtual-machine pppd[2901]: rc_read_dictionary: invalid type on line 92 of dictionary /usr/local/etc/radiusclient/dictionary<br>Apr  3 11:19:13 xu-virtual-machine pppd[2901]: RADIUS: Can&#x27;t read dictionary file /usr/local/etc/radiusclient/dictionary<br>Apr  3 11:19:13 xu-virtual-machine pppd[2901]: Peer user2 failed CHAP authentication<br></code></pre></td></tr></table></figure><ul><li><p>把<code>/usr/local/etc/radiusclient/dictionary</code>文件中所有<code>ipv6addr</code>和<code>ipv6prdeix</code>改成<code>string</code></p></li><li><p>下载dictionary.microsoft，只有使用该文件才支持Windows拨号</p></li><li><p>在<code>/usr/local/etc/radiusclient/dictionary</code>末尾加上</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">INCLUDE /usr/local/etc/radiusclient/dictionary.sip<br>INCLUDE /usr/local/etc/radiusclient/dictionary.ascend<br>INCLUDE /usr/local/etc/radiusclient/dictionary.merit<br>INCLUDE /usr/local/etc/radiusclient/dictionary.compat<br>INCLUDE /usr/local/etc/radiusclient/dictionary.microsoft<br></code></pre></td></tr></table></figure><p>之后再拨号，Radius服务器端显示报错信息，根据具体报错信息修改即可。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;接入网综合课设&quot;&gt;&lt;a href=&quot;#接入网综合课设&quot; class=&quot;headerlink&quot; title=&quot;接入网综合课设&quot;&gt;&lt;/a&gt;接入网综合课设&lt;/h1&gt;&lt;h2 id=&quot;阶段一&quot;&gt;&lt;a href=&quot;#阶段一&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="课设" scheme="http://example.com/tags/%E8%AF%BE%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>网络算法基础</title>
    <link href="http://example.com/2025/02/27/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2025/02/27/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2025-02-27T06:35:01.000Z</published>
    <updated>2025-03-10T03:12:40.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法与分治"><a href="#算法与分治" class="headerlink" title="算法与分治"></a>算法与分治</h1><p>Divide and Conquer（DC）</p><p>Divide：将源问题分解为规模较小的子问题，<strong>拆分问题性质相同</strong>，将子问题的解组合成原问题的解。</p><p>Conquer：如果子问题仍然困难，就继续对子问题进行分解，直到子问题可以被trivial。</p><p>Recursion：用递归的方式实现。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>问题定义：</p><ul><li><p>输入：n个数构成的数组;</p></li><li><p>输出：排列该n个数的有序数组。</p></li></ul><p>Merg Sort：</p><ul><li>分解：将原数组等分为两个子数组;</li><li>求解：递归地对两个子数组分别排序;</li><li>合并：将两个已排序的子数组合并。</li></ul><h3 id="Merge-Step"><a href="#Merge-Step" class="headerlink" title="Merge Step"></a>Merge Step</h3><p> <strong>CLAIM</strong>：对于n ≥ 1的数组，MergeSort需要的运行时间T(n) ≤ $ 6n \log_2 n + 6n $</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/1.PNG" alt="图片" title="证明"></p><h3 id="函数增长的渐进符号"><a href="#函数增长的渐进符号" class="headerlink" title="函数增长的渐进符号"></a>函数增长的渐进符号</h3><p><strong>Big O</strong>: 如果存在正数c和N，对于所有的n&gt;&#x3D;N，有f(n)&lt;&#x3D;c*g(n)，则f(n)&#x3D;O(g(n))。</p><p><strong>Big Omega</strong>：如果存在正数c和N，对于所有的n&gt;&#x3D;N，有f(n)&gt;&#x3D;c*g(n)，则f(n)&#x3D;Omega(g(n))。</p><p><strong>Big Theta</strong>：f(n)&#x3D;Theta(g(n))，当且仅当f(n)&#x3D;O(g(n))且f(n)&#x3D;Omega(g(n))。</p><h3 id="基于比较的排序"><a href="#基于比较的排序" class="headerlink" title="基于比较的排序"></a>基于比较的排序</h3><p><strong>CLAIM</strong>：任何基于比较的排序算法，RT不可能低于O(nlogn)。</p><p>任何基于两两比较的排序算法都可以表达为一棵决策树（完全二叉树）。</p><p>完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/2.PNG" alt="图片" title="决策树的性质"></p><h3 id="主办法（Master-Method）"><a href="#主办法（Master-Method）" class="headerlink" title="主办法（Master Method）"></a>主办法（Master Method）</h3><p><strong>主定理</strong></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/3.PNG" alt="图片" title="主定理的定义"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/4.PNG" alt="图片" title="主定理的证明"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/5.PNG" alt="图片" title="参数"></p><h1 id="图简介"><a href="#图简介" class="headerlink" title="图简介"></a>图简介</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><strong>树</strong>：不包含任何圈的连通图。</p><p><strong>生成树(Spanning Tree)</strong>：如果图G的一个子图包含了G的全部顶点，且为树，则称之为G的生成树。</p><h2 id="图搜索"><a href="#图搜索" class="headerlink" title="图搜索"></a>图搜索</h2><h3 id="循环不变式"><a href="#循环不变式" class="headerlink" title="循环不变式"></a>循环不变式</h3><ul><li>概念：每次循环开始时都要保持的性质 &#x2F; 状态。</li><li><strong>INVARIANT</strong>：已探索集合和未探索集合应该处于正确的状态。边界点集合应准备好了。<ul><li>循环开始时，从边界点集合中选择一个顶点进行探索。</li><li>循环结束前，将新扩展的边界点纳入集合。</li></ul></li><li>维护边界点集合：<ul><li><strong>BFS：队列(FIFO)</strong></li><li><strong>DFS：堆栈(LIFO)</strong></li></ul></li></ul><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>BFS的伪代码：</p><pre><code>BFS(Graph, start):B.EnQueue(s)WHILE B is not empty:    d=B.DeQueue();    标记d为“已探索”    FOR each neighbor t of d:        IF t is not in visited:            B.EnQueue(t)        ENDIF    ENDFORENDWHILE</code></pre><p><strong>聚合分析复杂度</strong>：O(n+m)</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>DFS的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">DFS(Graph, start):<br>B.Push(s)<br>WHILE B is not empty:<br> d = B.Pop()<br> 标记 d 为“已探索”<br> FOR each neighbor t of d:<br>  IF t is not in visited:<br>   B.Push(t)<br>  ENDIF<br> ENDFOR<br>ENDWHILE<br></code></pre></td></tr></table></figure><p><strong>聚合分析复杂度</strong>：O(n+m)</p><h2 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h2><h3 id="无向图的连通分量"><a href="#无向图的连通分量" class="headerlink" title="无向图的连通分量"></a><u>无向图</u>的连通分量</h3><p>下述等价关系的等价类：当且仅当图中具有u-v路径时，称u~v。</p><h4 id="BFS求无向连通分量"><a href="#BFS求无向连通分量" class="headerlink" title="BFS求无向连通分量"></a>BFS求无向连通分量</h4><p>BFS求无向连通分量的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Loop-BFS(G):<br>FOR i=1 to n<br>IF t is not in visited:<br>BFS(G,i);<br>ENDFOR<br></code></pre></td></tr></table></figure><p><strong>聚合分析复杂度</strong>：O(n+m)</p><h3 id="有向图的强连通分量（Strongly-Connected-Component-SCC）"><a href="#有向图的强连通分量（Strongly-Connected-Component-SCC）" class="headerlink" title="有向图的强连通分量（Strongly Connected Component,SCC）"></a><u>有向图</u>的强连通分量（Strongly Connected Component,SCC）</h3><p>下述等价关系的等价类：当且仅当有向图G中具有u -&gt; v路径且具有v -&gt; u路径时，称称u~v。</p><h4 id="TWO-PASS算法-Kosaraju算法"><a href="#TWO-PASS算法-Kosaraju算法" class="headerlink" title="TWO-PASS算法(Kosaraju算法)"></a>TWO-PASS算法(Kosaraju算法)</h4><ol><li>构建逆图。</li><li><strong>在逆图中进行 Loop-DFS</strong>，记录每个节点的<strong>完成时间</strong> f(v)。</li><li><strong>在原图中运行 Loop-DFS</strong>，按照逆图 DFS 完成的节点顺序进行，确定每个节点的 Leader。</li></ol><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/6.PNG" alt="图片" title="Kosaraju算法-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/7.PNG" alt="图片" title="Kosaraju算法-2"></p><p><strong>聚合分析复杂度</strong>：O(n+m)</p><h4 id="关键引理"><a href="#关键引理" class="headerlink" title="关键引理"></a><strong>关键引理</strong></h4><p>Key Lemma：考虑有向图G中的两个临接SCC，f(v)表示顶点v在反向图G’中Loop-DFS的完成时间，则有：<br>$$<br>\max_{v \in C_1} f(v) &lt; \max_{v \in C_2} f(v)<br>$$<br>推论：最大的f值必然在”sink“SCC中。</p><h1 id="贪心MST"><a href="#贪心MST" class="headerlink" title="贪心MST"></a>贪心MST</h1><h2 id="贪心vs分治"><a href="#贪心vs分治" class="headerlink" title="贪心vs分治"></a>贪心vs分治</h2><ul><li><strong>决策过程</strong>：<ul><li><strong>分治</strong>：每个子问题的解都会考虑整个子问题的情况，逐步拆解，最终合并。</li><li><strong>贪心</strong>：每一步决策只关注当前的局部最优解，不回头。</li></ul></li><li><strong>全局与局部</strong>：<ul><li><strong>分治</strong>：每个子问题的解可能涉及整个问题的全局结构。</li><li><strong>贪心</strong>：每一步只考虑局部最优解，期望通过局部最优解得到全局最优解。</li></ul></li><li><strong>解决问题的方式</strong>：<ul><li><strong>分治</strong>：递归地分解问题，直到子问题足够简单直接求解。</li><li><strong>贪心</strong>：通过逐步选择当前最优的解来构建最终解。</li></ul></li><li><strong>是否需要回溯</strong>：<ul><li><strong>分治</strong>：通常会回溯并合并结果。</li><li><strong>贪心</strong>：不会回溯，一旦做出选择就不再修改。</li></ul></li></ul><h2 id="MST（前提：无向图）"><a href="#MST（前提：无向图）" class="headerlink" title="MST（前提：无向图）"></a>MST（前提：无向图）</h2><p><strong>定义</strong>：最小权重生成树T。</p><ul><li>必须是无向图;</li><li>生成树的权重定义为树上边权重之和;</li><li>生成树定义为E的子集：<ol><li>必须覆盖V;</li><li>无环;</li><li>连通。</li></ol></li></ul><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/8.PNG" alt="图片" title="MST"></p><h3 id="割"><a href="#割" class="headerlink" title="割"></a>割</h3><p>割的概念：图G(V，E)的一个割(Cut)是V的一个划分，该划分将集合V分为两个非空的集合。</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/9.PNG" alt="图片" title="割"></p><ul><li>n个顶点的图最多有 $ 2^n-2 $ 个不同的割。</li></ul><p><strong>Empty-Cut引理</strong>：图G不连通，当且仅当Cut(A，B)没有割边。</p><p><strong>Double-Crossing Lemma</strong>：如果某个圈C⊆E中有边跨越了Cut(A，B)，则C中<strong>至少还有一条边</strong>跨越Cut(A，B)。</p><p><strong>Lonely-Cut Corollary</strong>：如果边e是跨越了Cut(A，B)的唯一一条边，则e不可能在<strong>任一</strong>圈中。</p><p><strong>The Cut Property</strong>：考虑图G中的一条边e，如果存在Cut(A，B)，使得e是所有跨越该割的所有边中权最小者，则e一定在G的MST中。</p><p>割的证明：</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/10.PNG" alt="图片" title="割的证明-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/11.PNG" alt="图片" title="割的证明-2"></p><h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><p>一个容器，其中元素具有key。</p><p>常规操作及对应的RT：</p><ul><li>Heapify：建堆 O(n)</li><li>Insert：加入一个新的对象 O(logn)</li><li>Extract-Min：从堆中取出具有最小key的元素 O(logn)</li><li>Delete：删除指定元素 O(logn)</li></ul><h4 id="Heap-Property"><a href="#Heap-Property" class="headerlink" title="Heap Property"></a><strong>Heap Property</strong></h4><ul><li>堆是一颗有根，二叉，尽可能完全的树。</li><li>任何节点的key都不大于其所有子代的key。 ——&gt; <strong>根元素具有最小key</strong></li></ul><h4 id="用数组实现堆"><a href="#用数组实现堆" class="headerlink" title="用数组实现堆"></a><strong>用数组实现堆</strong></h4><ul><li>Parent (i) &#x3D; i &#x2F; 2  （下标i为奇数时向下取整）</li><li>LeftC (i) &#x3D; 2i</li><li>RightC (i) &#x3D; 2i + 1</li></ul><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/12.PNG" alt="图片" title="堆的操作-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/13.PNG" alt="图片" title="堆的操作-2"></p><h3 id="Prime算法"><a href="#Prime算法" class="headerlink" title="Prime算法"></a><strong>Prime算法</strong></h3><p>基本思想：</p><ul><li>从一个节点开始（任意选择一个节点作为起点），将它加入生成树。</li><li>找到当前生成树中所有节点与其他节点之间的边，选择权重最小的边。</li><li>将与该边相连的节点加入生成树，更新最小边的权重，重复选择最小边的过程。</li><li>直到所有节点都被加入到生成树中。</li></ul><p>Pim的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Prim(Graph, start):<br>    初始化最小生成树的边集合 MST = &#123;&#125;<br>    初始化一个优先队列 Q，用于存储每个节点及其最小边的权重<br>    对于每个节点 v ∈ Graph:<br>        设置 v 的最小权重为无穷大（∞）<br>    设置 start 节点的最小权重为 0，并将其加入 Q<br><br>    WHILE Q is not empty:<br>        选择 Q 中最小的权重的节点 u<br>        标记 u 为“已加入到最小生成树”<br><br>        对于 u 的每个邻居 v:<br>            IF v is not in MST AND weight(u, v) &lt; v 的当前权重:<br>                更新 v 的最小权重为 weight(u, v)<br>                将 v 更新到 Q 中，以反映其新的最小权重<br><br>        ENDFOR<br>    ENDWHILE<br></code></pre></td></tr></table></figure><p>Prim算法的证明：</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/14.PNG" alt="图片" title="Prim的证明-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/15.PNG" alt="图片" title="Prim的证明-2"></p><p>用堆实现Prim：</p><pre><code>Prim(Graph, start):    初始化最小生成树 MST = &#123;&#125;    初始化最小堆 MinHeap    初始化一个集合 Visited，用于记录已加入 MST 的节点    将 (0, start) 插入 MinHeap  // (边的权重, 节点)    初始化 total_weight = 0  // 记录最小生成树的总权重WHILE MinHeap is not empty:    (weight, node) = MinHeap.Pop()  // 取出当前权重最小的边    IF node 已在 Visited:        CONTINUE  // 如果该节点已经在 MST 中，跳过    标记 node 为已访问    total_weight += weight  // 累加权重    MST.Add(node)    FOR each (neighbor, edge_weight) in Graph[node]:  // 遍历邻居        IF neighbor 不在 Visited:            MinHeap.Push((edge_weight, neighbor))  // 只加入未访问的节点RETURN MST, total_weight</code></pre><p><strong>复杂度分析</strong>：</p><ul><li>n次Extract-Min：O(nlogn)</li><li>m次Delete和m次Insert：O(mlogn)</li></ul><p>总RT &#x3D; O(nlogn)+O(mlogn) &#x3D; <strong>O(mlogn)</strong></p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>基本思想：</p><ul><li>按权重升序对边排序。</li><li>按序逐条检查边。</li><li>只要不成环，就将边加入T。</li></ul><p>Kruskal的伪代码：</p><pre><code>Kruskal(Graph):    初始化最小生成树 MST = &#123;&#125;    初始化并查集（Union-Find）来管理连通性    按照权重从小到大排序 Graph 的所有边 EdgeListFOR (u, v, weight) in EdgeList:  // 遍历排序后的边    IF u 和 v 不在同一个连通分量 (Find(u) ≠ Find(v)):        MST.Add((u, v, weight))  // 加入最小生成树        Union(u, v)  // 合并连通分量    IF MST 的边数 == V - 1:        BREAK  // 最小生成树构建完成RETURN MST</code></pre><p>Kruskal算法的证明：</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/16.PNG" alt="图片" title="Kruskal的证明-1"></p><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/17.PNG" alt="图片" title="Kruskal的证明-2"></p><h4 id="UNION-FIND算法"><a href="#UNION-FIND算法" class="headerlink" title="UNION-FIND算法"></a>UNION-FIND算法</h4><p>Union-Find（并查集）是一种高效的数据结构，主要用于<strong>处理动态连通性问题</strong>。它支持两种核心操作：</p><ol><li><strong>Find(x)</strong>：查找元素 <code>x</code> 所属的集合（返回它的代表元素）。</li><li><strong>Union(x, y)</strong>：合并 <code>x</code> 和 <code>y</code> 所在的两个集合。</li></ol><p>核心思想：</p><ul><li><strong>每个集合用一棵树表示</strong>，树的根节点作为该集合的<strong>代表元</strong>（代表元素）。</li><li><strong>Find(x)</strong> 操作用于查找 <code>x</code> 所在集合的代表元（根节点）。</li><li><strong>Union(x, y)</strong> 操作用于合并两个集合，<strong>将其中一个集合的根节点指向另一个集合的根</strong>。</li></ul><h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><p>Dijkstra的前提：<strong>无负权图（源点到第一层点的权重可为负值），避免负圈。</strong></p><p>Dijkstra的基本思路：</p><ol><li>初始化：</li></ol><ul><li>设 <code>dist[s] = 0</code>（起点到自身的距离为 0），其他所有点 <code>dist[v] = ∞</code>（起始时认为未知）。</li><li>用一个**优先队列（最小堆）**维护当前已发现的最短距离点。</li></ul><ol start="2"><li>贪心扩展：</li></ol><ul><li>每次从<strong>未访问的节点中选取当前 <code>dist[v]</code> 最小的点 <code>u</code></strong>。</li><li>遍历 u的所有邻居 v，尝试松弛：<ul><li><strong>如果 <code>dist[u] + w(u, v) &lt; dist[v]</code>，更新 <code>dist[v]</code></strong>，并将 <code>v</code> 加入优先队列。</li></ul></li></ul><ol start="3"><li>终止：所有节点均已访问，或优先队列为空（所有可达点已确定最短路径）。</li></ol><p>Dijkstra的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Dijkstra(Graph, start):<br>    初始化 dist[]，所有点设为 ∞，dist[start] = 0<br>    初始化优先队列 PQ，插入 (0, start)  // (当前最短距离, 顶点)<br>    初始化 visited[] 记录已确定最短路径的点<br><br>    WHILE PQ 不为空:<br>        (d, u) = PQ.Pop()  // 取出当前最短距离的点<br>        IF u 已访问:<br>            CONTINUE<br>        标记 u 为已访问<br><br>        FOR each 邻居 (v, weight) of u:<br>            IF dist[u] + weight &lt; dist[v]:  // 进行松弛操作<br>                dist[v] = dist[u] + weight<br>                PQ.Push((dist[v], v))  // 将 v 加入优先队列<br>    <br>    RETURN dist[]<br></code></pre></td></tr></table></figure><h2 id="循环桶"><a href="#循环桶" class="headerlink" title="循环桶"></a>循环桶</h2><p><strong>桶（Bucket）</strong> 是一种数据存储和分类的方法，可以根据某种规则（如哈希值、时间、范围等）<strong>将数据映射到不同的桶中</strong>，以加快查询、存储或计算的效率。</p><p>循环桶将数据按照一定规则分配到有限个桶（Bucket）中，并循环使用这些桶。</p><h3 id="循环桶的核心特点"><a href="#循环桶的核心特点" class="headerlink" title="循环桶的核心特点"></a>循环桶的核心特点</h3><ol><li>固定数量的桶（N 个）：<ul><li>设定 <code>N</code> 个桶，编号从 <code>0</code> 到 <code>N-1</code>，它们按照顺序<strong>排列成一个循环结构</strong>。</li><li>访问时<strong>基于取模（modulo）运算</strong>，保证访问永远落在 <code>0 ~ N-1</code> 之间。</li></ul></li><li>循环访问（Modulo 取模）：<ul><li>计算索引 <code>index = (当前时间 t) % N</code>，从而使得时间到了 <code>N</code> 之后会回到 <code>0</code>，形成循环管理。</li></ul></li></ol><h3 id="用循环桶实现Dijkstra算法："><a href="#用循环桶实现Dijkstra算法：" class="headerlink" title="用循环桶实现Dijkstra算法："></a>用循环桶实现Dijkstra算法：</h3><p><strong>CLAIM</strong>：Dijkstra算法中最多只需要C+1个桶。</p><ul><li>永久标记的顶点和非边界顶点不在桶中。</li><li>边界点的距离标记不会超过A[i]+C（i为当前标记点）</li><li>顶点x的桶的编号：A[x]mod(C+1)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Dijkstra_CircularBucket(Graph, start):<br>    初始化 dist[]，所有点设为 ∞，dist[start] = 0<br>    初始化桶 Bucket[]，桶的数量为 C+1，存储每个距离区间的节点<br>    初始化 visited[]，记录顶点是否已被永久标记<br>    <br>    将起点 start 放入 Bucket[0] 中（dist[start] = 0）<br>    <br>    WHILE 有节点未被永久标记:<br>        从桶中找出具有最小距离的非永久标记的边界点 u<br>        标记 u 为永久标记，并从桶中移除 u<br>        <br>        FOR 每个邻居 v of u:<br>            IF v 没有被永久标记:<br>                IF dist[u] + w(u, v) &lt; dist[v]:<br>                    dist[v] = dist[u] + w(u, v)  // 松弛操作<br>                    将 v 放入 Bucket[dist[v] mod (C + 1)] 中  // 根据 dist[v] 放入桶<br>                    更新 v 的距离标记<br><br>    RETURN dist[]<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：O(m+nC)</p><h2 id="Dijsktra算法扩展"><a href="#Dijsktra算法扩展" class="headerlink" title="Dijsktra算法扩展"></a>Dijsktra算法扩展</h2><h3 id="单源单宿最短路问题"><a href="#单源单宿最短路问题" class="headerlink" title="单源单宿最短路问题"></a>单源单宿最短路问题</h3><p>问题描述：给定图G，给定顶点s和d，求从s到d的最小权重路径。</p><p>解决方式：增加一个判断分支，d被永久标记时终止循环。</p><p>1111111111111111</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法与分治&quot;&gt;&lt;a href=&quot;#算法与分治&quot; class=&quot;headerlink&quot; title=&quot;算法与分治&quot;&gt;&lt;/a&gt;算法与分治&lt;/h1&gt;&lt;p&gt;Divide and Conquer（DC）&lt;/p&gt;
&lt;p&gt;Divide：将源问题分解为规模较小的子问题，&lt;stro</summary>
      
    
    
    
    
    <category term="图" scheme="http://example.com/tags/%E5%9B%BE/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
