<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ether Blog</title>
  
  <subtitle>Welcome to Ether Blog !!!</subtitle>
  <link href="http://example.com/rss.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-02-28T03:56:12.346Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Li-shuangyi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络算法基础</title>
    <link href="http://example.com/2025/02/27/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2025/02/27/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2025-02-27T06:35:01.000Z</published>
    <updated>2025-02-28T03:56:12.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法与分治"><a href="#算法与分治" class="headerlink" title="算法与分治"></a>算法与分治</h1><p>Divide and Conquer（DC）</p><p>Divide：将源问题分解为规模较小的子问题，<strong>拆分问题性质相同</strong>，将子问题的解组合成原问题的解。</p><p>Conquer：如果子问题仍然困难，就继续对子问题进行分解，直到子问题可以被trivial。</p><p>Recursion：用递归的方式实现。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>问题定义：</p><ul><li><p>输入：n个数构成的数组;</p></li><li><p>输出：排列该n个数的有序数组。</p></li></ul><p>Merg Sort：</p><ul><li>分解：将原数组等分为两个子数组;</li><li>求解：递归地对两个子数组分别排序;</li><li>合并：将两个已排序的子数组合并。</li></ul><h3 id="Merge-Step"><a href="#Merge-Step" class="headerlink" title="Merge Step"></a>Merge Step</h3><p> <strong>CLAIM</strong>：对于n ≥ 1的数组，MergeSort需要的运行时间T(n) ≤ $ 6n \log_2 n + 6n $</p><img src="/home/qi/my-blog/source/images/网络算法基础/1.PNG" alt="1" style="zoom:50%;" /><h3 id="函数增长的渐进符号"><a href="#函数增长的渐进符号" class="headerlink" title="函数增长的渐进符号"></a>函数增长的渐进符号</h3><p><strong>Big O</strong>: 如果存在正数c和N，对于所有的n&gt;&#x3D;N，有f(n)&lt;&#x3D;c*g(n)，则f(n)&#x3D;O(g(n))。</p><p><strong>Big Omega</strong>：如果存在正数c和N，对于所有的n&gt;&#x3D;N，有f(n)&gt;&#x3D;c*g(n)，则f(n)&#x3D;Omega(g(n))。</p><p><strong>Big Theta</strong>：f(n)&#x3D;Theta(g(n))，当且仅当f(n)&#x3D;O(g(n))且f(n)&#x3D;Omega(g(n))。</p><h3 id="基于比较的排序"><a href="#基于比较的排序" class="headerlink" title="基于比较的排序"></a>基于比较的排序</h3><p><strong>CLAIM</strong>：任何基于比较的排序算法，RT不可能低于O(nlogn)。</p><p>任何基于两两比较的排序算法都可以表达为一棵决策树（完全二叉树）。</p><p>完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。</p><img src="/home/qi/my-blog/source/images/网络算法基础/2.PNG" alt="2" style="zoom:50%;" /><h3 id="主办法（Master-Method）"><a href="#主办法（Master-Method）" class="headerlink" title="主办法（Master Method）"></a>主办法（Master Method）</h3><p><strong>主定理</strong></p><img src="/home/qi/my-blog/source/images/网络算法基础/3.PNG" alt="3" style="zoom:50%;" /><img src="/home/qi/my-blog/source/images/网络算法基础/5.PNG" alt="5" style="zoom:50%;" /><img src="/home/qi/my-blog/source/images/网络算法基础/4.PNG" alt="4" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法与分治&quot;&gt;&lt;a href=&quot;#算法与分治&quot; class=&quot;headerlink&quot; title=&quot;算法与分治&quot;&gt;&lt;/a&gt;算法与分治&lt;/h1&gt;&lt;p&gt;Divide and Conquer（DC）&lt;/p&gt;
&lt;p&gt;Divide：将源问题分解为规模较小的子问题，&lt;stro</summary>
      
    
    
    
    
    <category term="图" scheme="http://example.com/tags/%E5%9B%BE/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
