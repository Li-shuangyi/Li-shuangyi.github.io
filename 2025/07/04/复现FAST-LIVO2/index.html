<!DOCTYPE html>
<html lang="en">
<style>
    p{
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
        font-size: 1.1rem;
    }
    figure{
        margin: 0 !important;
    }
    pre{
        padding: 0 !important;
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
    }

    td{
        padding: 0 !important;
        margin-bottom: 1rem !important;
    }
    h1,h2,h3,h4,h5,h6{
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
    }
    @media (min-width: 1024px) {
        #middle-box{
            min-width: 56rem;
        }
    
    }
</style>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ether Blog - 复现FAST-LIVO2</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/tailwind.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/toc.css">
    
<header class="bg-black text-hacker-white py-4 font-dos font-extrabold">
    <div class="container mx-auto flex items-center justify-between space-x-8">
    
      <h1 class="text-2xl font-bold ml-[100px] md:ml-0 animate-pulse text-hacker-color1 md:mr-[20%]">
        <a href="/" class="hover:text-white transition-colors select-none">
          Ether Blog
        </a>
      </h1>
  
    <!-- 大屏幕 -->
      <nav class="hidden md:block">
        <ul class="flex space-x-6">
          
            <li>
              <a href="/" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Home
              </a>
            </li>
          
            <li>
              <a href="/archives/" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Archives
              </a>
            </li>
          
            <li>
              <a href="/categories/" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Categories
              </a>
            </li>
          
            <li>
              <a href="/tags/" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Tags
              </a>
            </li>
          
            <li>
              <a href="/about/" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                About
              </a>
            </li>
          
            <li>
              <a href="/rss.xml" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                RSS
              </a>
            </li>
          
        </ul>
      </nav>
  
      <!-- 小屏幕 -->
      <button id="menu-toggle" class="block md:hidden text-white focus:outline-none">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16"></path>
        </svg>
      </button>
    </div>
  
    <!-- 折叠菜单 -->
    <nav id="mobile-menu" class="hidden bg-black">
      <ul class="space-y-2 py-4 px-6">
        
          <li>
            <a href="/" class="block text-white hover:text-hacker-color1 transition-colors">
              Home
            </a>
          </li>
        
          <li>
            <a href="/archives/" class="block text-white hover:text-hacker-color1 transition-colors">
              Archives
            </a>
          </li>
        
          <li>
            <a href="/categories/" class="block text-white hover:text-hacker-color1 transition-colors">
              Categories
            </a>
          </li>
        
          <li>
            <a href="/tags/" class="block text-white hover:text-hacker-color1 transition-colors">
              Tags
            </a>
          </li>
        
          <li>
            <a href="/about/" class="block text-white hover:text-hacker-color1 transition-colors">
              About
            </a>
          </li>
        
          <li>
            <a href="/rss.xml" class="block text-white hover:text-hacker-color1 transition-colors">
              RSS
            </a>
          </li>
        
      </ul>
    </nav>
  
    <!-- RSS Link -->
    <link rel="alternate" type="application/rss+xml" title=" RSS" href="/rss.xml" />
  </header>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="/js/search.js"></script>
  <script>
        document.addEventListener("DOMContentLoaded", () => {
    const menuToggle = document.getElementById("menu-toggle");
    const mobileMenu = document.getElementById("mobile-menu");

    menuToggle.addEventListener("click", () => {
        if (mobileMenu.classList.contains("hidden")) {
        mobileMenu.classList.remove("hidden");
        } else {
        mobileMenu.classList.add("hidden");
        }
    });
    });

  </script>
  

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>
<body class="bg-black text-hacker-color3 container mx-auto" style="overflow-x:hidden">
    <!-- 文章标题 -->
    <h1 class="text-5xl text-hacker-color1 font-bold font-dos my-6 text-center">复现FAST-LIVO2</h1>

    <!-- 发布时间 -->
    <p class="text-hacker-color3 text-center text-sm mb-4">
        2025-07-04
    </p>

    <!-- 文章内容 -->
    <div id="article-content" class="article-entry prose prose-invert mx-auto max-w-4xl leading-relaxed highlight" style="display: flex;">
        <div id="middle-box">
            <h1 id="项目名称-FAST-LIVO2复现"><a href="#项目名称-FAST-LIVO2复现" class="headerlink" title="项目名称 : FAST-LIVO2复现"></a>项目名称 : FAST-LIVO2复现</h1><h2 id="任务规划"><a href="#任务规划" class="headerlink" title="任务规划"></a>任务规划</h2><ul>
<li><p>设备:</p>
<ol>
<li>Livox AVIA</li>
<li>Livox Converter 2.0</li>
<li>海康相机MV-CS020-10UC</li>
</ol>
</li>
<li><p>硬件:</p>
<ol>
<li><p>手持设备支架设计(Solidworks)</p>
</li>
<li><p>STM32硬同步流程</p>
</li>
<li><p>相机-Lidar标定</p>
</li>
</ol>
</li>
<li><p>软件:</p>
<ol>
<li>环境,build</li>
<li>录包,跑包</li>
</ol>
</li>
</ul>
<h2 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h2><h3 id="FAST-LIVO"><a href="#FAST-LIVO" class="headerlink" title="FAST-LIVO"></a>FAST-LIVO</h3><ul>
<li><p>LIO 子系统: 反向传播补偿 LiDAR 扫描的运动畸变,计算帧到地图点到平面的残差。</p>
</li>
<li><p>VIO 子系统: 提取当前 FoV 中的视觉子映射,剔除异常值。</p>
</li>
<li><p>视觉对齐: 稀疏直接图像对齐,比较光流误差。</p>
</li>
<li><p>紧密耦合: 点到平面残差和图像光度误差与误差状态iKF中的IMU传播紧密耦合。</p>
</li>
<li><p>ikdTree添加新点至全局映射。</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/1.png" alt="图1-FAST-LIVO系统概述图"></p>
<p style="text-align:center;">图1-FAST-LIVO系统概述图</p></li>
</ul>
<h3 id="FAST-LIVO2"><a href="#FAST-LIVO2" class="headerlink" title="FAST-LIVO2"></a>FAST-LIVO2</h3><h4 id="新贡献"><a href="#新贡献" class="headerlink" title="新贡献"></a>新贡献</h4><ol>
<li><p>问题 : 激光雷达和视觉测量之间维度不匹配 (测量维度 &#x2F; 数据类型 &#x2F; 分布特性) , 而 FAST-LIVO中使用异步更新。</p>
<p>解决方案 : ESIKF框架,惯顺序更新(sequential update)。</p>
</li>
<li><p>问题 : FAST-LIVO中假设图像块中所有像素共享相同深度,该假设降低了对齐中仿射变换的准确性。</p>
<p>解决方案 : 使用并进一步优化来自激光雷达点的平面先验。</p>
</li>
<li><p>问题: FAST-LIVO 基于与当前视图的接近度选择参考块,导致参考块低质量,降低了准确性。</p>
<p>解决方案 : 提出了一种参考块 Reference Patch 更新策略 ,通过选择具有大视差和足够纹理细节的高质量内点参考块提高图像对齐的准确性。</p>
</li>
<li><p>问题 : 环境光照变化会降低图像对齐中的收敛性,FAST-LIVO中未解决该问题。</p>
<p>解决方案 : 在线曝光时间估计。</p>
</li>
<li><p>问题 : 激光雷达近距离盲区造成激光雷达点测量缺失,FAST-LIVO中未考虑该问题。</p>
<p>解决方案 : 提出按需进行体素射线投射的方法，以增强系统在因激光雷达近距离盲区造成的激光雷达点测量缺失情况下的鲁棒性。 </p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/34.png" alt="图2-FAST-LIVO2系统概述图"></p>
</li>
</ol>
<p style="text-align:center;">图2-FAST-LIVO2系统概述图</p>												

<h4 id="Section-4-顺序更新的ESIKF"><a href="#Section-4-顺序更新的ESIKF" class="headerlink" title="Section 4 顺序更新的ESIKF"></a>Section 4 顺序更新的ESIKF</h4><ol>
<li><p>扫描重组 Scan Recombination</p>
<ol>
<li><p>将$t_k-1$时刻到$t_k$时刻的所有激光点都合并到$t_k$时刻。</p>
<p>将高频、连续采样的LiDAR原始点云数据，按照相机采样时刻进行分割，从而得到与相机采样时刻对应的独立LiDAR扫描帧。    </p>
</li>
<li><p>通过硬同步使雷达和相机采样一致</p>
<p>激光雷达和相机在$t_k-1$ 时刻同时触发采集，但相机在瞬间完成采集，激光雷达则在$t_k$时刻才完成一帧数据。虽然触发时间相同，系统实际处理的是$t_k$时刻图像与延迟 $t$ (约100ms) 的激光雷达帧。</p>
</li>
</ol>
</li>
<li><p>传播 Propagation</p>
</li>
</ol>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/35.png" alt="图3-前向传播与反向传播示意图"></p>
<p style="text-align:center;">图3-前向传播与反向传播示意图</p>									

<p>​	1. 前向传播：KF在预测阶段将噪声$W_i$ 设为0，预测$t_k-1$ 到$t_k$ 这段时间每个IMU输入时的状态。由KF预测可得	此时状态量为$\hat{x}$，状态量对应的协方差$\hat{P}$作为更新阶段的先验。</p>
<p>​	2. 反向传播 : 补偿激光雷达运动畸变，确保所有的点都是在tk时刻观测到的。</p>
<p>​	运动畸变 : 由于激光雷达在移动过程中分时采点，若忽略每个点的具体采集时间,统一视为同一时刻采样，会导致	点云在空间上的扭曲或错位。</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/36.png" alt="图4-反向传播示意图"></p>
<p style="text-align:center;">图4-反向传播示意图</p>

<p>​	3. 顺序更新 : 利用激光雷达测量细化的状态将被更新地图的几何结构，该状态将在视觉更新被进一步收敛，其中	视觉更新将在每个金字塔层面上进行，每层都要收敛。最终得到的状态被用于传播新到来的IMU测量，并更新地	图的视觉结构（纹理）。</p>
<h4 id="Section-5-局部建图"><a href="#Section-5-局部建图" class="headerlink" title="Section 5 局部建图"></a>Section 5 局部建图</h4><ol>
<li><p>地图结构 Map Structure</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/37.png" alt="图5-Voxel Map示意图"></p>
<p style="text-align:center;">图5-Voxel Map示意图</p></li>
</ol>
<p>​	<strong>自适应体素结构</strong>,按照哈希表和每个哈希条目的八叉树组织。</p>
<p>​	哈希表管理根体素,每一个根体素为0.5x0.5x0.5m的固定维度,每个根体素包含一个八叉树结构。叶体素代表一个局部平面,存储一个平面特征(即平面中心、法向量和不确定性),以及一组位于该平面上的激光雷达原始点。<strong>叶体素的不同大小使其能够表示不同尺度的局部平面,从而适应具有不同结构的环境</strong>。部分点与三级图像块(8×8图块大小)相连(即视觉地图点),收敛的视觉地图点仅与参考块关联，未收敛的点与参考块和其他可见块都关联。</p>
<p>​	为了防止地图大小无限增长,设置初始地图范围后, 在该范围进行进行探测和建图，当雷达探测范围触碰到范围边界，局部地图范围会在该边界方向上移动d距离。存储的A处点云数据将被重置为C处的数据,保持内存大小固定。每次ESIKF更新后检查一次地图是否移动。</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/38.png" alt="图6-局部地图滑动示意图"></p>
<p style="text-align:center;">图6-局部地图滑动示意图</p>

<p><em>在(a)中,灰色矩形是初 始地图区域,长度为 L。红色圆圈是以 p0 为中心的初始 检测区域。在(b)中,检测区域移动到新位置 p1,在此位 置触碰到地图边界。地图区域移动到新位置(蓝色矩形) ,移动距离为 d。在(c)中,内存空间B保持不变。存储绿色区域的内存空间A被重置为(b)中的蓝色区域C。</em></p>
<ol start="2">
<li><p>几何构造及更新 : <strong>基于ESIKF对激光雷达点测量构建和更新实现</strong>	<a name="Section5-2"></a></p>
<p>在ESIKF中的激光雷达更新后,将激光雷达扫描的所有点注册到全局坐标系中。对于每个注册的激光雷达点,确定其在哈希图中的根体素位置。</p>
<ul>
<li><p>如果不存在,用新点初始化该体素并将其索引到哈希图中。</p>
</li>
<li><p>如果确定的体素已经存在于地图中, 将该点附加到现有体素中。</p>
</li>
</ul>
<p>在所有扫描中的点分配完成后,进行几何构建和更新。</p>
<ol>
<li><p>对于新创建的体素</p>
<p>通过奇异值分解来确定其所有包含的点是否位于一个平面上。</p>
<ul>
<li>如果是,计算中心点 $ q &#x3D; p ̄$ 、平面法线 $n$ 和平面的协方差矩阵$ Σ_{n,q} $。$ Σ_{n,q} $ 用于表征平面不确定性 (平面不确定性源于姿态估计的不确定性和点测量噪声)。</li>
<li>如果不是,体素将不断细分为八个更小的八分体,直到子体素中的点被确定为形成一个平面或达到最大层数。达到最大层数后,叶体素中的点将被丢弃。</li>
<li><strong>地图仅包含被识别为平面的体素(根体素或子体素)。</strong></li>
</ul>
</li>
<li><p>对于已存在的体素</p>
<p>评估新的点和已有的点能否构建为一个平面</p>
<ul>
<li>如果否：和前面一样，对体素进行划分。</li>
<li>如果是：更新平面参数和协方差。</li>
<li><strong>一旦平面参数是收敛的，该平面将被视为成熟面，平面参数将被视为固定，平面上的新点将被丢弃。</strong></li>
</ul>
</li>
<li><p>平面上的激光雷达点生成视觉地图点</p>
<ul>
<li><p>对于成熟的平面,最近的50个雷达点是生成视觉地图点的候选者。</p>
</li>
<li><p>对于未成熟的平面,所有雷达点都是候选者。</p>
</li>
<li><p>视觉地图点生成过程将识别其中一些候选点作为视觉地图点,并将它们与图像块附加以进行图像对齐。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>视觉地图点生成和更新</p>
<p>选择地图中的候选激光雷达点用于生成和更新。(<a href="#Section7-1">详见第Section 7-1</a>)</p>
<p>候选点条件:</p>
<ol>
<li>在当前帧视角可见</li>
<li>在当前图像中表现出显著灰度梯度</li>
</ol>
<p>在视觉更新后,将候选点投影到当前图像上,并<strong>在每个体素中保留最小深度的候选点作为局部平面。将当前图像划分为每个30 × 30像素的均匀网格单元。</strong></p>
<ul>
<li><p>若一个栅格元没有包含任何投影到这的视觉地图点,则使用<strong>带有最高灰度梯度的候选点新建一个新的视觉地图点</strong>。将该点与当前图像块、估计的当前状态（位姿&#x2F;曝光时间）以及平面法向量相关联。与视觉地图点相关联的块有三个相同大小的层（每层11x11像素）,构成块金字塔。</p>
</li>
<li><p>若一个栅格元包含了投影的视觉地图点，并满足以下条件之一就添加新的块到当前视觉地图点上:</p>
<ol>
<li>超过20帧没有添加新的块到视觉地图点。</li>
<li>视觉地图点在当前帧中的像素位置比其在上一个块的位置相差至少40像素（晃得太厉害，点在屏幕里移动了一大段距离，重新拍一张）。</li>
</ol>
</li>
</ul>
<p><strong>地图点将拥有视角分布均匀的有效块Patch。</strong></p>
</li>
<li><p>Reference Patch 参考块更新 : 一个视觉地图点会拥有不止一个块。需要选择一个作为参考块用于视觉更新中的图像对齐，基于光度相似性和视角给每个块 f 评分。在所有附加到视觉地图点的Patch中,得分最高的Patch被更新为参考块。</p>
</li>
</ol>
<p>   上述评分机制倾向于选择:</p>
<pre><code>	1. 外观与大多数其他补丁相似(以NCC为标准)的参考补丁, 以避免动态目标上的补丁;
	2. 视角方向与平面正交,从而在高分辨率下保持纹理细节。
</code></pre>
<p>   FAST-LIVO 中的参考块更新策略直接选择与当前帧视角方向差异最小的补丁,导致所选参考补丁与当前帧非常接近,从而对当前姿态更新施加了弱约束。</p>
<ol start="5">
<li><p>法向量细化</p>
<p>每个视觉地图点都被假设位于一个小的局部平面上。（以前的研究假设像素块上的所有像素拥有同样深度）</p>
<p>使用源于雷达点的平面参数取得更好的精度<a href="#Section5-2">(详见第Section 5-2)</a>。 </p>
<p>平面法向量对于视觉更新过程中的图像仿射变换对齐至关重要,平面法向量细化能够增强仿射变换的精度。 </p>
<p>具体：<strong>通过最小化参考块与视觉地图点关联的其他块之间的光度误差，来优化参考块中的平面法向量。</strong></p>
</li>
</ol>
<h4 id="Section-6-激光雷达测量模型"><a href="#Section-6-激光雷达测量模型" class="headerlink" title="Section 6 激光雷达测量模型"></a>Section 6 激光雷达测量模型</h4><p>用于ESIKF LiDAR更新的LiDAR测量模型$y_l &#x3D; h_l(x, v_l)$。</p>
<ol>
<li><p>点到平面的雷达测量模型</p>
<ul>
<li><p>投影无畸变点到世界系;</p>
</li>
<li><p>确定该世界点所在哈希图的根&#x2F;子体素，并构建观测公式</p>
<p>如果没有体素被发现或该体素不包含平面则丢弃该点。 否则，构建该体素中平面与这个点的观测公式。 假设一个激光真值点，准确的到世界系变换阵，这个点与平面中心点应该是在一个平面上的。</p>
</li>
<li><p>带入激光点测量和噪声，平面法向量估计和中心点估计及协方差,</p>
<p>得到测量噪声的形式:$v_l&#x3D;(δ^L\mathbf{p}_j,δ\mathbf{n}_j,δ\mathbf{q}_j)$</p>
</li>
</ul>
</li>
<li><p>带有光束发散效应的Lidar测量噪声</p>
<p>测量噪声主要由两个元素构成，飞行时间导致的测距不确定性和编码导致的轴承方向不确定性，除此外，还有激光的发散角度。随着方位方向与法向量之间的角度 $φ$的增加，激光雷达点的测距不确定性显著增加，而方位方向的不确定性不受影响。当从地面和墙面选的点更多时，位姿估计的精度更高。 <strong>$φ$越小越好</strong>。</p>
</li>
</ol>
<h4 id="Section-7-视觉测量模型"><a href="#Section-7-视觉测量模型" class="headerlink" title="Section 7 视觉测量模型"></a>Section 7 视觉测量模型</h4><p>用于ESIKF视觉更新的视觉测量模型$y_c &#x3D; h_c(x, v_c)$。</p>
<p>1.视觉地图点选择<a name="Section7-1"></a></p>
<p>为了视觉更新中的稀疏对齐，首先选择合适的视觉地图点。 </p>
<ul>
<li><p>使用体素和投射查询来提取当前相机FoV中的可见的地图点集合（视觉的子地图）。 </p>
</li>
<li><p>来自这个子地图中视觉地图点将被挑选并剔除离群点。 </p>
</li>
<li><p>这个过程能够为<strong>视觉测量模型中构建视觉光度误差提供一个精细的视觉地图点集合</strong>。</p>
<ol>
<li><p>可见体素的查询 : </p>
<p>问题: 地图中体素数量庞大,从地图中的大量体素中确定当前帧FoV中的地图体素困难。</p>
<p>解决：利用当前LiDAR扫描直接命中的体素作为候选，大幅减少需处理的体素数量。 </p>
<p>实现：1、使用测量的点位置来查询体素哈希表</p>
<p>​       2、筛选上一图像帧中通过相同体素查询和光线投射确认为可见的地图点所命中的体素。 </p>
<p>最后,通过检查这两种体素中包含的地图点并进行视场检查,得到当前的视觉子图。</p>
</li>
<li><p>按需投射 :</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/39.png" alt="图7-按需体素光线投射的示意图"></p>
<p style="text-align:center;">图7-按需体素光线投射的示意图</p>

<p>当雷达距离目标太近而没有点返回时&#x2F;摄像机FOV可能不会被激光雷达FOV完全覆盖。流程如下 :</p>
<ol>
<li><p>图像划分<br>将图像划分为30x30的均匀栅格元，投影体素查询获得的视觉地图点到栅格元上。</p>
</li>
<li><p>对未被占据栅格元的射线投射<br>对于每个未被视觉地图点占据的栅格元，光线沿着中心像素向后投射，其中采样点沿着光线在深度方向上从dmin到dmax均匀分布</p>
</li>
<li><p>降低计算量<br>相机机体系下每个光线上的采样点的位置都被预先算好了。</p>
</li>
<li><p>处理每个采样点<br>对每个采样点，评估其对应的体素状态：<br>若该体素包含投影后位于此网格单元内的地图点，则将这些地图点纳入视觉子地图，并终止当前射线的处理。<br>否则：继续射线上的下一个采样点，直到达到最大深度DMAX。</p>
</li>
<li><p>所有未被占据栅格元处理完成<br>获得了一组在整个图像上分布的视觉地图点集合。</p>
</li>
</ol>
</li>
<li><p>视觉地图点中离群点剔除</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/40.png" alt="图8-剔除离群点示意图"></p>
<p style="text-align:center;">图8-剔除离群点示意图</p>

<p>存在的问题: 将会严重降低图像对齐精度</p>
<p>​    (1) 在当前帧中被遮挡</p>
<p>​    (2) 存在深度不连续性</p>
<p>​    (3) 拥有这些点的参考块采集视角过大</p>
<p>​    (4) 在当前帧中观测视角过大</p>
<ol>
<li><p>投影所有点–解决问题1</p>
<p>在雷达更新后，将子图中的所有视觉地图点用位姿投影至当前帧，并在每个栅格元中保留深度最小的点。</p>
</li>
<li><p>深度图–解决问题2</p>
<p>将当前雷达帧的点投影至当前帧生成深度图，用9x9的邻域在深度图中比较视觉地图点的深度，并判断遮挡和深度变化。被占据的&#x2F;深度不连续的点将被剔除。</p>
</li>
<li><p>点移除–解决问题3&amp;4</p>
<p>移除参考块与当前块的视角太大（法向量与从视觉地图点到块光学中心的方向之间的角度超过80°）的点。</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<ol start="2">
<li>稀疏直接的视觉测量模型</li>
</ol>
<p>上面提取的视觉地图点 {$G_{pi}$} 用于构建视觉测量模型。 其基本原理是,利用真值状态将地图点投影至当前图像，参考块与当前块之间的光度误差应当为0. </p>
<p>要根据测量方程估算反向曝光时间 $τ_k$，将初始反向曝光时间固定为 $τ_0$ &#x3D; 1 ，以消除方程在所有反向曝光时间都为零时的退化现象。后续帧的估计反向曝光时间是相对于第一帧的曝光时间。测量方程被用于三个层次的视觉更新步骤,估计的状态随后用于生成可视化地图点和更新参考块。</p>
<h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><p>雷达点云格式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// roslaunch livox_ros_driver livox_lidar.launch / livox_ros_driver2所有launch</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LivoxPoint</span> &#123;<br>    <span class="hljs-type">float</span> x;<br>    <span class="hljs-type">float</span> y;<br>    <span class="hljs-type">float</span> z;<br>    <span class="hljs-type">uint8_t</span> reflectivity;   <span class="hljs-comment">// 反射率</span><br>    <span class="hljs-type">uint8_t</span> tag;            <span class="hljs-comment">// 标志位</span><br>    <span class="hljs-type">uint8_t</span> line;           <span class="hljs-comment">// 扫描线编号</span><br>&#125;;<br><br><span class="hljs-comment">// roslaunch livox_ros_driver livox_lidar_msg.launch</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CustomMsg</span> &#123;<br>    <span class="hljs-type">uint64_t</span> timebase;      <span class="hljs-comment">// 当前包的基准时间</span><br>    <span class="hljs-type">uint32_t</span> point_num;     <span class="hljs-comment">// 点数</span><br>    <span class="hljs-type">uint8_t</span>  lidar_id;      <span class="hljs-comment">// 雷达ID</span><br>    <span class="hljs-type">uint8_t</span>  rsvd[<span class="hljs-number">3</span>];       <span class="hljs-comment">// 保留</span><br>    std::vector&lt;LivoxPoint&gt; points;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>结构体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StatesGroup</span><br>&#123;<br>    M3D rot_end;     <span class="hljs-comment">// 姿态（旋转矩阵），表示当前时刻的坐标系方向</span><br>    V3D pos_end;     <span class="hljs-comment">// 位置（世界系坐标）</span><br>    V3D vel_end;     <span class="hljs-comment">// 速度（世界系坐标）</span><br>    <span class="hljs-type">double</span> inv_expo_time; <span class="hljs-comment">// 逆曝光时间 (通常和相机或雷达扫描速度相关)</span><br>    V3D bias_g;      <span class="hljs-comment">// 陀螺仪零偏</span><br>    V3D bias_a;      <span class="hljs-comment">// 加速度计零偏</span><br>    V3D gravity;     <span class="hljs-comment">// 重力向量（世界坐标系下的估计）</span><br>    Matrix&lt;<span class="hljs-type">double</span>, DIM_STATE, DIM_STATE&gt; cov; <span class="hljs-comment">// 状态协方差</span><br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="LIVMapper-h-LIVMapper-cpp"><a href="#LIVMapper-h-LIVMapper-cpp" class="headerlink" title="LIVMapper.h &#x2F; LIVMapper.cpp"></a>LIVMapper.h &#x2F; LIVMapper.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">LIVMapper类：<br><span class="hljs-comment">//------------初始化----------------------</span><br><span class="hljs-comment">// 初始化Subscribers和Publishers</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LIVMapper::initializeSubscribersAndPublishers</span><span class="hljs-params">(ros::NodeHandle &amp;nh, image_transport::ImageTransport &amp;it)</span></span>;<br><span class="hljs-comment">// 初始化参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LIVMapper::initializeComponents</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 文件初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initializeFiles</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 对齐重力</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LIVMapper::gravityAlignment</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 处理第一帧</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleFirstFrame</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 选择当前模式（LIO/VIO/LIVO）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stateEstimationAndMapping</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 处理VIO帧外部接口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleVIO</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 处理LIO帧外部接口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleLIO</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 处理IMU数据外部接口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processImu</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    sync_packages → 时间切割LiDAR → 数据准备 → handleLIO → SLAM处理</span><br><span class="hljs-comment">                                          ↓</span><br><span class="hljs-comment">                                      handleVIO → 视觉处理</span><br><span class="hljs-comment">**/</span><br><span class="hljs-comment">// 多传感器数据同步</span><br><span class="hljs-comment">// LIO处理：IMU切分</span><br><span class="hljs-comment">// VIO处理：图像时间同步至LIO</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sync_packages</span><span class="hljs-params">(LidarMeasureGroup &amp;meas)</span></span>;<br><span class="hljs-comment">// 前向传播</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prop_imu_once</span><span class="hljs-params">(StatesGroup &amp;imu_prop_state, <span class="hljs-type">const</span> <span class="hljs-type">double</span> dt, V3D acc_avr, V3D angvel_avr)</span></span>;<br><span class="hljs-comment">// imu状态传播回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">imu_prop_callback</span><span class="hljs-params">(<span class="hljs-type">const</span> ros::TimerEvent &amp;e)</span></span>;<br><br><span class="hljs-comment">// 将LiDAR点云从机体坐标系变换到世界坐标系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transformLidar</span><span class="hljs-params">(<span class="hljs-type">const</span> Eigen::Matrix3d rot, <span class="hljs-type">const</span> Eigen::Vector3d t, <span class="hljs-type">const</span> PointCloudXYZI::Ptr &amp;input_cloud, PointCloudXYZI::Ptr &amp;trans_cloud)</span></span>;<br><span class="hljs-comment">// 将单个点云从机体坐标系变换到世界坐标系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pointBodyToWorld</span><span class="hljs-params">(<span class="hljs-type">const</span> PointType &amp;pi, PointType &amp;po)</span></span>;<br><span class="hljs-comment">// 将单个RGB点云从机体坐标系变换到世界坐标系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RGBpointBodyToWorld</span><span class="hljs-params">(PointType <span class="hljs-type">const</span> *<span class="hljs-type">const</span> pi, PointType *<span class="hljs-type">const</span> po)</span></span>;<br><br><span class="hljs-comment">// 点云回调函数</span><br><span class="hljs-comment">// LivoxPoint格式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">standard_pcl_cbk</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::PointCloud2::ConstPtr &amp;msg)</span></span>;<br><span class="hljs-comment">// CustomMsg格式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">livox_pcl_cbk</span><span class="hljs-params">(<span class="hljs-type">const</span> livox_ros_driver::CustomMsg::ConstPtr &amp;msg_in)</span></span>;<br><br><span class="hljs-comment">// imu回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">imu_cbk</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::Imu::ConstPtr &amp;msg_in)</span></span>;<br><span class="hljs-comment">// 图像回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">img_cbk</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::ImageConstPtr &amp;msg_in)</span></span>;<br></code></pre></td></tr></table></figure>



<h3 id="IMU-Processing-h-IMU-Processing-cpp"><a href="#IMU-Processing-h-IMU-Processing-cpp" class="headerlink" title="IMU_Processing.h &#x2F; IMU_Processing.cpp"></a>IMU_Processing.h &#x2F; IMU_Processing.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 结构体 class ImuProcess</span><br><br><span class="hljs-comment">//  IMU数据处理主函数（外部接口）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ImuProcess::Process2</span><span class="hljs-params">(LidarMeasureGroup &amp;lidar_meas, StatesGroup &amp;stat, PointCloudXYZI::Ptr cur_pcl_un_)</span></span>;<br><span class="hljs-comment">// 点云去畸变（前向传播+反向传播）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ImuProcess::UndistortPcl</span><span class="hljs-params">(LidarMeasureGroup &amp;lidar_meas, StatesGroup &amp;state_inout, PointCloudXYZI &amp;pcl_out)</span></span>;<br></code></pre></td></tr></table></figure>



<h3 id="vio-h-vio-cpp"><a href="#vio-h-vio-cpp" class="headerlink" title="vio.h &#x2F; vio.cpp"></a>vio.h &#x2F; vio.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 结构体 VIOManager</span><br><br><span class="hljs-comment">// 更新当前帧，将系统的IMU状态转换为相机帧的变换矩阵</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VIOManager::updateFrameState</span><span class="hljs-params">(StatesGroup state)</span></span>;<br><br><span class="hljs-comment">// 网格</span><br><span class="hljs-comment">// 特征检测：新帧图像 → 网格划分 → 每个网格内检测特征 → 控制特征密度</span><br><span class="hljs-comment">// 特征匹配：当前帧特征 → 定位网格 → 在对应网格内搜索匹配 → 提高匹配效率</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VIOManager::processFrame</span><span class="hljs-params">(cv::Mat &amp;img, vector&lt;pointWithVar&gt; &amp;pg, <span class="hljs-type">const</span> unordered_map&lt;VOXEL_LOCATION, VoxelOctoTree *&gt; &amp;feat_map, <span class="hljs-type">double</span> img_time)</span></span>;<br></code></pre></td></tr></table></figure>



<h3 id="订阅器"><a href="#订阅器" class="headerlink" title="订阅器"></a>订阅器</h3><p><strong>sub_pcl</strong><br>livox_pcl_cbk() - Livox LiDAR回调函数</p>
<ul>
<li>功能：处理Livox品牌激光雷达的自定义点云消息</li>
<li>消息类型：livox_ros_driver::CustomMsg</li>
</ul>
<p>standard_pcl_cbk()- 标准点云回调函数</p>
<ul>
<li>功能：处理标准ROS点云消息（如Velodyne、Ouster等）</li>
<li>消息类型：<code>sensor_msgs::PointCloud2</code></li>
</ul>
<p><strong>sub_imu</strong></p>
<p>imu_cbk() - IMU回调函数</p>
<ul>
<li>功能：处理惯性测量单元数据</li>
<li>消息类型：sensor_msgs::Imu</li>
</ul>
<p><strong>sub_img</strong></p>
<p>img_cbk() - 图像回调函数</p>
<ul>
<li>功能：处理相机图像数据</li>
<li>消息类型：sensor_msgs::Image</li>
</ul>
<h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LIVMapper <span class="hljs-title">mapper</span><span class="hljs-params">(nh)</span></span>; <br>mapper.<span class="hljs-built_in">initializeSubscribersAndPublishers</span>(nh, it);<br>mapper.<span class="hljs-built_in">run</span>();				<br></code></pre></td></tr></table></figure>



<p><strong>雷达-相机外参用于VIO（第5&#x2F;7部分）</strong></p>
<p>函数setLidarToCameraExtrinsic</p>
<h2 id="本机环境-和Fast-Livo2无关"><a href="#本机环境-和Fast-Livo2无关" class="headerlink" title="本机环境 (和Fast-Livo2无关)"></a>本机环境 (和Fast-Livo2无关)</h2><p>只是电脑又坏了。</p>
<ol>
<li><p>NVIDIA驱动 : </p>
<ul>
<li><p><strong>关闭bios security boot</strong></p>
</li>
<li><p>在命令行模式下删除之前安装的nvidia驱动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Ctrl + Alt + F3<br>sudo systemctl stop gdm<br>sudo apt-get purge &#x27;^nvidia-.*&#x27;<br>sudo apt-get autoremove<br>sudo rm -rf /etc/X11/xorg.conf<br>sudo rm -rf /lib/modules/$(uname -r)/kernel/drivers/video/nvidia*<br>sudo rm -rf /usr/src/nvidia*<br>sudo rm -rf /usr/share/doc/NVIDIA_GLX-1.0*<br>sudo rm -rf /usr/share/man/man1/nvidia*<br>sudo rm -rf /usr/bin/nvidia*<br>sudo rm -rf /etc/modprobe.d/blacklist-nvidia.conf<br></code></pre></td></tr></table></figure>
</li>
<li><p>重新安装,选择recommend的版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo ubuntu-drivers devices # 查看可以使用的驱动版本<br></code></pre></td></tr></table></figure>
</li>
<li><p>重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reboot<br></code></pre></td></tr></table></figure>
</li>
<li><p>检查</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nvidia-smi<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="NUC环境搭建"><a href="#NUC环境搭建" class="headerlink" title="NUC环境搭建"></a>NUC环境搭建</h2><h3 id="1-修网卡"><a href="#1-修网卡" class="headerlink" title="1. 修网卡"></a>1. 修网卡</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">fast@fast:~/WIFI/backport-iwlwifi$ lspci | grep -i wireless<br>fast@fast:~/WIFI/backport-iwlwifi$ lsmod | grep iwl<br></code></pre></td></tr></table></figure>

<p>系统没有识别出无线网卡设备,疑似硬件问题.最后使用网线上网.</p>
<h3 id="2-依赖项"><a href="#2-依赖项" class="headerlink" title="2. 依赖项"></a>2. 依赖项</h3><ul>
<li><p>PCL&gt;&#x3D;1.8, Follow <a target="_blank" rel="noopener" href="https://pointclouds.org/">PCL Installation</a>.</p>
</li>
<li><p>Eigen&gt;&#x3D;3.3.4, Follow <a target="_blank" rel="noopener" href="https://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen Installation</a>.</p>
</li>
<li><p>OpenCV&gt;&#x3D;4.2, Follow <a target="_blank" rel="noopener" href="http://opencv.org/">Opencv Installation</a>.</p>
</li>
<li><p>Livox_SDK2 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/Livox-SDK/Livox-SDK2.git<br>cd ./Livox-SDK2/<br>mkdir build<br>cd build<br>cmake .. &amp;&amp; make -j<br>sudo make install<br></code></pre></td></tr></table></figure>
</li>
<li><p>Sophus : Sophus Installation for the non-templated&#x2F;double-only version.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/strasdat/Sophus.git<br>cd Sophus<br>git checkout a621ff<br>mkdir build &amp;&amp; cd build &amp;&amp; cmake ..<br>make<br>sudo make install<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-工作空间配置"><a href="#3-工作空间配置" class="headerlink" title="3. 工作空间配置"></a>3. 工作空间配置</h3><p>Avia只支持livox_ros_driver</p>
<p>livox_ros_driver可以不着急先编译,等最后一起build</p>
<ul>
<li><p>FAST_LIVO2 : <a target="_blank" rel="noopener" href="https://github.com/hku-mars/FAST-LIVO2.git">https://github.com/hku-mars/FAST-LIVO2.git</a></p>
</li>
<li><p>livox_ros_ driver :  <a target="_blank" rel="noopener" href="https://github.com/xuankuzcr/LIV_handhold.git">https://github.com/xuankuzcr/LIV_handhold.git</a></p>
<p> <a href="#change">&lt;说明&gt;</a>硬同步需要使用这个github库中的livox_ros_driver,<strong>对比官方,这里做了硬同步的改动，增加了对共享内存写入时间戳的功能</strong> </p>
</li>
<li><p>mvs_ros_pkg : <a target="_blank" rel="noopener" href="https://github.com/xuankuzcr/LIV_handhold.git">https://github.com/xuankuzcr/LIV_handhold.git</a> 	<a name="mvs_ros_pkg"></a></p>
<p> &lt;说明&gt;硬同步需要使用这个github库中的相机ros驱动</p>
</li>
<li><p>rpg_vikit : <a target="_blank" rel="noopener" href="https://github.com/xuankuzcr/rpg_vikit.git">https://github.com/xuankuzcr/rpg_vikit.git</a> (使用这个url,否则编译时出错)</p>
</li>
</ul>
<h3 id="4-Build"><a href="#4-Build" class="headerlink" title="4. Build"></a>4. Build</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd ~/fast_livo2_ws/<br>catkin_make<br>source ~/fast_livo2_ws/devel/setup.bash<br></code></pre></td></tr></table></figure>

<p>​	<a name="change"></a></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>关于<a target="_blank" rel="noopener" href="https://github.com/xuankuzcr/LIV_handhold">LIV_handhold</a>中<strong>livox_ros_driver</strong>的改动</p>
<p>使用meld对比两份文件夹 ,  新的livox_ros_driver增加了共享内存以及对共享内存写入时间戳的功能.</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">+ livox_ros_driver.cpp<br>	 <span class="hljs-comment">// 将文件映射为一个共享内存区域，大小为sizeof(time_stamp)，通过指针pointt可以直接读写它。</span><br>	  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *user_name = <span class="hljs-built_in">getlogin</span>();<br>      std::string path_for_time_stamp = <span class="hljs-string">&quot;/home/&quot;</span> + std::<span class="hljs-built_in">string</span>(user_name) + <span class="hljs-string">&quot;/timeshare&quot;</span>;<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *shared_file_name = path_for_time_stamp.<span class="hljs-built_in">c_str</span>();<br>      <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(shared_file_name, O_CREAT | O_RDWR | O_TRUNC, <span class="hljs-number">0666</span>);<br>      <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">ERR_EXIT</span>(<span class="hljs-string">&quot;open&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open code: %d\n&quot;</span>, fd);<br>      &#125;<br>      <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-built_in">sizeof</span>(time_stamp) * <span class="hljs-number">1</span>, SEEK_SET);<br>      <span class="hljs-built_in">write</span>(fd, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">1</span>);<br>      pointt = (time_stamp *)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">sizeof</span>(time_stamp) * <span class="hljs-number">1</span>,<br>                                  PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>关于<a target="_blank" rel="noopener" href="https://github.com/xuankuzcr/LIV_handhold">LIV_handhold</a>中<strong>livox_ros_driver2</strong>的改动</p>
<p>新的livox_ros_driver2增加了共享内存以及对共享内存写入时间戳的功能.</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">+lddc.cpp<br>    <span class="hljs-comment">// 实现了用一个普通文件作为共享内存的载体，进程间可以通过映射该文件进行数据共享。</span><br>    <span class="hljs-comment">// 结构体time_stamp用于在多个进程（或设备驱动与应用程序）间共享硬件时间戳。</span><br>    <span class="hljs-comment">//******************************************************************** add code</span><br>    <span class="hljs-keyword">if</span> (isOpended == <span class="hljs-literal">false</span>)<br>    &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *user_name = <span class="hljs-built_in">getlogin</span>();<br>      std::string path_for_time_stamp = <span class="hljs-string">&quot;/home/&quot;</span> + std::<span class="hljs-built_in">string</span>(user_name) + <span class="hljs-string">&quot;/timeshare&quot;</span>;<br><br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *shared_file_name = path_for_time_stamp.<span class="hljs-built_in">c_str</span>();<br>      <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(shared_file_name, O_CREAT | O_RDWR | O_TRUNC, <span class="hljs-number">0666</span>);<br>      <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)<br>      &#123;<br>        <span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;open failed\n&quot;</span>);<br>        isOpended = <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;open code: %d\n&quot;</span>, fd);<br>        isOpended = <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-built_in">sizeof</span>(time_stamp) * <span class="hljs-number">1</span>, SEEK_SET);<br>      <span class="hljs-built_in">write</span>(fd, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">1</span>);<br>      pointt = (time_stamp *)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">sizeof</span>(time_stamp) * <span class="hljs-number">1</span>,<br>                                  PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//********************************************************************</span><br></code></pre></td></tr></table></figure>



<h2 id="STM32硬同步"><a href="#STM32硬同步" class="headerlink" title="STM32硬同步"></a>STM32硬同步</h2><h3 id="1-材料"><a href="#1-材料" class="headerlink" title="1. 材料"></a>1. 材料</h3><ul>
<li>工程文件 : <a target="_blank" rel="noopener" href="https://github.com/xuankuzcr/LIV_handhold/tree/main/stm32_timersync-open">stm32_timersync-open</a></li>
<li>烧录器 : ST-LINK V2</li>
<li>STM32F103C8T6</li>
<li>TTL to USB</li>
<li>TTL to RS485</li>
</ul>
<h3 id="2-原理图"><a href="#2-原理图" class="headerlink" title="2. 原理图"></a>2. 原理图</h3><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/15.png" alt="图9-硬件同步方案"></p>
<p style="text-align:center;">图9-硬件同步方案</p>

<p>Livox_avia不支持直接读取GPRMC格式的指令,mid360支持直接读取.如果使用mid360连线原理图将会改变.本篇只考虑Livox_avia.</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/16.png" alt="图10-硬件同步原理图"></p>
<p style="text-align:center;">图10-硬件同步原理图</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/19.png" alt="图11-时间对齐原理图"></p>
<p style="text-align:center;">图11-时间对齐原理图</p>

<h3 id="3-硬件连线图"><a href="#3-硬件连线图" class="headerlink" title="3. 硬件连线图"></a>3. 硬件连线图</h3><p>**硬件连线参考图 : ** </p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/31.png" alt="图12-硬件连线参考图"></p>
<p style="text-align:center;">图12-硬件连线参考图</p>

<p>相机线说明 :</p>
<p>相机的电源及 I&#x2F;O 接口为 6-pin P7 接口。</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/32.png" alt="图13-相机同步线线序图"></p>
<p style="text-align:center;">图13-相机同步线线序图</p>

<p>Livox Converter 2.0 同步线说明 :</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/33.png" alt="图14-雷达同步线线序图"></p>
<p style="text-align:center;">图14-雷达同步线线序图</p>



<h3 id="4-串口绑定"><a href="#4-串口绑定" class="headerlink" title="4. 串口绑定"></a>4. 串口绑定</h3><p>为了赋予特定串口权限,且防止串口在ubuntu下名称跳变，本片介绍ubuntu系统下如何绑定串口。</p>
<h4 id="1-建立udev规则"><a href="#1-建立udev规则" class="headerlink" title="1. 建立udev规则"></a>1. 建立udev规则</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo gedit /etc/udev/rules.d/my_rule.rules<br></code></pre></td></tr></table></figure>

<h4 id="2-获取串口设备详情"><a href="#2-获取串口设备详情" class="headerlink" title="2. 获取串口设备详情"></a>2. 获取串口设备详情</h4><p>列出当前串口设备。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls /dev/ttyUSB*<br></code></pre></td></tr></table></figure>

<p>以ttyUSB0为例。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">udevadm info --attribute-walk --name=/dev/ttyUSB0<br></code></pre></td></tr></table></figure>

<p>获得详细信息，我习惯以第四行&#x3D;&#x3D;looking …&#x3D;&#x3D;以下的信息作为信息绑定的依靠。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">looking at device &#x27;/devices/pci0000:00/0000:00:14.0/usb3/3-3/3-3:1.0/ttyUSB0/tty/ttyUSB0&#x27;:<br>    KERNEL==&quot;ttyUSB0&quot;<br>    SUBSYSTEM==&quot;tty&quot;<br>    DRIVER==&quot;&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0/usb3/3-3/3-3:1.0/ttyUSB0&#x27;:<br>    KERNELS==&quot;ttyUSB0&quot;<br>    SUBSYSTEMS==&quot;usb-serial&quot;<br>    DRIVERS==&quot;cp210x&quot;<br>    ATTRS&#123;port_number&#125;==&quot;0&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0/usb3/3-3/3-3:1.0&#x27;:<br>    KERNELS==&quot;3-3:1.0&quot;<br>    SUBSYSTEMS==&quot;usb&quot;<br>    DRIVERS==&quot;cp210x&quot;<br>    ATTRS&#123;interface&#125;==&quot;CP2102 USB to UART Bridge Controller&quot;<br>    ATTRS&#123;authorized&#125;==&quot;1&quot;<br>    ATTRS&#123;bAlternateSetting&#125;==&quot; 0&quot;<br>    ATTRS&#123;bInterfaceProtocol&#125;==&quot;00&quot;<br>    ATTRS&#123;bNumEndpoints&#125;==&quot;02&quot;<br>    ATTRS&#123;supports_autosuspend&#125;==&quot;1&quot;<br>    ATTRS&#123;bInterfaceSubClass&#125;==&quot;00&quot;<br>    ATTRS&#123;bInterfaceClass&#125;==&quot;ff&quot;<br>    ATTRS&#123;bInterfaceNumber&#125;==&quot;00&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0/usb3/3-3&#x27;:<br>    KERNELS==&quot;3-3&quot;<br>    SUBSYSTEMS==&quot;usb&quot;<br>    DRIVERS==&quot;usb&quot;<br>    ATTRS&#123;idProduct&#125;==&quot;ea60&quot;<br>    ATTRS&#123;bConfigurationValue&#125;==&quot;1&quot;<br>    ATTRS&#123;tx_lanes&#125;==&quot;1&quot;<br>    ATTRS&#123;bNumInterfaces&#125;==&quot; 1&quot;<br>    ATTRS&#123;maxchild&#125;==&quot;0&quot;<br>    ATTRS&#123;avoid_reset_quirk&#125;==&quot;0&quot;<br>    ATTRS&#123;devpath&#125;==&quot;3&quot;<br>    ATTRS&#123;bDeviceSubClass&#125;==&quot;00&quot;<br>    ATTRS&#123;bDeviceClass&#125;==&quot;00&quot;<br>    ATTRS&#123;ltm_capable&#125;==&quot;no&quot;<br>    ATTRS&#123;quirks&#125;==&quot;0x0&quot;<br>    ATTRS&#123;serial&#125;==&quot;0001&quot;<br>    ATTRS&#123;bDeviceProtocol&#125;==&quot;00&quot;<br>    ATTRS&#123;speed&#125;==&quot;12&quot;<br>    ATTRS&#123;busnum&#125;==&quot;3&quot;<br>    ATTRS&#123;bNumConfigurations&#125;==&quot;1&quot;<br>    ATTRS&#123;manufacturer&#125;==&quot;Silicon Labs&quot;<br>    ATTRS&#123;bMaxPacketSize0&#125;==&quot;64&quot;<br>    ATTRS&#123;version&#125;==&quot; 1.10&quot;<br>    ATTRS&#123;bcdDevice&#125;==&quot;0100&quot;<br>    ATTRS&#123;devnum&#125;==&quot;6&quot;<br>    ATTRS&#123;rx_lanes&#125;==&quot;1&quot;<br>    ATTRS&#123;authorized&#125;==&quot;1&quot;<br>    ATTRS&#123;removable&#125;==&quot;removable&quot;<br>    ATTRS&#123;product&#125;==&quot;CP2102 USB to UART Bridge Controller&quot;<br>    ATTRS&#123;configuration&#125;==&quot;&quot;<br>    ATTRS&#123;bMaxPower&#125;==&quot;100mA&quot;<br>    ATTRS&#123;urbnum&#125;==&quot;12&quot;<br>    ATTRS&#123;bmAttributes&#125;==&quot;80&quot;<br>    ATTRS&#123;idVendor&#125;==&quot;10c4&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0/usb3&#x27;:<br>    KERNELS==&quot;usb3&quot;<br>    SUBSYSTEMS==&quot;usb&quot;<br>    DRIVERS==&quot;usb&quot;<br>    ATTRS&#123;devpath&#125;==&quot;0&quot;<br>    ATTRS&#123;authorized_default&#125;==&quot;1&quot;<br>    ATTRS&#123;ltm_capable&#125;==&quot;no&quot;<br>    ATTRS&#123;speed&#125;==&quot;480&quot;<br>    ATTRS&#123;bNumInterfaces&#125;==&quot; 1&quot;<br>    ATTRS&#123;configuration&#125;==&quot;&quot;<br>    ATTRS&#123;bMaxPower&#125;==&quot;0mA&quot;<br>    ATTRS&#123;bmAttributes&#125;==&quot;e0&quot;<br>    ATTRS&#123;avoid_reset_quirk&#125;==&quot;0&quot;<br>    ATTRS&#123;serial&#125;==&quot;0000:00:14.0&quot;<br>    ATTRS&#123;manufacturer&#125;==&quot;Linux 5.15.0-139-generic xhci-hcd&quot;<br>    ATTRS&#123;busnum&#125;==&quot;3&quot;<br>    ATTRS&#123;interface_authorized_default&#125;==&quot;1&quot;<br>    ATTRS&#123;bConfigurationValue&#125;==&quot;1&quot;<br>    ATTRS&#123;bDeviceClass&#125;==&quot;09&quot;<br>    ATTRS&#123;bMaxPacketSize0&#125;==&quot;64&quot;<br>    ATTRS&#123;quirks&#125;==&quot;0x0&quot;<br>    ATTRS&#123;bcdDevice&#125;==&quot;0515&quot;<br>    ATTRS&#123;idProduct&#125;==&quot;0002&quot;<br>    ATTRS&#123;tx_lanes&#125;==&quot;1&quot;<br>    ATTRS&#123;rx_lanes&#125;==&quot;1&quot;<br>    ATTRS&#123;product&#125;==&quot;xHCI Host Controller&quot;<br>    ATTRS&#123;urbnum&#125;==&quot;98&quot;<br>    ATTRS&#123;removable&#125;==&quot;unknown&quot;<br>    ATTRS&#123;bNumConfigurations&#125;==&quot;1&quot;<br>    ATTRS&#123;devnum&#125;==&quot;1&quot;<br>    ATTRS&#123;bDeviceProtocol&#125;==&quot;01&quot;<br>    ATTRS&#123;version&#125;==&quot; 2.00&quot;<br>    ATTRS&#123;idVendor&#125;==&quot;1d6b&quot;<br>    ATTRS&#123;maxchild&#125;==&quot;12&quot;<br>    ATTRS&#123;bDeviceSubClass&#125;==&quot;00&quot;<br>    ATTRS&#123;authorized&#125;==&quot;1&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:14.0&#x27;:<br>    KERNELS==&quot;0000:00:14.0&quot;<br>    SUBSYSTEMS==&quot;pci&quot;<br>    DRIVERS==&quot;xhci_hcd&quot;<br>    ATTRS&#123;local_cpus&#125;==&quot;ffff&quot;<br>    ATTRS&#123;dma_mask_bits&#125;==&quot;64&quot;<br>    ATTRS&#123;power_state&#125;==&quot;D0&quot;<br>    ATTRS&#123;device&#125;==&quot;0x51ed&quot;<br>    ATTRS&#123;subsystem_device&#125;==&quot;0x3037&quot;<br>    ATTRS&#123;ari_enabled&#125;==&quot;0&quot;<br>    ATTRS&#123;class&#125;==&quot;0x0c0330&quot;<br>    ATTRS&#123;msi_bus&#125;==&quot;1&quot;<br>    ATTRS&#123;vendor&#125;==&quot;0x8086&quot;<br>    ATTRS&#123;revision&#125;==&quot;0x01&quot;<br>    ATTRS&#123;local_cpulist&#125;==&quot;0-15&quot;<br>    ATTRS&#123;label&#125;==&quot;Onboard - Other&quot;<br>    ATTRS&#123;numa_node&#125;==&quot;-1&quot;<br>    ATTRS&#123;driver_override&#125;==&quot;(null)&quot;<br>    ATTRS&#123;consistent_dma_mask_bits&#125;==&quot;64&quot;<br>    ATTRS&#123;subsystem_vendor&#125;==&quot;0x8086&quot;<br>    ATTRS&#123;dbc&#125;==&quot;disabled&quot;<br>    ATTRS&#123;enable&#125;==&quot;1&quot;<br>    ATTRS&#123;broken_parity_status&#125;==&quot;0&quot;<br>    ATTRS&#123;irq&#125;==&quot;145&quot;<br>    ATTRS&#123;d3cold_allowed&#125;==&quot;1&quot;<br>    ATTRS&#123;index&#125;==&quot;7&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00&#x27;:<br>    KERNELS==&quot;pci0000:00&quot;<br>    SUBSYSTEMS==&quot;&quot;<br>    DRIVERS==&quot;&quot;<br>    ATTRS&#123;waiting_for_supplier&#125;==&quot;0&quot;<br></code></pre></td></tr></table></figure>

<h4 id="3-在udev规则下写入串口信息"><a href="#3-在udev规则下写入串口信息" class="headerlink" title="3. 在udev规则下写入串口信息"></a>3. 在udev规则下写入串口信息</h4><p>如果没有相同ID设备的话可直接写入。</p>
<p>其中<code>KERNEL==&quot;ttyUSB*&quot;</code>表明绑定的设备是串口，<code>ATTRS&#123;idVendor&#125;==&quot;10c4&quot;, ATTRS&#123;idProduct&#125;==&quot;ea60&quot;</code>是Step2中设备的信息，<code>MODE:=&quot;0777&quot;</code>给予设备最高权限，<code>SYMLINK+=&quot;ttyUSB_TTL2USB&quot;</code>为绑定后设备的名称。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">KERNEL==&quot;ttyUSB*&quot;, ATTRS&#123;idVendor&#125;==&quot;10c4&quot;, ATTRS&#123;idProduct&#125;==&quot;ea60&quot;, MODE:=&quot;0777&quot;, SYMLINK+=&quot;ttyUSB_TTL2USB&quot;<br></code></pre></td></tr></table></figure>

<p>若有相同ID设备，则可再添加<code>ATTRS&#123;devpath&#125;==&quot;5.2&quot;</code>信息，该量一般与设备与电脑链接的端口号有关。</p>
<h4 id="4-重启udev"><a href="#4-重启udev" class="headerlink" title="4. 重启udev"></a>4. 重启udev</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo service udev reload<br>sudo service udev restart<br></code></pre></td></tr></table></figure>

<p>再次查看串口设备，即可看到绑定成功后的名称。若还没成功，可尝试重启电脑或者热插拔设备。</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/50.jpg" alt="图15-绑定串口显示"></p>
<p style="text-align:center;">图15-绑定串口显示</p>



<h3 id="5-雷达设置"><a href="#5-雷达设置" class="headerlink" title="5. 雷达设置"></a>5. 雷达设置</h3><p>雷达选型 : Livox AVIA</p>
<p>转换器 : Livox Converter 2.0</p>
<h4 id="Livox雷达时间同步说明"><a href="#Livox雷达时间同步说明" class="headerlink" title="Livox雷达时间同步说明"></a>Livox雷达时间同步说明</h4><p>参考:<a target="_blank" rel="noopener" href="https://github.com/Livox-SDK/Livox-SDK/wiki/livox-device-time-synchronization-manual-cn#%E9%99%84%E5%BD%95">https://github.com/Livox-SDK/Livox-SDK/wiki/livox-device-time-synchronization-manual-cn#%E9%99%84%E5%BD%95</a></p>
<p>Livox设备支持3种时间同步方式：</p>
<ul>
<li>PTP：IEEE 1588v2.0 PTP 网络协议同步；</li>
<li>GPS：秒脉冲+GPRMC时间数据，组成GPS时间同步方式；</li>
<li>PPS：秒脉冲同步，需要上层应用程序通过其他途径（如：uart）获取每个脉冲的时间信息，并修正点云时间。</li>
</ul>
<p>FAST-LIO只涉及GPS和PPS两种,只介绍这两种。</p>
<h5 id="GPS"><a href="#GPS" class="headerlink" title="GPS"></a>GPS</h5><p>GPS时钟源的PPS端口每秒发送一次硬件脉冲（PPS信号），随后数据端口发送一次对应这个脉冲上升沿的时间信息（GPRMC格式）。Livox设备接收到PPS信号上升沿，并由GPRMC数据解析出正确的时间信息后，会设置点云时间为GPS时间，并保持此时间基准持续累加，来实现和GPS设备的时间同步。</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/17.png" alt="图17-GPS信号示意图"></p>
<p style="text-align:center;">图17-GPS信号示意图</p>

<p><strong>Livox Converter 2.0</strong>将GPS模块的时间信号（GPRMC）通过TTL转usb模块接入PC，PPS信号接入LiDAR转接盒同步口（Sync Port）。</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/18.png" alt="图18-Livox Converter 2.0连线图"></p>
<p style="text-align:center;">图18-Livox Converter 2.0连线图</p>

<h5 id="PPS"><a href="#PPS" class="headerlink" title="PPS"></a>PPS</h5><p>Livox LiDAR每次接收到PPS信号的上升沿后，会将当前时刻的点云时间置为0，然后重新开始计时直到下一个PPS脉冲到来,利用这个特性，来实现PPS脉冲对LiDAR时间的同步。</p>
<p>伪代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// PPS Time Synchronization</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span> lidar_time_last;<br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span> lidar_time_real;<br><br><span class="hljs-comment">// 1. Read the PPS rising edge time, Unit is nanosecond.</span><br><span class="hljs-type">uint64_t</span> pps_time_ns = get_pps_rising_nsecond();<br><span class="hljs-comment">// 2. Read LiDAR point time, Unit is nanosecond.</span><br><span class="hljs-type">uint64_t</span> lidar_time = get_lidar_pack_time();<br><span class="hljs-comment">// 3. Update real time.</span><br><span class="hljs-keyword">if</span> (lidar_time &lt; lidar_time_last)<br>&#123;<br>    <span class="hljs-comment">//LiDAR time jump indicates the generation of PPS rising edge.</span><br>    lidar_time_real = pps_time_ns + lidar_time%(<span class="hljs-number">1000000000</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    lidar_time_real += lidar_time - lidar_time_last;<br>&#125;<br><span class="hljs-comment">//Update history</span><br>lidar_time_last = lidar_time;<br></code></pre></td></tr></table></figure>

<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><h4 id="1-安装Livox-Viewer"><a href="#1-安装Livox-Viewer" class="headerlink" title="1. 安装Livox Viewer"></a>1. 安装Livox Viewer</h4><p> Livox Viewer 0.10.0(64bit) : <a target="_blank" rel="noopener" href="https://www.livoxtech.com/downloads">https://www.livoxtech.com/downloads</a></p>
<blockquote>
<p>注：Livox Viewer2并不支持Avia</p>
</blockquote>
<p>以太网设置:</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/47.jpg" alt="图19-Livox雷达以太网设置"></p>
<p style="text-align:center;">图19-Livox雷达以太网设置</p>

<p>点击左上角播放按钮,出现点云.</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/48.jpg" alt="图20-Livox Viewer点云示意图"></p>
<p style="text-align:center;">图20-Livox Viewer点云示意图</p>

<p>插上硬同步设备后,查看雷达的连接转态和数据的读取状态，来确认雷达是否已进入PPS同步状态 <strong>(在这里不能修改TIme Sync &#x2F; PPS State,此设置为连接硬同步后自动触发)</strong></p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/49.png" alt="图21-Livox Viewer设置状态图"></p>
<p style="text-align:center;">图21-Livox Viewer设置状态图</p>

<h4 id="2-修改livox-lidar-config-json"><a href="#2-修改livox-lidar-config-json" class="headerlink" title="2. 修改livox_lidar_config.json"></a>2. 修改livox_lidar_config.json</h4><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/51.jpg" alt="图22-livox_lidar_config.json参数设置"></p>
<p style="text-align:center;">图22-livox_lidar_config.json参数设置</p>

<h4 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs SHELL">roslaunch livox_ros_driver livox_lidar_rviz.launch<br></code></pre></td></tr></table></figure>

<p>可以在自动弹出来的rviz中查看是否有点云正常输出和显示</p>
<h3 id="6-相机设置"><a href="#6-相机设置" class="headerlink" title="6. 相机设置"></a>6. 相机设置</h3><p>相机 : 海康相机MV-CS020-10UC</p>
<p>驱动 : MVS_STD_V3.0.1</p>
<h4 id="1-安装驱动"><a href="#1-安装驱动" class="headerlink" title="1. 安装驱动"></a>1. 安装驱动</h4><p>海康威视工业相机SDK的ros驱动依赖MVS的库文件，先安装MVS客户端.</p>
<p>官方下载地址：<a href="https://gitee.com/link?target=https://www.hikrobotics.com/cn/machinevision/service/download/?module=0">https://www.hikrobotics.com/cn/machinevision/service/download/?module=0</a></p>
<h4 id="2-下载和编译相机的雷达ros驱动"><a href="#2-下载和编译相机的雷达ros驱动" class="headerlink" title="2. 下载和编译相机的雷达ros驱动"></a>2. 下载和编译相机的雷达ros驱动</h4><p> (见<a href="#mvs_ros_pkg">NUC环境搭建 - 3.工作空间配置</a>)</p>
<h4 id="3-调整配置文件"><a href="#3-调整配置文件" class="headerlink" title="3. 调整配置文件"></a>3. 调整配置文件</h4><p>路径 : mvs_ros_driver&#x2F;config</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">%YAML:1.0</span><br><br><span class="hljs-comment">#--------------------------------------------------------------------------------------------</span><br><span class="hljs-comment"># Camera Parameters. Adjust them!</span><br><span class="hljs-comment">#--------------------------------------------------------------------------------------------</span><br><span class="hljs-attr">SerialNumber:</span> <span class="hljs-string">&quot;DA2099368&quot;</span> <span class="hljs-comment"># Not needed for single camera. Specify serial number for multiple cameras. </span><br><span class="hljs-attr">TopicName:</span> <span class="hljs-string">&quot;left_camera/image&quot;</span><br><br><span class="hljs-attr">TriggerEnable:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 0 stands for Off, 1 stands for On</span><br><br><span class="hljs-attr">ExposureAutoMode:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 0 stands for Off, 1 stands for Once, 2 stands for Continues</span><br><span class="hljs-attr">ExposureTime:</span> <span class="hljs-number">5000</span> <span class="hljs-comment"># us</span><br><br><span class="hljs-comment"># ExposureAutoMode: 2</span><br><span class="hljs-comment"># AutoExposureTimeLower: 100</span><br><span class="hljs-comment"># AutoExposureTimeUpper: 20000</span><br><br><span class="hljs-attr">image_scale:</span> <span class="hljs-number">0.5</span> <span class="hljs-comment"># 1 0.5</span><br><span class="hljs-attr">GainAuto:</span> <span class="hljs-number">2</span> <span class="hljs-comment"># Gain Auto, 0 stands for Off, 1 stands for Once, 2 stands for Continues</span><br><span class="hljs-attr">Gain:</span> <span class="hljs-number">15</span> <span class="hljs-comment"># min: 0   max: 17.0166</span><br><span class="hljs-attr">Gamma:</span> <span class="hljs-number">0.7</span>  <span class="hljs-comment"># min: 0   max: 17.0166</span><br><span class="hljs-attr">GammaSelector:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 0 stands for user, 1 stands for sRGB</span><br><span class="hljs-comment"># GammaEnable: 1</span><br><br><span class="hljs-attr">PixelFormat:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 0: RGB8, 1: BayerRG8, 2: BayerRG12Packed, 3: BayerGB12Packed, 4: BayerGB8</span><br></code></pre></td></tr></table></figure>

<p>最重要的参数是<strong>PixelFormat</strong>,需要根据相机型号调整。遍历一遍看哪个数值可用当然可以,代价是报错的时候不能理解其中原因,会造成很多麻烦。</p>
<p><strong>如何找到适合本相机的PixelFormat :</strong></p>
<ul>
<li>查阅海康相机官网<a target="_blank" rel="noopener" href="https://www.hikrobotics.com/cn/machinevision/productdetail/?id=12379">https://www.hikrobotics.com/cn/machinevision/productdetail/?id=12379</a></li>
</ul>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/41.png" alt="图23-相机支持像素格式"></p>
<p style="text-align:center;">图23-相机支持像素格式</p>

<p>​	看似这个相机支持RGB8 &#x2F; BayerRG8 &#x2F; BayerRG12Packed, PixelFormat选择0&#x2F;1&#x2F;2都可以, 实则不然。</p>
<p>​	当选择1或2的时候,运行<code>roslaunch mvs_ros_driver mvs_camera_trigger.launch</code>时, 出现报错 :</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/42.jpg" alt="图24-mvs_camera_trigger报错图"></p>
<p style="text-align:center;">图24-mvs_camera_trigger报错图</p>

<p>​	针对这个报错, 打开MVS的官方图形化界面看一下 : </p>
<p>​	图形化界面参数太多了,再查阅海康机器人USB3.0工业面阵相机用户手册,发现Gamma参数应该在Analog Control 属性中.</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/43.png" alt="图25-海康相机用户手册详细参数"></p>
<p style="text-align:center;">图25-海康相机用户手册详细参数</p>

<p>​	在Bayer RG 8 &#x2F; BayerRG12Packed模式下 , 没有Gamma这个参数 ．只有在RGB8模式下才有Gamma参数．</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/44.jpg" alt="图26-海康相机图形化界面参数"></p>
<p style="text-align:center;">图26-海康相机图形化界面参数</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/45.jpg" alt="图27-海康相机图形化界面参数"></p>
<p style="text-align:center;">图27-海康相机图形化界面参数</p>

<p>​	探究一下原理：</p>
<ul>
<li><p>Bayer 格式是原始图像数据（Raw），<code>Bayer RG8</code> 是未经过处理的原始图像数据格式，每个像素仅包含单色信息（红、绿或蓝中的一个）。在这种格式下，图像还没有完成 去马赛克（Demosaicing）、白平衡、Gamma 校正等ISP流程。</p>
</li>
<li><p>RGB8 是处理后的彩色图像格式，可以进行Gamma调节．</p>
<blockquote>
<p>注 : 如果把yaml文件中的Gamma和GammaSelector注释掉,该驱动包也能正常跑.但是之后我都选择使用<strong>RGB8</strong>格式,故BayerRG8 &#x2F; BayerRG12Packed能否跑完全流程并不确定．</p>
</blockquote>
</li>
</ul>
<h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h4><ul>
<li><p>如果需要<strong>单独测试相机驱动</strong>,需要把mvs_ros_driver&#x2F;config中的<strong>TriggerEnable参数改为0</strong>,否则节点无图像数据！</p>
</li>
<li><p>相机插NUC的<strong>USB3.0</strong>的插口</p>
</li>
<li><p>指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch mvs_ros_pkg mvs_camera_trigger.launch<br></code></pre></td></tr></table></figure>

<p>rviz中查看图像是否正常输出．</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/46.jpg" alt="图28-mvs_camera_trigger的rviz界面"></p>
<p style="text-align:center;">图28-mvs_camera_trigger的rviz界面</p></li>
</ul>
<h3 id="7-烧录"><a href="#7-烧录" class="headerlink" title="7. 烧录"></a>7. 烧录</h3><ol>
<li><p>STLINK驱动安装</p>
<p><a target="_blank" rel="noopener" href="https://docs.qq.com/doc/DT2hyS2ZjY21WQkZt">https://docs.qq.com/doc/DT2hyS2ZjY21WQkZt</a></p>
</li>
<li><p>硬件连接</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/20.png" alt="图29-烧录硬件连接原理图"></p>
<p style="text-align:center;">图29-烧录硬件连接原理图</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/21.jpg" alt="图30-实物图(stlink正面)"></p>
<p style="text-align:center;">图30-实物图(stlink正面)</p></li>
</ol>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/22.jpg" alt="图31-实物图(stlink侧面)"></p>
<p style="text-align:center;">图31-实物图(stlink侧面)</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/23.jpg" alt="图32-实物图(stm32背面)"></p>
<p style="text-align:center;">图32-实物图(stm32背面)</p>

<ol start="3">
<li><p>Keil烧录</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/24.png" alt="图33-烧录步骤-1"></p>
<p style="text-align:center;">图33-烧录步骤-1</p></li>
</ol>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/25.png" alt="图34-烧录步骤-2"></p>
<p style="text-align:center;">图34-烧录步骤-2</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/26.png" alt="图35-烧录步骤-3"></p>
<p style="text-align:center;">图35-烧录步骤-3</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/27.png" alt="图36-烧录步骤-4"></p>
<p style="text-align:center;">图36-烧录步骤-4</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/28.png" alt="图37-烧录步骤-5"></p>
<p style="text-align:center;">图37-烧录步骤-5</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/29.png" alt="图38-烧录步骤-6"></p>
<p style="text-align:center;">图38-烧录步骤-6</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/30.png" alt="图39-烧录步骤-7"></p>
<p style="text-align:center;">图39-烧录步骤-7</p>



<h2 id="标定"><a href="#标定" class="headerlink" title="标定"></a>标定</h2><h3 id="相机内参标定"><a href="#相机内参标定" class="headerlink" title="相机内参标定"></a>相机内参标定</h3><p>张正友平面标定法</p>
<ol>
<li><p>准备标定素材</p>
<p>海康相机不能直接用opencv打开,必须调用mvs_ros_driver包,在自己写的订阅相机图片节点捕获图像.</p>
<blockquote>
<p>注意mvs_ros_driver发布图片话题时有scale &#x3D; 0.5,后面标定得到的参数需要*2。</p>
</blockquote>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">订阅相机图像话题并截图的ros_node</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sensor_msgs/Image.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cv_bridge/cv_bridge.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/filesystem.hpp&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> fs = boost::filesystem;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageCapture</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ImageCapture</span>(ros::NodeHandle&amp; nh, <span class="hljs-type">const</span> std::string&amp; save_dir)<br>        : <span class="hljs-built_in">save_dir_</span>(save_dir)<br>    &#123;<br>        sub_ = nh.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;/left_camera/image&quot;</span>, <span class="hljs-number">1</span>, &amp;ImageCapture::imageCallback, <span class="hljs-keyword">this</span>);<br>        <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;等待按下空格键保存图像，按 &#x27;q&#x27; 退出&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (!fs::<span class="hljs-built_in">exists</span>(save_dir_))<br>        &#123;<br>            fs::<span class="hljs-built_in">create_directories</span>(save_dir_);<br>            <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;创建保存目录: %s&quot;</span>, save_dir_.<span class="hljs-built_in">c_str</span>());<br>        &#125;<br><br>        cv::<span class="hljs-built_in">namedWindow</span>(<span class="hljs-string">&quot;View&quot;</span>, cv::WINDOW_NORMAL);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spin</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">ros::Rate <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<br>        <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>        &#123;<br>            &#123;<br>                <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>                <span class="hljs-keyword">if</span> (!latest_image_.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    cv::<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;View&quot;</span>, latest_image_);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-type">int</span> key = cv::<span class="hljs-built_in">waitKey</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (key == <span class="hljs-number">32</span>) <span class="hljs-comment">// 空格</span><br>            &#123;<br>                <span class="hljs-built_in">saveImage</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&#x27;q&#x27;</span> || key == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            &#123;<br>                <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;用户退出程序&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            ros::<span class="hljs-built_in">spinOnce</span>();<br>            rate.<span class="hljs-built_in">sleep</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ros::Subscriber sub_;<br>    cv::Mat latest_image_;<br>    std::mutex mutex_;<br>    std::string save_dir_;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">imageCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::ImageConstPtr&amp; msg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            cv::Mat image = cv_bridge::<span class="hljs-built_in">toCvShare</span>(msg, <span class="hljs-string">&quot;bgr8&quot;</span>)-&gt;image;<br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>            latest_image_ = image.<span class="hljs-built_in">clone</span>();<br>        &#125;<br>        <span class="hljs-built_in">catch</span> (cv_bridge::Exception&amp; e)<br>        &#123;<br>            <span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;cv_bridge 异常: %s&quot;</span>, e.<span class="hljs-built_in">what</span>());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">saveImage</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        <span class="hljs-keyword">if</span> (!latest_image_.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            std::string filename = save_dir_ + <span class="hljs-string">&quot;/image_&quot;</span> + std::<span class="hljs-built_in">to_string</span>(ros::Time::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">toNSec</span>()) + <span class="hljs-string">&quot;.jpg&quot;</span>;<br>            cv::<span class="hljs-built_in">imwrite</span>(filename, latest_image_);<br>            <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;图像已保存为 %s&quot;</span>, filename.<span class="hljs-built_in">c_str</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">ROS_WARN</span>(<span class="hljs-string">&quot;没有图像可保存&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;image_capture_node&quot;</span>);<br>    <span class="hljs-function">ros::NodeHandle <span class="hljs-title">nh</span><span class="hljs-params">(<span class="hljs-string">&quot;~&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 获取保存目录参数（默认当前目录）</span><br>    std::string save_dir;<br>    nh.<span class="hljs-built_in">param</span>&lt;std::string&gt;(<span class="hljs-string">&quot;save_dir&quot;</span>, save_dir, <span class="hljs-string">&quot;./&quot;</span>);<br><br>    <span class="hljs-function">ImageCapture <span class="hljs-title">ic</span><span class="hljs-params">(nh, save_dir)</span></span>;<br>    ic.<span class="hljs-built_in">spin</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<ol start="2">
<li>使用MATLAB进行标定:</li>
</ol>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/77.png" alt="图40-在matlab中选择标定"></p>
<p style="text-align:center;">图40-在matlab中选择标定</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/78.png" alt="图41-标定过程"></p>
<p style="text-align:center;">图41-标定过程</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/79.png" alt="图42-标定得到的数据"></p>
<p style="text-align:center;">图42-标定得到的数据</p>

<blockquote>
<p>得到参数:</p>
<p>&gt;&gt; cameraParams.IntrinsicMatrix</p>
<p>   671.9949         0          0         </p>
<p>   0                672.0204   0  </p>
<p>  410.0420    323.3874  1.0000 </p>
<p> &gt;&gt; cameraParams.RadialDistortion     -0.0572    0.0895</p>
</blockquote>
<p>对应camera_pinhole.yaml中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cam_model:</span> <span class="hljs-string">Pinhole</span><br><span class="hljs-attr">cam_width:</span> <span class="hljs-number">1624</span><br><span class="hljs-attr">cam_height:</span> <span class="hljs-number">1240</span><br><span class="hljs-attr">scale:</span> <span class="hljs-number">0.5</span><br><span class="hljs-attr">cam_fx:</span> <span class="hljs-number">1343.9898</span><br><span class="hljs-attr">cam_fy:</span> <span class="hljs-number">1344.0408</span><br><span class="hljs-attr">cam_cx:</span> <span class="hljs-number">820.0840</span><br><span class="hljs-attr">cam_cy:</span> <span class="hljs-number">646.7748</span><br><span class="hljs-attr">cam_d0:</span> <span class="hljs-number">-0.0572</span><br><span class="hljs-attr">cam_d1:</span> <span class="hljs-number">0.0895</span><br><span class="hljs-attr">cam_d2:</span> <span class="hljs-number">0.0</span><br><span class="hljs-attr">cam_d3:</span> <span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure>

<h3 id="外参标定"><a href="#外参标定" class="headerlink" title="外参标定"></a>外参标定</h3><ul>
<li><p>将相机内参同步到<code>FAST-Calib/config/qr_params.yaml</code>中。</p>
</li>
<li><p>运行roslaunch livox_ros_driver livox_lidar_msg<br>在<code>/FAST-Calib/calib_data</code> 下运行 <code> rosbag record -a</code></p>
</li>
<li><p>拍照当前相机图片</p>
<p>标定数据组织如下 (data.txt为自行记录标定数据,不需要预先创建)</p>
</li>
</ul>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/80.jpg" alt="图43-FAST-Calib标定数据组织"></p>
<p style="text-align:center;">图43-FAST-Calib标定数据组织</p>

<p>运行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch fast_calib calib.launch<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意修改qr_params.yaml中和filter相关的参数.</p>
<p>否则会报错 :</p>
<p>[pcl::TransformationEstimationSVD::estimateRigidTransformation] Number or points in source (0) differs than target (4)! [Result] RMSE:  [computeRMSE] Point cloud sizes do not match, cannot compute RMSE.  -1.0000 m</p>
</blockquote>
<p>参考qr_params.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Camera intrinsics  </span><br>  <span class="hljs-comment"># mid360</span><br>  <span class="hljs-comment"># fx: 522.123514287681</span><br>  <span class="hljs-comment"># fy: 522.275153384482</span><br>  <span class="hljs-comment"># cx: 773.466430504725</span><br>  <span class="hljs-comment"># cy: 534.053165700174</span><br>  <span class="hljs-comment"># k1: 0.00324949759262203</span><br>  <span class="hljs-comment"># k2: -0.0171040538369167</span><br>  <span class="hljs-comment"># p1: 0.000669657443377146</span><br>  <span class="hljs-comment"># p2: -0.000350205468789575</span><br><br>  <span class="hljs-comment"># avia</span><br>  <span class="hljs-attr">fx:</span> <span class="hljs-number">1343.9898</span><br>  <span class="hljs-attr">fy:</span> <span class="hljs-number">1344.0408</span><br>  <span class="hljs-attr">cx:</span> <span class="hljs-number">820.0840</span><br>  <span class="hljs-attr">cy:</span> <span class="hljs-number">646.7748</span><br>  <span class="hljs-attr">k1:</span> <span class="hljs-number">-0.0572</span><br>  <span class="hljs-attr">k2:</span> <span class="hljs-number">0.0895</span><br>  <span class="hljs-attr">p1:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">p2:</span> <span class="hljs-number">0</span><br><br>  <span class="hljs-comment"># ouster</span><br>  <span class="hljs-comment"># fx: 1466.16500795563</span><br>  <span class="hljs-comment"># fy: 1465.32657394431</span><br>  <span class="hljs-comment"># cx: 1214.39964380518</span><br>  <span class="hljs-comment"># cy: 1010.97681425650</span><br>  <span class="hljs-comment"># k1: -0.0458344972140773</span><br>  <span class="hljs-comment"># k2: 0.0896961240772692</span><br>  <span class="hljs-comment"># p1: -0.000731746350601389</span><br>  <span class="hljs-comment"># p2: -0.000201478932371979</span><br><br><span class="hljs-comment"># Calibration target parameters</span><br>  <span class="hljs-attr">marker_size:</span> <span class="hljs-number">0.17</span> <span class="hljs-comment"># ArUco marker size (our test data uses 0.16m; adjust to match your marker size)</span><br>  <span class="hljs-attr">delta_width_qr_center:</span> <span class="hljs-number">0.55</span> <span class="hljs-comment"># Half the distance between the centers of two markers in the horizontal direction </span><br>  <span class="hljs-attr">delta_height_qr_center:</span> <span class="hljs-number">0.35</span> <span class="hljs-comment"># Half the distance between the centers of two markers in the vertical direction</span><br>  <span class="hljs-attr">delta_width_circles:</span> <span class="hljs-number">0.5</span> <span class="hljs-comment"># Distance between the centers of two circles in the horizontal direction</span><br>  <span class="hljs-attr">delta_height_circles:</span> <span class="hljs-number">0.4</span> <span class="hljs-comment"># Distance between the centers of two circles in the vertical direction</span><br>  <span class="hljs-attr">circle_radius:</span> <span class="hljs-number">0.12</span> <span class="hljs-comment"># Radius of the circle </span><br><br><span class="hljs-comment"># Distance filter</span><br>  <span class="hljs-attr">x_min:</span> <span class="hljs-number">1.8</span><br>  <span class="hljs-attr">x_max:</span> <span class="hljs-number">2.4</span><br>  <span class="hljs-attr">y_min:</span> <span class="hljs-number">-1</span><br>  <span class="hljs-attr">y_max:</span> <span class="hljs-number">1.0</span><br>  <span class="hljs-attr">z_min:</span> <span class="hljs-number">-0.2</span> <span class="hljs-comment"># avia and mid360: -0.5 ouster: -0.8</span><br>  <span class="hljs-attr">z_max:</span> <span class="hljs-number">2.5</span><br><br><span class="hljs-comment"># Input</span><br>  <span class="hljs-attr">lidar_topic:</span> <span class="hljs-string">&quot;/livox/lidar&quot;</span> <span class="hljs-comment"># /ouster/points /livox/lidar</span><br>  <span class="hljs-attr">bag_path:</span> <span class="hljs-string">&quot;$(find fast_calib)/calib_data/1.bag&quot;</span><br>  <span class="hljs-attr">image_path:</span> <span class="hljs-string">&quot;$(find fast_calib)/calib_data/1.png&quot;</span><br><br><span class="hljs-comment"># Output</span><br>  <span class="hljs-attr">output_path:</span> <span class="hljs-string">&quot;$(find fast_calib)/output&quot;</span><br></code></pre></td></tr></table></figure>

<p>标定结果:</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/82.png" alt="图44-FAST-Calib标定的点云"></p>
<p style="text-align:center;">图44-FAST-Calib标定的点云</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/83.png" alt="图45-FAST-Calib标定的彩色图像"></p>
<p style="text-align:center;">图45-FAST-Calib标定的彩色图像</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/81.png" alt="图46-FAST-Calib得到的数据"></p>
<p style="text-align:center;">图46-FAST-Calib得到的数据</p>

<blockquote>
<p>输出:</p>
<p>[Result] Extrinsic parameters T_cam_lidar:<br>-0.096829 -0.994963 -0.025938 -1.142585<br>-0.081987  0.033945 -0.996055 -0.876730<br> 0.991919 -0.094320 -0.084861  2.192050<br> 0.000000  0.000000  0.000000  1.000000</p>
<p>对应的Rcl和Pcl:</p>
<p>Rcl: [-0.096829, -0.994963, -0.025938,<br>      -0.081987,  0.033945, -0.996055,<br>       0.991919, -0.094320, -0.084861]<br>Pcl: [-1.142585, -0.876730, 2.192050]</p>
<p>和真值偏移很大,彩色点云图中也有畸变,怀疑是标定板形变,以及标定板没有按照FAST-Calib官方推荐固定并悬挂的原因.</p>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="跑包"><a href="#跑包" class="headerlink" title="跑包"></a>跑包</h3><p>HKU_Lecture_Center_02.bag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch fast_livo mapping_avia.launch<br>rosbag play HKU_Lecture_Center_02.bag<br></code></pre></td></tr></table></figure>

<h4 id="建图精度"><a href="#建图精度" class="headerlink" title="建图精度"></a>建图精度</h4><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/2.jpg" alt="图47-rviz-1"></p>
<p style="text-align:center;">图47-rviz-1</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/3.jpg" alt="图48-rviz-2"></p>
<p style="text-align:center;">图48-rviz-2</p>

<p>墙面与地面分界线清晰</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/4.jpg" alt="图49-rviz-3"></p>
<p style="text-align:center;">图49-rviz-3</p>

<p>图片处理(拉高亮度)后,可以看到墙面纹路,转角非常清晰</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/5.jpg" alt="图50-rviz-4"></p>
<p style="text-align:center;">图50-rviz-4</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/6.jpg" alt="图51-rviz-5"></p>
<p style="text-align:center;">图51-rviz-5</p>



<h4 id="系统资源占用"><a href="#系统资源占用" class="headerlink" title="系统资源占用"></a>系统资源占用</h4><p>运行launch和rviz : 资源主要由rviz占用,且初始rviz config中点云queue数值极大,rviz实时看全局着色点云很卡</p>
<ol>
<li>可以把queue值 &#x2F; decay值适当改小;</li>
<li>可以重建完成后保存pcd文件,通过pcl_viewer（最好+显卡 +opengl）或者cloud compare等软件离线查看;</li>
<li>使用带gpu的电脑提升实时rviz性能.</li>
</ol>
<table>
<thead>
<tr>
<th align="center"><strong>字段</strong></th>
<th align="center"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">PRI</td>
<td align="center">Priority（优先级）</td>
</tr>
<tr>
<td align="center">NI</td>
<td align="center">Nice 值（友好度）</td>
</tr>
<tr>
<td align="center">VIRT</td>
<td align="center">Virtual Memory（虚拟内存大小）</td>
</tr>
<tr>
<td align="center">RES</td>
<td align="center">Resident Memory（常驻内存） 当前进程实际占用的物理内存大小</td>
</tr>
<tr>
<td align="center">SHR</td>
<td align="center">Shared Memory（共享内存）</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">State（进程状态）R：运行（Running）S：休眠（Sleeping）</td>
</tr>
<tr>
<td align="center">CPU%</td>
<td align="center">进程当前使用的 CPU 百分比（所有核总和）</td>
</tr>
<tr>
<td align="center">MEM%</td>
<td align="center">进程使用的物理内存占系统总内存的百分比</td>
</tr>
</tbody></table>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/7.jpg" alt="图52-htop查看资源占用"></p>
<p style="text-align:center;">图52-htop查看资源占用</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/8.jpg" alt="图53-fast-livo2运行占用资源"></p>
<p style="text-align:center;">图53-fast-livo2运行占用资源</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/9.jpg" alt="图54-fast-livo2的rviz占用资源"></p>
<p style="text-align:center;">图54-fast-livo2的rviz占用资源</p>

<p>只运行launch: </p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/10.jpg" alt="图55-只运行launch系统占用资源"></p>
<p style="text-align:center;">图55-只运行launch系统占用资源</p>



<h4 id="里程计数据"><a href="#里程计数据" class="headerlink" title="里程计数据"></a>里程计数据</h4><p>纵轴单位(m) ,三条曲线分别是x轴,y轴,z轴里程计数据变化</p>
<ul>
<li><p>蓝色-x轴</p>
</li>
<li><p>红色-y轴</p>
</li>
<li><p>绿色-z轴</p>
<p>取最后一段平稳曲线部分放大 : 静态波动在厘米级,峰峰值4-6cm</p>
</li>
</ul>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/11.jpg" alt="图56-里程计数据总览"></p>
<p style="text-align:center;">图56-里程计数据总览</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/12.png" alt="图57-里程计数据细节(图56蓝色框部分)"></p>
<p style="text-align:center;">图57-里程计数据细节(图56蓝色框部分)</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/13.jpg" alt="图58-里程计数据统计(统计图57中数据部分)"></p>
<p style="text-align:center;">图58-里程计数据统计(统计图57中数据部分)</p>



<h4 id="处理时间"><a href="#处理时间" class="headerlink" title="处理时间"></a>处理时间</h4><p>参考该帧处理时间数量级</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/14.jpg" alt="图59-处理时间参考"></p>
<p style="text-align:center;">图59-处理时间参考</p>



<p>###可行性初测试</p>
<h4 id="修改参数"><a href="#修改参数" class="headerlink" title="修改参数"></a>修改参数</h4><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/53.png" alt="图60-fast-livo2文件结构"></p>
<p style="text-align:center;">图60-fast-livo2文件结构</p>

<ul>
<li><p>&#x2F;congfig&#x2F;avia.yaml: Avia雷达的参数配置</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/54.png" alt="图61-雷达参数配置文件"></p>
<p style="text-align:center;">图61-雷达参数配置文件</p>

<blockquote>
<ul>
<li><p><strong>extrin_calib</strong> 中：</p>
<ol>
<li><p>extrinsic_T 和extrinsic_R 为雷达到IMU的外参（平移与旋转）</p>
</li>
<li><p>Rcl 和 Pcl 为相机到 LiDAR 的旋转矩阵和平移向量, 需要外参标定得出，更新到该位置即可</p>
<p>-作者在issue中的原回答:</p>
<p>The extrinsic_R in avia_resize.yaml doesn’t have to be an identity matrix.<br>extrinsic_R represents the rotation matrix of LiDAR frame w.r.t. IMU frame.<br>extrinsic_T represents the translation of LiDAR frame w.r.t. IMU frame.<br>If you set them correctly according to the physical meaning, there should be no wrong alignment of the image and LiDAR scan.</p>
</li>
</ol>
</li>
<li><p><strong>preprocess</strong> 预处理中：</p>
<p>1.lidar_type： LiDAR 类型<br> 保持值仍为1 （1：Livox Avia &#x2F; Mid360）</p>
<p>2.scan_line:  扫描线数量<br> 这里仍为6  （Avia：6，Mid360：4）</p>
</li>
<li><p><strong>time_offset</strong>时间偏移: </p>
<p>-作者在issue中的原回答:</p>
<p>img_time_offset: 0.1，在我们提供的<a target="_blank" rel="noopener" href="https://github.com/xuankuzcr/LIV_handhold">同步方案</a>中，LiDAR会将其时间戳存储到共享内存中，相机帧则会读取内存中最新的时间戳。由于LiDAR scan是一个段时间测量，需要等0.1秒扫完后才会将其header的时间戳存到内存里。此时被触发的相机读取的时间戳实际上是0.1秒前的，因此其真实采样时间戳需要+0.1s。 对于NTU-VIRAL数据集，我设置lidar_time_offset: -0.1，因为该数据集中的LiDAR scan提供的是帧末时间戳，而我们的系统需要的是header时间戳，因此需要-0.1s。这一判断是基于在静止条件下观察EKF估计出的位姿抖动程度得出的。 </p>
<p>时间没对上不影响，只要在一个时间轴上就可以，evo会用高频的真值轨迹插值出LiDAR或相机采样时刻的位姿的。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>&#x2F;congfig&#x2F;camara_pinhole.yaml: 相机的参数配置</p>
<p>相机选型: 海康相机MV-CS020-10UC</p>
<p>相机原始图像尺寸大小 : 1624*1240</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs SHELL">cam_model: Pinhole<br>cam_width: 1624<br>cam_height: 1240<br>scale: 0.5<br>cam_fx: 1343.9898<br>cam_fy: 1344.0408<br>cam_cx: 820.0840<br>cam_cy: 646.7748<br>cam_d0: -0.0572<br>cam_d1: 0.0895<br>cam_d2: 0.0<br>cam_d3: 0.0<br></code></pre></td></tr></table></figure>

<blockquote>
<p>除了要修改雷达的内参参数外,还要注意<code>cam_width</code> &#x2F; <code>cam_height</code> &#x2F; <code>scale</code> 三个参数 :</p>
<ul>
<li>在 mvs_ros_driver &#x2F; config &#x2F; left_camera_trigger.yaml中,scale默认为0.5,camara_pinhole.yaml中的值需要与其保持一致</li>
<li>mvs_ros_driver中默认不修改相机图像大小,<code>cam_width</code> &#x2F; <code>cam_height</code> 为相机原尺寸</li>
<li>图像传输时缩放了 0.5 倍，尺寸变为 812×620。</li>
</ul>
</blockquote>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>启动雷达：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch livox_ros_driver livox_lidar_msg.launch<br></code></pre></td></tr></table></figure>

<p>注意：这里我们启动的是Avia雷达的自定义消息格式，而非PointCloud2格式</p>
<p>启动相机:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch mvs_ros_pkg mvs_camera_trigger.launch<br></code></pre></td></tr></table></figure>

<p>Fast Livo2主节点启动:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">roslaunch fast_livo mapping_avia.launch<br></code></pre></td></tr></table></figure>

<p>建图效果，如下方所示：</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/52.jpg" alt="图62-实时rviz"></p>
<p style="text-align:center;">图62-实时rviz</p>

<h4 id="包数据分析"><a href="#包数据分析" class="headerlink" title="包数据分析"></a>包数据分析</h4><p>对齐效果 :</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/56.jpg" alt="图63-包对齐总览"></p>
<p style="text-align:center;">图63-包对齐总览</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/55.jpg" alt="图64-包对齐细节"></p>
<p style="text-align:center;">图64-包对齐细节</p>

<blockquote>
<ul>
<li>雷达 &#x2F; imu &#x2F; 图像均为10hz</li>
</ul>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="完全测试"><a href="#完全测试" class="headerlink" title="完全测试"></a>完全测试</h3><h4 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h4><p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/59.jpg" alt="图65-硬件设备设计图"></p>
<p style="text-align:center;">图65-硬件设备设计图</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/57.jpg" alt="图66-硬件设备实物图"></p>
<p style="text-align:center;">图66-硬件设备实物图</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/58.jpg" alt="图67-硬件设备实物图"></p>
<p style="text-align:center;">图67-硬件设备实物图</p>

<p>设备标注:</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/76.jpeg" alt="图68-硬件设备标注"></p>
<p style="text-align:center;">图68-硬件设备标注</p>

<p>设备接线:</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/75.jpeg" alt="图69-设备接线标注"></p>
<p style="text-align:center;">图69-设备接线标注</p>

<p>设备供电:</p>
<ol>
<li><p>使用一块4S航模电池为雷达 &#x2F; NUC供电</p>
<ul>
<li><p>4S航模电池直供NUC</p>
</li>
<li><p>4S航模电池经过Livox Converter 2.0降压连接雷达</p>
</li>
</ul>
</li>
<li><p>NUC为相机 &#x2F; 屏幕供电</p>
<ol>
<li><p>使用一块4S航模电池为雷达 &#x2F; NUC供电</p>
<ol>
<li>4S航模电池直供NUC</li>
<li>4S航模电池经过Livox Converter 2.0降压连接雷达</li>
</ol>
</li>
<li><p>NUC为相机 &#x2F; 屏幕供电</p>
</li>
</ol>
</li>
</ol>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/84.png" alt="图70-设备供电展示"></p>
<p style="text-align:center;">图70-设备供电展示</p>



<h4 id="建图精度-1"><a href="#建图精度-1" class="headerlink" title="建图精度"></a>建图精度</h4><p>表现 : 基本可以看清大色块纹理,也许需要更准确的标定数据?<strong>(存疑)</strong></p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/62.jpg" alt="图71-复杂墙面建图总览"></p>
<p style="text-align:center;">图71-复杂墙面建图总览</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/60.png" alt="图72-复杂墙面建图细节-1"></p>
<p style="text-align:center;">图72-复杂墙面建图细节-1</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/61.png" alt="图73-复杂墙面建图细节-2"></p>
<p style="text-align:center;">图73-复杂墙面建图细节-2</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/63.jpg" alt="图74-大号文字墙面建图"></p>
<p style="text-align:center;">图74-大号文字墙面建图</p>



<h4 id="回环精度"><a href="#回环精度" class="headerlink" title="回环精度"></a>回环精度</h4><p>表现 : 长距离回环 z轴有1.8m左右的漂移, x轴,y轴回环较为稳定</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/64.png" alt="图75-回环路径展示"></p>
<p style="text-align:center;">图75-回环路径展示</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/65.png" alt="图76-回环里程计数据-z轴"></p>
<p style="text-align:center;">图76-回环里程计数据-z轴</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/66.png" alt="图77-回环里程计数据-x轴(蓝)&#x2F;y轴(绿)"></p>
<p style="text-align:center;">图77-回环里程计数据-x轴(蓝)/y轴(绿)</p>



<h4 id="不同场景"><a href="#不同场景" class="headerlink" title="不同场景"></a>不同场景</h4><ol>
<li><p>12分钟+室内+室外</p>
<p>表现 : 里程计数据基本平滑 , 室外相机有过曝情况 , 代码里没有看到和论文中对应的自动调整曝光的部分,也没有发布自动曝光话题 <strong>(存疑)</strong></p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/71.jpg" alt="图78-室外场景实时rviz"></p>
<p style="text-align:center;">图78-室外场景实时rviz</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/67.jpg" alt="图79-室外场景里程计数据总览"></p>
<p style="text-align:center;">图79-室外场景里程计数据总览</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/68.png" alt="图80-室外场景里程计数据细节"></p>
<p style="text-align:center;">图80-室外场景里程计数据细节</p>
</li>
<li><p>室内</p>
<p>表现 : 玻璃会影响建图精度,从开发空间进入密闭空间(推门走进楼梯间)易造成错误建图</p>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/72.jpg" alt="图81-室内场景rviz-1"></p>
<p style="text-align:center;">图81-室内场景rviz-1</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/73.jpg" alt="图82-室内场景rviz-2"></p>
<p style="text-align:center;">图82-室内场景rviz-2</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/74.jpg" alt="图83-室内场景rviz-3"></p>
<p style="text-align:center;">图83-室内场景rviz-3</p>
</li>
<li><p>楼梯间</p>
<p>表现 : 跑飞,窗户处建图错误</p>
<p>推测 : 楼梯间狭窄且全为白墙,特征点少,avia雷达1-2m处点云质量差,存在盲区</p>
</li>
</ol>
<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/69.jpg" alt="图84-楼梯间rviz-1"></p>
<p style="text-align:center;">图84-楼梯间rviz-1</p>

<p><img src="/../images/%E5%A4%8D%E7%8E%B0FAST-LIVO2/70.jpg" alt="图85-楼梯间rviz-2"></p>
<p style="text-align:center;">图85-楼梯间rviz-2</p>

        </div>
        
            <div class="post-container">
            <aside class="toc-container">
                <button class="toc-toggle">文章目录</button>
                <nav class="toc" id="toc"></nav>
            </aside>
        </div>
        
    </div>


    <!-- 返回主页链接 -->
    <div class="text-center my-8">
        <a href="/" class="text-hacker-color1 underline hover:text-hacker-color2">← Back to Home</a>
    </div>

      
      <script src="/js/toc.js"></script>  <!-- 引入 TOC 逻辑 -->
      
      

    <footer class="bg-black text-gray-400 py-4">
    <div class="container mx-auto text-center">
      <p>© <span id="current-year"></span>  Li-shuangyi 
        <br> Powered by <a class="hover:text-white duration-150 hover:underline decoration-slice" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a class="hover:text-white duration-150 hover:underline decoration-slice" target="_blank" rel="noopener" href="https://github.com/m310ct/hexo-theme-hexploit">Hexpolit</a></p>
    </div>
  </footer>
  
  <script> 
    document.getElementById("current-year").textContent = new Date().getFullYear();
  </script>
  


</body>
</html>
