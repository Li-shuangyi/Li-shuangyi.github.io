<!DOCTYPE html>
<html lang="en">
<style>
    p{
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
        font-size: 1.1rem;
    }
    figure{
        margin: 0 !important;
    }
    pre{
        padding: 0 !important;
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
    }

    td{
        padding: 0 !important;
        margin-bottom: 1rem !important;
    }
    h1,h2,h3,h4,h5,h6{
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
    }
    @media (min-width: 1024px) {
        #middle-box{
            min-width: 56rem;
        }
    
    }
</style>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ether Blog - 网络算法基础</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/tailwind.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/toc.css">
    
<header class="bg-black text-hacker-white py-4 font-dos font-extrabold">
    <div class="container mx-auto flex items-center justify-between space-x-8">
    
      <h1 class="text-2xl font-bold ml-[100px] md:ml-0 animate-pulse text-hacker-color1 md:mr-[20%]">
        <a href="/" class="hover:text-white transition-colors select-none">
          Ether Blog
        </a>
      </h1>
  
    <!-- 大屏幕 -->
      <nav class="hidden md:block">
        <ul class="flex space-x-6">
          
            <li>
              <a href="/" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Home
              </a>
            </li>
          
            <li>
              <a href="/archives/" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Archives
              </a>
            </li>
          
            <li>
              <a href="/categories/" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Categories
              </a>
            </li>
          
            <li>
              <a href="/tags/" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Tags
              </a>
            </li>
          
            <li>
              <a href="/about/" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                About
              </a>
            </li>
          
            <li>
              <a href="/rss.xml" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                RSS
              </a>
            </li>
          
        </ul>
      </nav>
  
      <!-- 小屏幕 -->
      <button id="menu-toggle" class="block md:hidden text-white focus:outline-none">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16"></path>
        </svg>
      </button>
    </div>
  
    <!-- 折叠菜单 -->
    <nav id="mobile-menu" class="hidden bg-black">
      <ul class="space-y-2 py-4 px-6">
        
          <li>
            <a href="/" class="block text-white hover:text-hacker-color1 transition-colors">
              Home
            </a>
          </li>
        
          <li>
            <a href="/archives/" class="block text-white hover:text-hacker-color1 transition-colors">
              Archives
            </a>
          </li>
        
          <li>
            <a href="/categories/" class="block text-white hover:text-hacker-color1 transition-colors">
              Categories
            </a>
          </li>
        
          <li>
            <a href="/tags/" class="block text-white hover:text-hacker-color1 transition-colors">
              Tags
            </a>
          </li>
        
          <li>
            <a href="/about/" class="block text-white hover:text-hacker-color1 transition-colors">
              About
            </a>
          </li>
        
          <li>
            <a href="/rss.xml" class="block text-white hover:text-hacker-color1 transition-colors">
              RSS
            </a>
          </li>
        
      </ul>
    </nav>
  
    <!-- RSS Link -->
    <link rel="alternate" type="application/rss+xml" title=" RSS" href="/rss.xml" />
  </header>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="/js/search.js"></script>
  <script>
        document.addEventListener("DOMContentLoaded", () => {
    const menuToggle = document.getElementById("menu-toggle");
    const mobileMenu = document.getElementById("mobile-menu");

    menuToggle.addEventListener("click", () => {
        if (mobileMenu.classList.contains("hidden")) {
        mobileMenu.classList.remove("hidden");
        } else {
        mobileMenu.classList.add("hidden");
        }
    });
    });

  </script>
  

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>
<body class="bg-black text-hacker-color3 container mx-auto" style="overflow-x:hidden">
    <!-- 文章标题 -->
    <h1 class="text-5xl text-hacker-color1 font-bold font-dos my-6 text-center">网络算法基础</h1>

    <!-- 发布时间 -->
    <p class="text-hacker-color3 text-center text-sm mb-4">
        2025-02-27
    </p>

    <!-- 文章内容 -->
    <div id="article-content" class="article-entry prose prose-invert mx-auto max-w-4xl leading-relaxed highlight" style="display: flex;">
        <div id="middle-box">
            <h1 id="算法与分治"><a href="#算法与分治" class="headerlink" title="算法与分治"></a>算法与分治</h1><p>Divide and Conquer（DC）</p>
<p>Divide：将源问题分解为规模较小的子问题，<strong>拆分问题性质相同</strong>，将子问题的解组合成原问题的解。</p>
<p>Conquer：如果子问题仍然困难，就继续对子问题进行分解，直到子问题可以被trivial。</p>
<p>Recursion：用递归的方式实现。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>问题定义：</p>
<ul>
<li><p>输入：n个数构成的数组;</p>
</li>
<li><p>输出：排列该n个数的有序数组。</p>
</li>
</ul>
<p>Merg Sort：</p>
<ul>
<li>分解：将原数组等分为两个子数组;</li>
<li>求解：递归地对两个子数组分别排序;</li>
<li>合并：将两个已排序的子数组合并。</li>
</ul>
<h3 id="Merge-Step"><a href="#Merge-Step" class="headerlink" title="Merge Step"></a>Merge Step</h3><p> <strong>CLAIM</strong>：对于n ≥ 1的数组，MergeSort需要的运行时间T(n) ≤ $ 6n \log_2 n + 6n $</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/1.PNG" alt="图片" title="证明"></p>
<h3 id="函数增长的渐进符号"><a href="#函数增长的渐进符号" class="headerlink" title="函数增长的渐进符号"></a>函数增长的渐进符号</h3><p><strong>Big O</strong>: 如果存在正数c和N，对于所有的n&gt;&#x3D;N，有f(n)&lt;&#x3D;c*g(n)，则f(n)&#x3D;O(g(n))。</p>
<p><strong>Big Omega</strong>：如果存在正数c和N，对于所有的n&gt;&#x3D;N，有f(n)&gt;&#x3D;c*g(n)，则f(n)&#x3D;Omega(g(n))。</p>
<p><strong>Big Theta</strong>：f(n)&#x3D;Theta(g(n))，当且仅当f(n)&#x3D;O(g(n))且f(n)&#x3D;Omega(g(n))。</p>
<h3 id="基于比较的排序"><a href="#基于比较的排序" class="headerlink" title="基于比较的排序"></a>基于比较的排序</h3><p><strong>CLAIM</strong>：任何基于比较的排序算法，RT不可能低于O(nlogn)。</p>
<p>任何基于两两比较的排序算法都可以表达为一棵决策树（完全二叉树）。</p>
<p>完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/2.PNG" alt="图片" title="决策树的性质"></p>
<h3 id="主办法（Master-Method）"><a href="#主办法（Master-Method）" class="headerlink" title="主办法（Master Method）"></a>主办法（Master Method）</h3><p><strong>主定理</strong></p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/3.PNG" alt="图片" title="主定理的定义"></p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/4.PNG" alt="图片" title="主定理的证明"></p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/5.PNG" alt="图片" title="参数"></p>
<h1 id="图简介"><a href="#图简介" class="headerlink" title="图简介"></a>图简介</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><strong>树</strong>：不包含任何圈的连通图。</p>
<p><strong>生成树(Spanning Tree)</strong>：如果图G的一个子图包含了G的全部顶点，且为树，则称之为G的生成树。</p>
<h2 id="图搜索"><a href="#图搜索" class="headerlink" title="图搜索"></a>图搜索</h2><h3 id="循环不变式"><a href="#循环不变式" class="headerlink" title="循环不变式"></a>循环不变式</h3><ul>
<li>概念：每次循环开始时都要保持的性质 &#x2F; 状态。</li>
<li><strong>INVARIANT</strong>：已探索集合和未探索集合应该处于正确的状态。边界点集合应准备好了。<ul>
<li>循环开始时，从边界点集合中选择一个顶点进行探索。</li>
<li>循环结束前，将新扩展的边界点纳入集合。</li>
</ul>
</li>
<li>维护边界点集合：<ul>
<li><strong>BFS：队列(FIFO)</strong></li>
<li><strong>DFS：堆栈(LIFO)</strong></li>
</ul>
</li>
</ul>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>BFS的伪代码：</p>
<pre><code>BFS(Graph, start):
B.EnQueue(s)
WHILE B is not empty:
    d=B.DeQueue();
    标记d为“已探索”
    FOR each neighbor t of d:
        IF t is not in visited:
            B.EnQueue(t)
        ENDIF
    ENDFOR
ENDWHILE
</code></pre>
<p><strong>聚合分析复杂度</strong>：O(n+m)</p>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>DFS的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">DFS(Graph, start):<br>B.Push(s)<br>WHILE B is not empty:<br> d = B.Pop()<br> 标记 d 为“已探索”<br> FOR each neighbor t of d:<br>  IF t is not in visited:<br>   B.Push(t)<br>  ENDIF<br> ENDFOR<br>ENDWHILE<br></code></pre></td></tr></table></figure>

<p><strong>聚合分析复杂度</strong>：O(n+m)</p>
<h2 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h2><h3 id="无向图的连通分量"><a href="#无向图的连通分量" class="headerlink" title="无向图的连通分量"></a><u>无向图</u>的连通分量</h3><p>下述等价关系的等价类：当且仅当图中具有u-v路径时，称u~v。</p>
<h4 id="BFS求无向连通分量"><a href="#BFS求无向连通分量" class="headerlink" title="BFS求无向连通分量"></a>BFS求无向连通分量</h4><p>BFS求无向连通分量的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Loop-BFS(G):<br>FOR i=1 to n<br>	IF t is not in visited:<br>		BFS(G,i);<br>ENDFOR<br></code></pre></td></tr></table></figure>

<p><strong>聚合分析复杂度</strong>：O(n+m)</p>
<h3 id="有向图的强连通分量（Strongly-Connected-Component-SCC）"><a href="#有向图的强连通分量（Strongly-Connected-Component-SCC）" class="headerlink" title="有向图的强连通分量（Strongly Connected Component,SCC）"></a><u>有向图</u>的强连通分量（Strongly Connected Component,SCC）</h3><p>下述等价关系的等价类：当且仅当有向图G中具有u -&gt; v路径且具有v -&gt; u路径时，称称u~v。</p>
<h4 id="TWO-PASS算法-Kosaraju算法"><a href="#TWO-PASS算法-Kosaraju算法" class="headerlink" title="TWO-PASS算法(Kosaraju算法)"></a>TWO-PASS算法(Kosaraju算法)</h4><ol>
<li>构建逆图。</li>
<li><strong>在逆图中进行 Loop-DFS</strong>，记录每个节点的<strong>完成时间</strong> f(v)。</li>
<li><strong>在原图中运行 Loop-DFS</strong>，按照逆图 DFS 完成的节点顺序进行，确定每个节点的 Leader。</li>
</ol>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/6.PNG" alt="图片" title="Kosaraju算法-1"></p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/7.PNG" alt="图片" title="Kosaraju算法-2"></p>
<p><strong>聚合分析复杂度</strong>：O(n+m)</p>
<h4 id="关键引理"><a href="#关键引理" class="headerlink" title="关键引理"></a><strong>关键引理</strong></h4><p>Key Lemma：考虑有向图G中的两个临接SCC，f(v)表示顶点v在反向图G’中Loop-DFS的完成时间，则有：<br>$$<br>\max_{v \in C_1} f(v) &lt; \max_{v \in C_2} f(v)<br>$$<br>推论：最大的f值必然在”sink“SCC中。</p>
<h1 id="贪心MST"><a href="#贪心MST" class="headerlink" title="贪心MST"></a>贪心MST</h1><h2 id="贪心vs分治"><a href="#贪心vs分治" class="headerlink" title="贪心vs分治"></a>贪心vs分治</h2><ul>
<li><strong>决策过程</strong>：<ul>
<li><strong>分治</strong>：每个子问题的解都会考虑整个子问题的情况，逐步拆解，最终合并。</li>
<li><strong>贪心</strong>：每一步决策只关注当前的局部最优解，不回头。</li>
</ul>
</li>
<li><strong>全局与局部</strong>：<ul>
<li><strong>分治</strong>：每个子问题的解可能涉及整个问题的全局结构。</li>
<li><strong>贪心</strong>：每一步只考虑局部最优解，期望通过局部最优解得到全局最优解。</li>
</ul>
</li>
<li><strong>解决问题的方式</strong>：<ul>
<li><strong>分治</strong>：递归地分解问题，直到子问题足够简单直接求解。</li>
<li><strong>贪心</strong>：通过逐步选择当前最优的解来构建最终解。</li>
</ul>
</li>
<li><strong>是否需要回溯</strong>：<ul>
<li><strong>分治</strong>：通常会回溯并合并结果。</li>
<li><strong>贪心</strong>：不会回溯，一旦做出选择就不再修改。</li>
</ul>
</li>
</ul>
<h2 id="MST（前提：无向图）"><a href="#MST（前提：无向图）" class="headerlink" title="MST（前提：无向图）"></a>MST（前提：无向图）</h2><p><strong>定义</strong>：最小权重生成树T。</p>
<ul>
<li>必须是无向图;</li>
<li>生成树的权重定义为树上边权重之和;</li>
<li>生成树定义为E的子集：<ol>
<li>必须覆盖V;</li>
<li>无环;</li>
<li>连通。</li>
</ol>
</li>
</ul>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/8.PNG" alt="图片" title="MST"></p>
<h3 id="割"><a href="#割" class="headerlink" title="割"></a>割</h3><p>割的概念：图G(V，E)的一个割(Cut)是V的一个划分，该划分将集合V分为两个非空的集合。</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/9.PNG" alt="图片" title="割"></p>
<ul>
<li>n个顶点的图最多有 $ 2^n-2 $ 个不同的割。</li>
</ul>
<p><strong>Empty-Cut引理</strong>：图G不连通，当且仅当Cut(A，B)没有割边。</p>
<p><strong>Double-Crossing Lemma</strong>：如果某个圈C⊆E中有边跨越了Cut(A，B)，则C中<strong>至少还有一条边</strong>跨越Cut(A，B)。</p>
<p><strong>Lonely-Cut Corollary</strong>：如果边e是跨越了Cut(A，B)的唯一一条边，则e不可能在<strong>任一</strong>圈中。</p>
<p><strong>The Cut Property</strong>：考虑图G中的一条边e，如果存在Cut(A，B)，使得e是所有跨越该割的所有边中权最小者，则e一定在G的MST中。</p>
<p>割的证明：</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/10.PNG" alt="图片" title="割的证明-1"></p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/11.PNG" alt="图片" title="割的证明-2"></p>
<h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><p>一个容器，其中元素具有key。</p>
<p>常规操作及对应的RT：</p>
<ul>
<li>Heapify：建堆 O(n)</li>
<li>Insert：加入一个新的对象 O(logn)</li>
<li>Extract-Min：从堆中取出具有最小key的元素 O(logn)</li>
<li>Delete：删除指定元素 O(logn)</li>
</ul>
<h4 id="Heap-Property"><a href="#Heap-Property" class="headerlink" title="Heap Property"></a><strong>Heap Property</strong></h4><ul>
<li>堆是一颗有根，二叉，尽可能完全的树。</li>
<li>任何节点的key都不大于其所有子代的key。 ——&gt; <strong>根元素具有最小key</strong></li>
</ul>
<h4 id="用数组实现堆"><a href="#用数组实现堆" class="headerlink" title="用数组实现堆"></a><strong>用数组实现堆</strong></h4><ul>
<li>Parent (i) &#x3D; i &#x2F; 2  （下标i为奇数时向下取整）</li>
<li>LeftC (i) &#x3D; 2i</li>
<li>RightC (i) &#x3D; 2i + 1</li>
</ul>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/12.PNG" alt="图片" title="堆的操作-1"></p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/13.PNG" alt="图片" title="堆的操作-2"></p>
<h3 id="Prime算法"><a href="#Prime算法" class="headerlink" title="Prime算法"></a><strong>Prime算法</strong></h3><p>基本思想：</p>
<ul>
<li>从一个节点开始（任意选择一个节点作为起点），将它加入生成树。</li>
<li>找到当前生成树中所有节点与其他节点之间的边，选择权重最小的边。</li>
<li>将与该边相连的节点加入生成树，更新最小边的权重，重复选择最小边的过程。</li>
<li>直到所有节点都被加入到生成树中。</li>
</ul>
<p>Pim的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Prim(Graph, start):<br>    初始化最小生成树的边集合 MST = &#123;&#125;<br>    初始化一个优先队列 Q，用于存储每个节点及其最小边的权重<br>    对于每个节点 v ∈ Graph:<br>        设置 v 的最小权重为无穷大（∞）<br>    设置 start 节点的最小权重为 0，并将其加入 Q<br><br>    WHILE Q is not empty:<br>        选择 Q 中最小的权重的节点 u<br>        标记 u 为“已加入到最小生成树”<br><br>        对于 u 的每个邻居 v:<br>            IF v is not in MST AND weight(u, v) &lt; v 的当前权重:<br>                更新 v 的最小权重为 weight(u, v)<br>                将 v 更新到 Q 中，以反映其新的最小权重<br><br>        ENDFOR<br>    ENDWHILE<br></code></pre></td></tr></table></figure>

<p>Prim算法的证明：</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/14.PNG" alt="图片" title="Prim的证明-1"></p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/15.PNG" alt="图片" title="Prim的证明-2"></p>
<p>用堆实现Prim：</p>
<pre><code>Prim(Graph, start):
    初始化最小生成树 MST = &#123;&#125;
    初始化最小堆 MinHeap
    初始化一个集合 Visited，用于记录已加入 MST 的节点
    将 (0, start) 插入 MinHeap  // (边的权重, 节点)
    初始化 total_weight = 0  // 记录最小生成树的总权重	
	WHILE MinHeap is not empty:
    	(weight, node) = MinHeap.Pop()  // 取出当前权重最小的边
   	 IF node 已在 Visited:
    	    CONTINUE  // 如果该节点已经在 MST 中，跳过

  	  标记 node 为已访问
  	  total_weight += weight  // 累加权重
  	  MST.Add(node)

	    FOR each (neighbor, edge_weight) in Graph[node]:  // 遍历邻居
     	   IF neighbor 不在 Visited:
       	     MinHeap.Push((edge_weight, neighbor))  // 只加入未访问的节点

	RETURN MST, total_weight
</code></pre>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>n次Extract-Min：O(nlogn)</li>
<li>m次Delete和m次Insert：O(mlogn)</li>
</ul>
<p>总RT &#x3D; O(nlogn)+O(mlogn) &#x3D; <strong>O(mlogn)</strong></p>
<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>基本思想：</p>
<ul>
<li>按权重升序对边排序。</li>
<li>按序逐条检查边。</li>
<li>只要不成环，就将边加入T。</li>
</ul>
<p>Kruskal的伪代码：</p>
<pre><code>Kruskal(Graph):
    初始化最小生成树 MST = &#123;&#125;
    初始化并查集（Union-Find）来管理连通性
    按照权重从小到大排序 Graph 的所有边 EdgeList
	FOR (u, v, weight) in EdgeList:  // 遍历排序后的边
   	 IF u 和 v 不在同一个连通分量 (Find(u) ≠ Find(v)):
    	    MST.Add((u, v, weight))  // 加入最小生成树
  	      Union(u, v)  // 合并连通分量
  	  IF MST 的边数 == V - 1:
     	   BREAK  // 最小生成树构建完成
	RETURN MST
</code></pre>
<p>Kruskal算法的证明：</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/16.PNG" alt="图片" title="Kruskal的证明-1"></p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/17.PNG" alt="图片" title="Kruskal的证明-2"></p>
<h4 id="UNION-FIND算法"><a href="#UNION-FIND算法" class="headerlink" title="UNION-FIND算法"></a>UNION-FIND算法</h4><p>Union-Find（并查集）是一种高效的数据结构，主要用于<strong>处理动态连通性问题</strong>。它支持两种核心操作：</p>
<ol>
<li><strong>Find(x)</strong>：查找元素 <code>x</code> 所属的集合（返回它的代表元素）。</li>
<li><strong>Union(x, y)</strong>：合并 <code>x</code> 和 <code>y</code> 所在的两个集合。</li>
</ol>
<p>核心思想：</p>
<ul>
<li><strong>每个集合用一棵树表示</strong>，树的根节点作为该集合的<strong>代表元</strong>（代表元素）。</li>
<li><strong>Find(x)</strong> 操作用于查找 <code>x</code> 所在集合的代表元（根节点）。</li>
<li><strong>Union(x, y)</strong> 操作用于合并两个集合，<strong>将其中一个集合的根节点指向另一个集合的根</strong>。</li>
</ul>
<h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><p>Dijkstra的前提：<strong>无负权图（源点到第一层点的权重可为负值），避免负圈。</strong></p>
<p>Dijkstra的基本思路：</p>
<ol>
<li>初始化：</li>
</ol>
<ul>
<li>设 <code>dist[s] = 0</code>（起点到自身的距离为 0），其他所有点 <code>dist[v] = ∞</code>（起始时认为未知）。</li>
<li>用一个**优先队列（最小堆）**维护当前已发现的最短距离点。</li>
</ul>
<ol start="2">
<li>贪心扩展：</li>
</ol>
<ul>
<li>每次从<strong>未访问的节点中选取当前 <code>dist[v]</code> 最小的点 <code>u</code></strong>。</li>
<li>遍历 u的所有邻居 v，尝试松弛：<ul>
<li><strong>如果 <code>dist[u] + w(u, v) &lt; dist[v]</code>，更新 <code>dist[v]</code></strong>，并将 <code>v</code> 加入优先队列。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>终止：所有节点均已访问，或优先队列为空（所有可达点已确定最短路径）。</li>
</ol>
<p>Dijkstra的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Dijkstra(Graph, start):<br>    初始化 dist[]，所有点设为 ∞，dist[start] = 0<br>    初始化优先队列 PQ，插入 (0, start)  // (当前最短距离, 顶点)<br>    初始化 visited[] 记录已确定最短路径的点<br><br>    WHILE PQ 不为空:<br>        (d, u) = PQ.Pop()  // 取出当前最短距离的点<br>        IF u 已访问:<br>            CONTINUE<br>        标记 u 为已访问<br><br>        FOR each 邻居 (v, weight) of u:<br>            IF dist[u] + weight &lt; dist[v]:  // 进行松弛操作<br>                dist[v] = dist[u] + weight<br>                PQ.Push((dist[v], v))  // 将 v 加入优先队列<br>    <br>    RETURN dist[]<br></code></pre></td></tr></table></figure>

<h2 id="循环桶"><a href="#循环桶" class="headerlink" title="循环桶"></a>循环桶</h2><p><strong>桶（Bucket）</strong> 是一种数据存储和分类的方法，可以根据某种规则（如哈希值、时间、范围等）<strong>将数据映射到不同的桶中</strong>，以加快查询、存储或计算的效率。</p>
<p>循环桶将数据按照一定规则分配到有限个桶（Bucket）中，并循环使用这些桶。</p>
<h3 id="循环桶的核心特点"><a href="#循环桶的核心特点" class="headerlink" title="循环桶的核心特点"></a>循环桶的核心特点</h3><ol>
<li>固定数量的桶（N 个）：<ul>
<li>设定 <code>N</code> 个桶，编号从 <code>0</code> 到 <code>N-1</code>，它们按照顺序<strong>排列成一个循环结构</strong>。</li>
<li>访问时<strong>基于取模（modulo）运算</strong>，保证访问永远落在 <code>0 ~ N-1</code> 之间。</li>
</ul>
</li>
<li>循环访问（Modulo 取模）：<ul>
<li>计算索引 <code>index = (当前时间 t) % N</code>，从而使得时间到了 <code>N</code> 之后会回到 <code>0</code>，形成循环管理。</li>
</ul>
</li>
</ol>
<h3 id="用循环桶实现Dijkstra算法："><a href="#用循环桶实现Dijkstra算法：" class="headerlink" title="用循环桶实现Dijkstra算法："></a>用循环桶实现Dijkstra算法：</h3><p><strong>CLAIM</strong>：Dijkstra算法中最多只需要C+1个桶。</p>
<ul>
<li>永久标记的顶点和非边界顶点不在桶中。</li>
<li>边界点的距离标记不会超过A[i]+C（i为当前标记点）</li>
<li>顶点x的桶的编号：A[x]mod(C+1)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Dijkstra_CircularBucket(Graph, start):<br>    初始化 dist[]，所有点设为 ∞，dist[start] = 0<br>    初始化桶 Bucket[]，桶的数量为 C+1，存储每个距离区间的节点<br>    初始化 visited[]，记录顶点是否已被永久标记<br>    <br>    将起点 start 放入 Bucket[0] 中（dist[start] = 0）<br>    <br>    WHILE 有节点未被永久标记:<br>        从桶中找出具有最小距离的非永久标记的边界点 u<br>        标记 u 为永久标记，并从桶中移除 u<br>        <br>        FOR 每个邻居 v of u:<br>            IF v 没有被永久标记:<br>                IF dist[u] + w(u, v) &lt; dist[v]:<br>                    dist[v] = dist[u] + w(u, v)  // 松弛操作<br>                    将 v 放入 Bucket[dist[v] mod (C + 1)] 中  // 根据 dist[v] 放入桶<br>                    更新 v 的距离标记<br><br>    RETURN dist[]<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：O(m+nC)</p>
<h2 id="Dijsktra算法扩展"><a href="#Dijsktra算法扩展" class="headerlink" title="Dijsktra算法扩展"></a>Dijsktra算法扩展</h2><h3 id="单源单宿最短路问题"><a href="#单源单宿最短路问题" class="headerlink" title="单源单宿最短路问题"></a>单源单宿最短路问题</h3><p>问题描述：给定图G，给定顶点s和d，求从s到d的最小权重路径。</p>
<p>解决方式：增加一个判断分支，d被永久标记时终止循环。</p>
<p>1111111111111111</p>

        </div>
        
            <div class="post-container">
            <aside class="toc-container">
                <button class="toc-toggle">文章目录</button>
                <nav class="toc" id="toc"></nav>
            </aside>
        </div>
        
    </div>


    <!-- 返回主页链接 -->
    <div class="text-center my-8">
        <a href="/" class="text-hacker-color1 underline hover:text-hacker-color2">← Back to Home</a>
    </div>

      
      <script src="/js/toc.js"></script>  <!-- 引入 TOC 逻辑 -->
      
      

    <footer class="bg-black text-gray-400 py-4">
    <div class="container mx-auto text-center">
      <p>© <span id="current-year"></span>  Li-shuangyi 
        <br> Powered by <a class="hover:text-white duration-150 hover:underline decoration-slice" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a class="hover:text-white duration-150 hover:underline decoration-slice" target="_blank" rel="noopener" href="https://github.com/m310ct/hexo-theme-hexploit">Hexpolit</a></p>
    </div>
  </footer>
  
  <script> 
    document.getElementById("current-year").textContent = new Date().getFullYear();
  </script>
  


</body>
</html>
