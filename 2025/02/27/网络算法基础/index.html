<!DOCTYPE html>
<html lang="en">
<style>
    p{
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
        font-size: 1.1rem;
    }
    figure{
        margin: 0 !important;
    }
    pre{
        padding: 0 !important;
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
    }

    td{
        padding: 0 !important;
        margin-bottom: 1rem !important;
    }
    h1,h2,h3,h4,h5,h6{
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
    }
</style>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ether Blog - 网络算法基础</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/tailwind.css">
    <link rel="stylesheet" href="/css/highlight.css">
    
<header class="bg-black text-hacker-white py-4 font-dos font-extrabold">
    <div class="container mx-auto flex items-center justify-between space-x-8">
    
      <h1 class="text-2xl font-bold ml-[100px] md:ml-0 animate-pulse text-hacker-color1 md:mr-[20%]">
        <a href="/" class="hover:text-white transition-colors select-none">
          Ether Blog
        </a>
      </h1>
  
    <!-- 大屏幕 -->
      <nav class="hidden md:block">
        <ul class="flex space-x-6">
          
            <li>
              <a href="/" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Home
              </a>
            </li>
          
            <li>
              <a href="/archives" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Archives
              </a>
            </li>
          
            <li>
              <a href="/categories" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Categories
              </a>
            </li>
          
            <li>
              <a href="/tags" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Tags
              </a>
            </li>
          
            <li>
              <a href="/about" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                About
              </a>
            </li>
          
            <li>
              <a href="/rss.xml" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                RSS
              </a>
            </li>
          
        </ul>
      </nav>
  
      <!-- 小屏幕 -->
      <button id="menu-toggle" class="block md:hidden text-white focus:outline-none">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16"></path>
        </svg>
      </button>
    </div>
  
    <!-- 折叠菜单 -->
    <nav id="mobile-menu" class="hidden bg-black">
      <ul class="space-y-2 py-4 px-6">
        
          <li>
            <a href="/" class="block text-white hover:text-hacker-color1 transition-colors">
              Home
            </a>
          </li>
        
          <li>
            <a href="/archives" class="block text-white hover:text-hacker-color1 transition-colors">
              Archives
            </a>
          </li>
        
          <li>
            <a href="/categories" class="block text-white hover:text-hacker-color1 transition-colors">
              Categories
            </a>
          </li>
        
          <li>
            <a href="/tags" class="block text-white hover:text-hacker-color1 transition-colors">
              Tags
            </a>
          </li>
        
          <li>
            <a href="/about" class="block text-white hover:text-hacker-color1 transition-colors">
              About
            </a>
          </li>
        
          <li>
            <a href="/rss.xml" class="block text-white hover:text-hacker-color1 transition-colors">
              RSS
            </a>
          </li>
        
      </ul>
    </nav>
  
    <!-- RSS Link -->
    <link rel="alternate" type="application/rss+xml" title=" RSS" href="/rss.xml" />
  </header>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="/js/search.js"></script>
  <script>
        document.addEventListener("DOMContentLoaded", () => {
    const menuToggle = document.getElementById("menu-toggle");
    const mobileMenu = document.getElementById("mobile-menu");

    menuToggle.addEventListener("click", () => {
        if (mobileMenu.classList.contains("hidden")) {
        mobileMenu.classList.remove("hidden");
        } else {
        mobileMenu.classList.add("hidden");
        }
    });
    });

  </script>
  

<meta name="generator" content="Hexo 7.3.0"></head>
<body class="bg-black text-hacker-color3 container mx-auto">
    <!-- 文章标题 -->
    <h1 class="text-5xl text-hacker-color1 font-bold font-dos my-6 text-center">网络算法基础</h1>

    <!-- 发布时间 -->
    <p class="text-hacker-color3 text-center text-sm mb-4">
        2025-02-27
    </p>

    <!-- 文章内容 -->
    <div id="article-content" class="article-entry prose prose-invert mx-auto max-w-4xl leading-relaxed highlight">
        <h1 id="算法与分治"><a href="#算法与分治" class="headerlink" title="算法与分治"></a>算法与分治</h1><p>Divide and Conquer（DC）</p>
<p>Divide：将源问题分解为规模较小的子问题，<strong>拆分问题性质相同</strong>，将子问题的解组合成原问题的解。</p>
<p>Conquer：如果子问题仍然困难，就继续对子问题进行分解，直到子问题可以被trivial。</p>
<p>Recursion：用递归的方式实现。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>问题定义：</p>
<ul>
<li><p>输入：n个数构成的数组;</p>
</li>
<li><p>输出：排列该n个数的有序数组。</p>
</li>
</ul>
<p>Merg Sort：</p>
<ul>
<li>分解：将原数组等分为两个子数组;</li>
<li>求解：递归地对两个子数组分别排序;</li>
<li>合并：将两个已排序的子数组合并。</li>
</ul>
<h3 id="Merge-Step"><a href="#Merge-Step" class="headerlink" title="Merge Step"></a>Merge Step</h3><p> <strong>CLAIM</strong>：对于n ≥ 1的数组，MergeSort需要的运行时间T(n) ≤ $ 6n \log_2 n + 6n $</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/1.PNG" alt="图片" title="证明"></p>
<h3 id="函数增长的渐进符号"><a href="#函数增长的渐进符号" class="headerlink" title="函数增长的渐进符号"></a>函数增长的渐进符号</h3><p><strong>Big O</strong>: 如果存在正数c和N，对于所有的n&gt;&#x3D;N，有f(n)&lt;&#x3D;c*g(n)，则f(n)&#x3D;O(g(n))。</p>
<p><strong>Big Omega</strong>：如果存在正数c和N，对于所有的n&gt;&#x3D;N，有f(n)&gt;&#x3D;c*g(n)，则f(n)&#x3D;Omega(g(n))。</p>
<p><strong>Big Theta</strong>：f(n)&#x3D;Theta(g(n))，当且仅当f(n)&#x3D;O(g(n))且f(n)&#x3D;Omega(g(n))。</p>
<h3 id="基于比较的排序"><a href="#基于比较的排序" class="headerlink" title="基于比较的排序"></a>基于比较的排序</h3><p><strong>CLAIM</strong>：任何基于比较的排序算法，RT不可能低于O(nlogn)。</p>
<p>任何基于两两比较的排序算法都可以表达为一棵决策树（完全二叉树）。</p>
<p>完全二叉树：完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/2.PNG" alt="图片" title="决策树的性质"></p>
<h3 id="主办法（Master-Method）"><a href="#主办法（Master-Method）" class="headerlink" title="主办法（Master Method）"></a>主办法（Master Method）</h3><p><strong>主定理</strong></p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/3.PNG" alt="图片" title="主定理的定义"></p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/4.PNG" alt="图片" title="主定理的证明"></p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/5.PNG" alt="图片" title="参数"></p>
<h1 id="图简介"><a href="#图简介" class="headerlink" title="图简介"></a>图简介</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><strong>树</strong>：不包含任何圈的连通图。</p>
<p><strong>生成树(Spanning Tree)</strong>：如果图G的一个子图包含了G的全部顶点，且为树，则称之为G的生成树。</p>
<h2 id="图搜索"><a href="#图搜索" class="headerlink" title="图搜索"></a>图搜索</h2><h3 id="循环不变式"><a href="#循环不变式" class="headerlink" title="循环不变式"></a>循环不变式</h3><ul>
<li>概念：每次循环开始时都要保持的性质 &#x2F; 状态。</li>
<li><strong>INVARIANT</strong>：已探索集合和未探索集合应该处于正确的状态。边界点集合应准备好了。<ul>
<li>循环开始时，从边界点集合中选择一个顶点进行探索。</li>
<li>循环结束前，将新扩展的边界点纳入集合。</li>
</ul>
</li>
<li>维护边界点集合：<ul>
<li><strong>BFS：队列(FIFO)</strong></li>
<li><strong>DFS：堆栈(LIFO)</strong></li>
</ul>
</li>
</ul>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>BFS的伪代码：</p>
<pre><code>BFS(Graph, start):
B.EnQueue(s)
WHILE B is not empty:
    d=B.DeQueue();
    标记d为“已探索”
    FOR each neighbor t of d:
        IF t is not in visited:
            B.EnQueue(t)
        ENDIF
    ENDFOR
ENDWHILE
</code></pre>
<p><strong>聚合分析复杂度</strong>：O(n+m)</p>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>DFS的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">DFS(Graph, start):<br>B.Push(s)<br>WHILE B is not empty:<br> d = B.Pop()<br> 标记 d 为“已探索”<br> FOR each neighbor t of d:<br>  IF t is not in visited:<br>   B.Push(t)<br>  ENDIF<br> ENDFOR<br>ENDWHILE<br></code></pre></td></tr></table></figure>

<p><strong>聚合分析复杂度</strong>：O(n+m)</p>
<h2 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h2><h3 id="无向图的连通分量"><a href="#无向图的连通分量" class="headerlink" title="无向图的连通分量"></a><u>无向图</u>的连通分量</h3><p>下述等价关系的等价类：当且仅当图中具有u-v路径时，称u~v。</p>
<h4 id="BFS求无向连通分量"><a href="#BFS求无向连通分量" class="headerlink" title="BFS求无向连通分量"></a>BFS求无向连通分量</h4><p>BFS求无向连通分量的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Loop-BFS(G):<br>FOR i=1 to n<br>	IF t is not in visited:<br>		BFS(G,i);<br>ENDFOR<br></code></pre></td></tr></table></figure>

<p><strong>聚合分析复杂度</strong>：O(n+m)</p>
<h3 id="有向图的强连通分量（Strongly-Connected-Component-SCC）"><a href="#有向图的强连通分量（Strongly-Connected-Component-SCC）" class="headerlink" title="有向图的强连通分量（Strongly Connected Component,SCC）"></a><u>有向图</u>的强连通分量（Strongly Connected Component,SCC）</h3><p>下述等价关系的等价类：当且仅当有向图G中具有u -&gt; v路径且具有v -&gt; u路径时，称称u~v。</p>
<h4 id="TWO-PASS算法-Kosaraju算法"><a href="#TWO-PASS算法-Kosaraju算法" class="headerlink" title="TWO-PASS算法(Kosaraju算法)"></a>TWO-PASS算法(Kosaraju算法)</h4><ol>
<li>构建逆图。</li>
<li><strong>在逆图中进行 Loop-DFS</strong>，记录每个节点的<strong>完成时间</strong> f(v)。</li>
<li><strong>在原图中运行 Loop-DFS</strong>，按照逆图 DFS 完成的节点顺序进行，确定每个节点的 Leader。</li>
</ol>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/6.PNG" alt="图片" title="Kosaraju算法-1"></p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/7.PNG" alt="图片" title="Kosaraju算法-2"></p>
<p><strong>聚合分析复杂度</strong>：O(n+m)</p>
<h4 id="关键引理"><a href="#关键引理" class="headerlink" title="关键引理"></a><strong>关键引理</strong></h4><p>Key Lemma：考虑有向图G中的两个临接SCC，f(v)表示顶点v在反向图G’中Loop-DFS的完成时间，则有：<br>$$<br>\max_{v \in C_1} f(v) &lt; \max_{v \in C_2} f(v)<br>$$<br>推论：最大的f值必然在”sink“SCC中。</p>
<h1 id="贪心MST"><a href="#贪心MST" class="headerlink" title="贪心MST"></a>贪心MST</h1><h2 id="贪心vs分治"><a href="#贪心vs分治" class="headerlink" title="贪心vs分治"></a>贪心vs分治</h2><ul>
<li><strong>决策过程</strong>：<ul>
<li><strong>分治</strong>：每个子问题的解都会考虑整个子问题的情况，逐步拆解，最终合并。</li>
<li><strong>贪心</strong>：每一步决策只关注当前的局部最优解，不回头。</li>
</ul>
</li>
<li><strong>全局与局部</strong>：<ul>
<li><strong>分治</strong>：每个子问题的解可能涉及整个问题的全局结构。</li>
<li><strong>贪心</strong>：每一步只考虑局部最优解，期望通过局部最优解得到全局最优解。</li>
</ul>
</li>
<li><strong>解决问题的方式</strong>：<ul>
<li><strong>分治</strong>：递归地分解问题，直到子问题足够简单直接求解。</li>
<li><strong>贪心</strong>：通过逐步选择当前最优的解来构建最终解。</li>
</ul>
</li>
<li><strong>是否需要回溯</strong>：<ul>
<li><strong>分治</strong>：通常会回溯并合并结果。</li>
<li><strong>贪心</strong>：不会回溯，一旦做出选择就不再修改。</li>
</ul>
</li>
</ul>
<h2 id="MST（前提：无向图）"><a href="#MST（前提：无向图）" class="headerlink" title="MST（前提：无向图）"></a>MST（前提：无向图）</h2><p><strong>定义</strong>：最小权重生成树T。</p>
<ul>
<li>必须是无向图;</li>
<li>生成树的权重定义为树上边权重之和;</li>
<li>生成树定义为E的子集：<ol>
<li>必须覆盖V;</li>
<li>无环;</li>
<li>连通。</li>
</ol>
</li>
</ul>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/8.PNG" alt="图片" title="MST"></p>
<h3 id="割"><a href="#割" class="headerlink" title="割"></a>割</h3><p>割的概念：图G(V，E)的一个割(Cut)是V的一个划分，该划分将集合V分为两个非空的集合。</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/9.PNG" alt="图片" title="割"></p>
<ul>
<li>n个顶点的图最多有 $ 2^n-2 $ 个不同的割。</li>
</ul>
<p><strong>Empty-Cut引理</strong>：图G不连通，当且仅当Cut(A，B)没有割边。</p>
<p><strong>Double-Crossing Lemma</strong>：如果某个圈C⊆E中有边跨越了Cut(A，B)，则C中<strong>至少还有一条边</strong>跨越Cut(A，B)。</p>
<p><strong>Lonely-Cut Corollary</strong>：如果边e是跨越了Cut(A，B)的唯一一条边，则e不可能在<strong>任一</strong>圈中。</p>
<p><strong>The Cut Property</strong>：考虑图G中的一条边e，如果存在Cut(A，B)，使得e是所有跨越该割的所有边中权最小者，则e一定在G的MST中。</p>
<p>割的证明：</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/10.PNG" alt="图片" title="割的证明-1"></p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/11.PNG" alt="图片" title="割的证明-2"></p>
<h3 id="Prime算法"><a href="#Prime算法" class="headerlink" title="Prime算法"></a><strong>Prime算法</strong></h3><p>基本思想：</p>
<ul>
<li>从一个节点开始（任意选择一个节点作为起点），将它加入生成树。</li>
<li>找到当前生成树中所有节点与其他节点之间的边，选择权重最小的边。</li>
<li>将与该边相连的节点加入生成树，更新最小边的权重，重复选择最小边的过程。</li>
<li>直到所有节点都被加入到生成树中。</li>
</ul>
<p>Pim的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Prim(Graph, start):<br>    初始化最小生成树的边集合 MST = &#123;&#125;<br>    初始化一个优先队列 Q，用于存储每个节点及其最小边的权重<br>    对于每个节点 v ∈ Graph:<br>        设置 v 的最小权重为无穷大（∞）<br>    设置 start 节点的最小权重为 0，并将其加入 Q<br><br>    WHILE Q is not empty:<br>        选择 Q 中最小的权重的节点 u<br>        标记 u 为“已加入到最小生成树”<br><br>        对于 u 的每个邻居 v:<br>            IF v is not in MST AND weight(u, v) &lt; v 的当前权重:<br>                更新 v 的最小权重为 weight(u, v)<br>                将 v 更新到 Q 中，以反映其新的最小权重<br><br>        ENDFOR<br>    ENDWHILE<br></code></pre></td></tr></table></figure>

<p>Prim算法的证明：</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/12.PNG" alt="图片" title="Prim的证明-1"><br><img src="/images/%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/13.PNG" alt="图片" title="Prim的证明-2"></p>

    </div>

    <!-- 返回主页链接 -->
    <div class="text-center my-8">
        <a href="/" class="text-hacker-color1 underline hover:text-hacker-color2">← Back to Home</a>
    </div>

    <footer class="bg-black text-gray-400 py-4">
    <div class="container mx-auto text-center">
      <p>© <span id="current-year"></span>  Li-shuangyi 
        <br> Powered by <a class="hover:text-white duration-150 hover:underline decoration-slice" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a class="hover:text-white duration-150 hover:underline decoration-slice" target="_blank" rel="noopener" href="https://github.com/m310ct/hexo-theme-hexploit">Hexpolit</a></p>
    </div>
  </footer>
  
  <script> 
    document.getElementById("current-year").textContent = new Date().getFullYear();
  </script>
  


</body>
</html>
